{"ast":null,"code":"/**\n * react-table\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n!function (e, t) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? t(exports, require(\"react\")) : \"function\" == typeof define && define.amd ? define([\"exports\", \"react\"], t) : t((e = \"undefined\" != typeof globalThis ? globalThis : e || self).ReactTable = {}, e.React);\n}(this, function (e, t) {\n  \"use strict\";\n\n  function n(e) {\n    if (e && e.__esModule) return e;\n    var t = Object.create(null);\n    return e && Object.keys(e).forEach(function (n) {\n      if (\"default\" !== n) {\n        var l = Object.getOwnPropertyDescriptor(e, n);\n        Object.defineProperty(t, n, l.get ? l : {\n          enumerable: !0,\n          get: function () {\n            return e[n];\n          }\n        });\n      }\n    }), t.default = e, Object.freeze(t);\n  }\n\n  var l = n(t);\n  /**\n     * table-core\n     *\n     * Copyright (c) TanStack\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE.md file in the root directory of this source tree.\n     *\n     * @license MIT\n     */\n\n  function o(e, t) {\n    return \"function\" == typeof e ? e(t) : e;\n  }\n\n  function i(e, t) {\n    return n => {\n      t.setState(t => ({ ...t,\n        [e]: o(n, t[e])\n      }));\n    };\n  }\n\n  function r(e) {\n    return e instanceof Function;\n  }\n\n  function u(e, t) {\n    const n = [],\n          l = e => {\n      e.forEach(e => {\n        n.push(e);\n        const o = t(e);\n        null != o && o.length && l(o);\n      });\n    };\n\n    return l(e), n;\n  }\n\n  function a(e, t, n) {\n    let l,\n        o = [];\n    return () => {\n      let i;\n      n.key && n.debug && (i = Date.now());\n      const r = e();\n      if (!(r.length !== o.length || r.some((e, t) => o[t] !== e))) return l;\n      let u;\n\n      if (o = r, n.key && n.debug && (u = Date.now()), l = t(...r), null == n || null == n.onChange || n.onChange(l), n.key && n.debug && null != n && n.debug()) {\n        const e = Math.round(100 * (Date.now() - i)) / 100,\n              t = Math.round(100 * (Date.now() - u)) / 100,\n              l = t / 16,\n              o = (e, t) => {\n          for (e = String(e); e.length < t;) e = \" \" + e;\n\n          return e;\n        };\n\n        console.info(\"%c⏱ \" + o(t, 5) + \" /\" + o(e, 5) + \" ms\", \"\\n            font-size: .6rem;\\n            font-weight: bold;\\n            color: hsl(\" + Math.max(0, Math.min(120 - 120 * l, 120)) + \"deg 100% 31%);\", null == n ? void 0 : n.key);\n      }\n\n      return l;\n    };\n  }\n\n  function s(e, t, n, l) {\n    var o, i;\n\n    const r = e._getDefaultColumnDef();\n\n    let u,\n        s = null != (o = null != (i = (t = { ...r,\n      ...t\n    }).id) ? i : t.accessorKey) ? o : \"string\" == typeof t.header ? t.header : void 0;\n    if (t.accessorFn ? u = t.accessorFn : t.accessorKey && (u = e => e[t.accessorKey]), !s) throw new Error();\n    let g = {\n      id: \"\" + s,\n      accessorFn: u,\n      parent: l,\n      depth: n,\n      columnDef: t,\n      columnDefType: t.columnDefType,\n      columns: [],\n      getFlatColumns: a(() => [!0], () => {\n        var e;\n        return [g, ...(null == (e = g.columns) ? void 0 : e.flatMap(e => e.getFlatColumns()))];\n      }, {\n        key: \"column.getFlatColumns\",\n        debug: () => {\n          var t;\n          return null != (t = e.options.debugAll) ? t : e.options.debugColumns;\n        }\n      }),\n      getLeafColumns: a(() => [e._getOrderColumnsFn()], e => {\n        var t;\n\n        if (null != (t = g.columns) && t.length) {\n          let t = g.columns.flatMap(e => e.getLeafColumns());\n          return e(t);\n        }\n\n        return [g];\n      }, {\n        key: \"column.getLeafColumns\",\n        debug: () => {\n          var t;\n          return null != (t = e.options.debugAll) ? t : e.options.debugColumns;\n        }\n      })\n    };\n    return g = e._features.reduce((t, n) => Object.assign(t, null == n.createColumn ? void 0 : n.createColumn(g, e)), g), g;\n  }\n\n  function g(e, t, n) {\n    var l;\n    let o = {\n      id: null != (l = n.id) ? l : t.id,\n      column: t,\n      index: n.index,\n      isPlaceholder: !!n.isPlaceholder,\n      placeholderId: n.placeholderId,\n      depth: n.depth,\n      subHeaders: [],\n      colSpan: 0,\n      rowSpan: 0,\n      headerGroup: null,\n      getLeafHeaders: () => {\n        const e = [],\n              t = n => {\n          n.subHeaders && n.subHeaders.length && n.subHeaders.map(t), e.push(n);\n        };\n\n        return t(o), e;\n      },\n      renderHeader: () => t.columnDef.header ? e._render(t.columnDef.header, {\n        instance: e,\n        header: o,\n        column: t\n      }) : null,\n      renderFooter: () => t.columnDef.footer ? e._render(t.columnDef.footer, {\n        instance: e,\n        header: o,\n        column: t\n      }) : null\n    };\n    return e._features.forEach(t => {\n      Object.assign(o, null == t.createHeader ? void 0 : t.createHeader(o, e));\n    }), o;\n  }\n\n  const d = {\n    createInstance: e => ({\n      getHeaderGroups: a(() => [e.getAllColumns(), e.getVisibleLeafColumns(), e.getState().columnPinning.left, e.getState().columnPinning.right], (t, n, l, o) => {\n        var i, r;\n        const u = null != (i = null == l ? void 0 : l.map(e => n.find(t => t.id === e)).filter(Boolean)) ? i : [],\n              a = null != (r = null == o ? void 0 : o.map(e => n.find(t => t.id === e)).filter(Boolean)) ? r : [];\n        return c(t, [...u, ...n.filter(e => !(null != l && l.includes(e.id) || null != o && o.includes(e.id))), ...a], e);\n      }, {\n        key: !1,\n        debug: () => {\n          var t;\n          return null != (t = e.options.debugAll) ? t : e.options.debugHeaders;\n        }\n      }),\n      getCenterHeaderGroups: a(() => [e.getAllColumns(), e.getVisibleLeafColumns(), e.getState().columnPinning.left, e.getState().columnPinning.right], (t, n, l, o) => c(t, n = n.filter(e => !(null != l && l.includes(e.id) || null != o && o.includes(e.id))), e, \"center\"), {\n        key: !1,\n        debug: () => {\n          var t;\n          return null != (t = e.options.debugAll) ? t : e.options.debugHeaders;\n        }\n      }),\n      getLeftHeaderGroups: a(() => [e.getAllColumns(), e.getVisibleLeafColumns(), e.getState().columnPinning.left], (t, n, l) => {\n        var o;\n        return c(t, null != (o = null == l ? void 0 : l.map(e => n.find(t => t.id === e)).filter(Boolean)) ? o : [], e, \"left\");\n      }, {\n        key: !1,\n        debug: () => {\n          var t;\n          return null != (t = e.options.debugAll) ? t : e.options.debugHeaders;\n        }\n      }),\n      getRightHeaderGroups: a(() => [e.getAllColumns(), e.getVisibleLeafColumns(), e.getState().columnPinning.right], (t, n, l) => {\n        var o;\n        return c(t, null != (o = null == l ? void 0 : l.map(e => n.find(t => t.id === e)).filter(Boolean)) ? o : [], e, \"right\");\n      }, {\n        key: !1,\n        debug: () => {\n          var t;\n          return null != (t = e.options.debugAll) ? t : e.options.debugHeaders;\n        }\n      }),\n      getFooterGroups: a(() => [e.getHeaderGroups()], e => [...e].reverse(), {\n        key: !1,\n        debug: () => {\n          var t;\n          return null != (t = e.options.debugAll) ? t : e.options.debugHeaders;\n        }\n      }),\n      getLeftFooterGroups: a(() => [e.getLeftHeaderGroups()], e => [...e].reverse(), {\n        key: !1,\n        debug: () => {\n          var t;\n          return null != (t = e.options.debugAll) ? t : e.options.debugHeaders;\n        }\n      }),\n      getCenterFooterGroups: a(() => [e.getCenterHeaderGroups()], e => [...e].reverse(), {\n        key: !1,\n        debug: () => {\n          var t;\n          return null != (t = e.options.debugAll) ? t : e.options.debugHeaders;\n        }\n      }),\n      getRightFooterGroups: a(() => [e.getRightHeaderGroups()], e => [...e].reverse(), {\n        key: !1,\n        debug: () => {\n          var t;\n          return null != (t = e.options.debugAll) ? t : e.options.debugHeaders;\n        }\n      }),\n      getFlatHeaders: a(() => [e.getHeaderGroups()], e => e.map(e => e.headers).flat(), {\n        key: !1,\n        debug: () => {\n          var t;\n          return null != (t = e.options.debugAll) ? t : e.options.debugHeaders;\n        }\n      }),\n      getLeftFlatHeaders: a(() => [e.getLeftHeaderGroups()], e => e.map(e => e.headers).flat(), {\n        key: !1,\n        debug: () => {\n          var t;\n          return null != (t = e.options.debugAll) ? t : e.options.debugHeaders;\n        }\n      }),\n      getCenterFlatHeaders: a(() => [e.getCenterHeaderGroups()], e => e.map(e => e.headers).flat(), {\n        key: !1,\n        debug: () => {\n          var t;\n          return null != (t = e.options.debugAll) ? t : e.options.debugHeaders;\n        }\n      }),\n      getRightFlatHeaders: a(() => [e.getRightHeaderGroups()], e => e.map(e => e.headers).flat(), {\n        key: !1,\n        debug: () => {\n          var t;\n          return null != (t = e.options.debugAll) ? t : e.options.debugHeaders;\n        }\n      }),\n      getCenterLeafHeaders: a(() => [e.getCenterFlatHeaders()], e => e.filter(e => {\n        var t;\n        return !(null != (t = e.subHeaders) && t.length);\n      }), {\n        key: !1,\n        debug: () => {\n          var t;\n          return null != (t = e.options.debugAll) ? t : e.options.debugHeaders;\n        }\n      }),\n      getLeftLeafHeaders: a(() => [e.getLeftFlatHeaders()], e => e.filter(e => {\n        var t;\n        return !(null != (t = e.subHeaders) && t.length);\n      }), {\n        key: !1,\n        debug: () => {\n          var t;\n          return null != (t = e.options.debugAll) ? t : e.options.debugHeaders;\n        }\n      }),\n      getRightLeafHeaders: a(() => [e.getRightFlatHeaders()], e => e.filter(e => {\n        var t;\n        return !(null != (t = e.subHeaders) && t.length);\n      }), {\n        key: !1,\n        debug: () => {\n          var t;\n          return null != (t = e.options.debugAll) ? t : e.options.debugHeaders;\n        }\n      }),\n      getLeafHeaders: a(() => [e.getLeftHeaderGroups(), e.getCenterHeaderGroups(), e.getRightHeaderGroups()], (e, t, n) => {\n        var l, o, i, r, u, a;\n        return [...(null != (l = null == (o = e[0]) ? void 0 : o.headers) ? l : []), ...(null != (i = null == (r = t[0]) ? void 0 : r.headers) ? i : []), ...(null != (u = null == (a = n[0]) ? void 0 : a.headers) ? u : [])].map(e => e.getLeafHeaders()).flat();\n      }, {\n        key: !1,\n        debug: () => {\n          var t;\n          return null != (t = e.options.debugAll) ? t : e.options.debugHeaders;\n        }\n      })\n    })\n  };\n\n  function c(e, t, n, l) {\n    var o, i;\n    let r = 0;\n\n    const u = function (e, t) {\n      void 0 === t && (t = 1), r = Math.max(r, t), e.filter(e => e.getIsVisible()).forEach(e => {\n        var n;\n        null != (n = e.columns) && n.length && u(e.columns, t + 1);\n      }, 0);\n    };\n\n    u(e);\n    let a = [];\n\n    const s = (e, t) => {\n      const o = {\n        depth: t,\n        id: [l, \"\" + t].filter(Boolean).join(\"_\"),\n        headers: []\n      },\n            i = [];\n      e.forEach(e => {\n        const r = [...i].reverse()[0];\n        let u,\n            a = !1;\n        if (e.column.depth === o.depth && e.column.parent ? u = e.column.parent : (u = e.column, a = !0), (null == r ? void 0 : r.column) === u) r.subHeaders.push(e);else {\n          const o = g(n, u, {\n            id: [l, t, u.id, null == e ? void 0 : e.id].filter(Boolean).join(\"_\"),\n            isPlaceholder: a,\n            placeholderId: a ? \"\" + i.filter(e => e.column === u).length : void 0,\n            depth: t,\n            index: i.length\n          });\n          o.subHeaders.push(e), i.push(o);\n        }\n        o.headers.push(e), e.headerGroup = o;\n      }), a.push(o), t > 0 && s(i, t - 1);\n    },\n          d = t.map((e, t) => g(n, e, {\n      depth: r,\n      index: t\n    }));\n\n    s(d, r - 1), a.reverse();\n\n    const c = e => e.filter(e => e.column.getIsVisible()).map(e => {\n      let t = 0,\n          n = 0,\n          l = [0];\n      e.subHeaders && e.subHeaders.length ? (l = [], c(e.subHeaders).forEach(e => {\n        let {\n          colSpan: n,\n          rowSpan: o\n        } = e;\n        t += n, l.push(o);\n      })) : t = 1;\n      return n += Math.min(...l), e.colSpan = t, e.rowSpan = n, {\n        colSpan: t,\n        rowSpan: n\n      };\n    });\n\n    return c(null != (o = null == (i = a[0]) ? void 0 : i.headers) ? o : []), a;\n  }\n\n  const p = {\n    size: 150,\n    minSize: 20,\n    maxSize: Number.MAX_SAFE_INTEGER\n  },\n        f = {\n    getDefaultColumnDef: () => p,\n    getInitialState: e => ({\n      columnSizing: {},\n      columnSizingInfo: {\n        startOffset: null,\n        startSize: null,\n        deltaOffset: null,\n        deltaPercentage: null,\n        isResizingColumn: !1,\n        columnSizingStart: []\n      },\n      ...e\n    }),\n    getDefaultOptions: e => ({\n      columnResizeMode: \"onEnd\",\n      onColumnSizingChange: i(\"columnSizing\", e),\n      onColumnSizingInfoChange: i(\"columnSizingInfo\", e)\n    }),\n    createColumn: (e, t) => ({\n      getSize: () => {\n        var n, l, o;\n        const i = t.getState().columnSizing[e.id];\n        return Math.min(Math.max(null != (n = e.columnDef.minSize) ? n : p.minSize, null != (l = null != i ? i : e.columnDef.size) ? l : p.size), null != (o = e.columnDef.maxSize) ? o : p.maxSize);\n      },\n      getStart: n => {\n        const l = n ? \"left\" === n ? t.getLeftVisibleLeafColumns() : t.getRightVisibleLeafColumns() : t.getVisibleLeafColumns(),\n              o = l.findIndex(t => t.id === e.id);\n\n        if (o > 0) {\n          const e = l[o - 1];\n          return e.getStart(n) + e.getSize();\n        }\n\n        return 0;\n      },\n      resetSize: () => {\n        t.setColumnSizing(t => {\n          let {\n            [e.id]: n,\n            ...l\n          } = t;\n          return l;\n        });\n      },\n      getCanResize: () => {\n        var n, l;\n        return (null == (n = e.columnDef.enableResizing) || n) && (null == (l = t.options.enableColumnResizing) || l);\n      },\n      getIsResizing: () => t.getState().columnSizingInfo.isResizingColumn === e.id\n    }),\n    createHeader: (e, t) => ({\n      getSize: () => {\n        let t = 0;\n\n        const n = e => {\n          var l;\n          e.subHeaders.length ? e.subHeaders.forEach(n) : t += null != (l = e.column.getSize()) ? l : 0;\n        };\n\n        return n(e), t;\n      },\n      getStart: () => {\n        if (e.index > 0) {\n          const t = e.headerGroup.headers[e.index - 1];\n          return t.getStart() + t.getSize();\n        }\n\n        return 0;\n      },\n      getResizeHandler: () => {\n        const n = t.getColumn(e.column.id),\n              l = n.getCanResize();\n        return o => {\n          if (!l) return;\n          if (null == o.persist || o.persist(), w(o) && o.touches && o.touches.length > 1) return;\n\n          const i = e.getSize(),\n                r = e ? e.getLeafHeaders().map(e => [e.column.id, e.column.getSize()]) : [[n.id, n.getSize()]],\n                u = w(o) ? Math.round(o.touches[0].clientX) : o.clientX,\n                a = (e, n) => {\n            if (\"number\" != typeof n) return;\n            let l = {};\n            t.setColumnSizingInfo(e => {\n              var t, o;\n              const i = n - (null != (t = null == e ? void 0 : e.startOffset) ? t : 0),\n                    r = Math.max(i / (null != (o = null == e ? void 0 : e.startSize) ? o : 0), -.999999);\n              return e.columnSizingStart.forEach(e => {\n                let [t, n] = e;\n                l[t] = Math.round(100 * Math.max(n + n * r, 0)) / 100;\n              }), { ...e,\n                deltaOffset: i,\n                deltaPercentage: r\n              };\n            }), \"onChange\" !== t.options.columnResizeMode && \"end\" !== e || t.setColumnSizing(e => ({ ...e,\n              ...l\n            }));\n          },\n                s = {\n            moveHandler: e => {\n              return t = e.clientX, a(\"move\", t);\n              var t;\n            },\n            upHandler: e => {\n              var n;\n              document.removeEventListener(\"mousemove\", s.moveHandler), document.removeEventListener(\"mouseup\", s.upHandler), n = e.clientX, a(\"end\", n), t.setColumnSizingInfo(e => ({ ...e,\n                isResizingColumn: !1,\n                startOffset: null,\n                startSize: null,\n                deltaOffset: null,\n                deltaPercentage: null,\n                columnSizingStart: []\n              }));\n            }\n          },\n                g = !!b() && {\n            passive: !1\n          };\n\n          w(o) || (document.addEventListener(\"mousemove\", s.moveHandler, g), document.addEventListener(\"mouseup\", s.upHandler, g)), t.setColumnSizingInfo(e => ({ ...e,\n            startOffset: u,\n            startSize: i,\n            deltaOffset: 0,\n            deltaPercentage: 0,\n            columnSizingStart: r,\n            isResizingColumn: n.id\n          }));\n        };\n      }\n    }),\n    createInstance: e => ({\n      setColumnSizing: t => null == e.options.onColumnSizingChange ? void 0 : e.options.onColumnSizingChange(t),\n      setColumnSizingInfo: t => null == e.options.onColumnSizingInfoChange ? void 0 : e.options.onColumnSizingInfoChange(t),\n      resetColumnSizing: t => {\n        var n;\n        e.setColumnSizing(t ? {} : null != (n = e.initialState.columnSizing) ? n : {});\n      },\n      resetHeaderSizeInfo: t => {\n        var n;\n        e.setColumnSizingInfo(t ? {\n          startOffset: null,\n          startSize: null,\n          deltaOffset: null,\n          deltaPercentage: null,\n          isResizingColumn: !1,\n          columnSizingStart: []\n        } : null != (n = e.initialState.columnSizingInfo) ? n : {\n          startOffset: null,\n          startSize: null,\n          deltaOffset: null,\n          deltaPercentage: null,\n          isResizingColumn: !1,\n          columnSizingStart: []\n        });\n      },\n      getTotalSize: () => {\n        var t, n;\n        return null != (t = null == (n = e.getHeaderGroups()[0]) ? void 0 : n.headers.reduce((e, t) => e + t.getSize(), 0)) ? t : 0;\n      },\n      getLeftTotalSize: () => {\n        var t, n;\n        return null != (t = null == (n = e.getLeftHeaderGroups()[0]) ? void 0 : n.headers.reduce((e, t) => e + t.getSize(), 0)) ? t : 0;\n      },\n      getCenterTotalSize: () => {\n        var t, n;\n        return null != (t = null == (n = e.getCenterHeaderGroups()[0]) ? void 0 : n.headers.reduce((e, t) => e + t.getSize(), 0)) ? t : 0;\n      },\n      getRightTotalSize: () => {\n        var t, n;\n        return null != (t = null == (n = e.getRightHeaderGroups()[0]) ? void 0 : n.headers.reduce((e, t) => e + t.getSize(), 0)) ? t : 0;\n      }\n    })\n  };\n  let m = null;\n\n  function b() {\n    if (\"boolean\" == typeof m) return m;\n    let e = !1;\n\n    try {\n      const t = {\n        get passive() {\n          return e = !0, !1;\n        }\n\n      },\n            n = () => {};\n\n      window.addEventListener(\"test\", n, t), window.removeEventListener(\"test\", n);\n    } catch (t) {\n      e = !1;\n    }\n\n    return m = e, m;\n  }\n\n  function w(e) {\n    return \"touchstart\" === e.type;\n  }\n\n  const v = {\n    getInitialState: e => ({\n      expanded: {},\n      ...e\n    }),\n    getDefaultOptions: e => ({\n      onExpandedChange: i(\"expanded\", e),\n      autoResetExpanded: !0,\n      paginateExpandedRows: !0\n    }),\n    createInstance: e => {\n      let t = !1,\n          n = !1;\n      return {\n        _autoResetExpanded: () => {\n          if (t) {\n            if (!1 !== e.options.autoResetAll && (!0 === e.options.autoResetAll || e.options.autoResetExpanded)) {\n              if (n) return;\n              n = !0, e._queue(() => {\n                e.resetExpanded(), n = !1;\n              });\n            }\n          } else e._queue(() => {\n            t = !0;\n          });\n        },\n        setExpanded: t => null == e.options.onExpandedChange ? void 0 : e.options.onExpandedChange(t),\n        toggleAllRowsExpanded: t => {\n          (null != t ? t : !e.getIsAllRowsExpanded()) ? e.setExpanded(!0) : e.setExpanded({});\n        },\n        resetExpanded: t => {\n          var n, l;\n          e.setExpanded(t ? {} : null != (n = null == (l = e.initialState) ? void 0 : l.expanded) ? n : {});\n        },\n        getCanSomeRowsExpand: () => e.getRowModel().flatRows.some(e => e.getCanExpand()),\n        getToggleAllRowsExpandedHandler: () => t => {\n          null == t.persist || t.persist(), e.toggleAllRowsExpanded();\n        },\n        getIsSomeRowsExpanded: () => {\n          const t = e.getState().expanded;\n          return !0 === t || Object.values(t).some(Boolean);\n        },\n        getIsAllRowsExpanded: () => {\n          const t = e.getState().expanded;\n          return \"boolean\" == typeof t ? !0 === t : !!Object.keys(t).length && !e.getRowModel().flatRows.some(e => e.getIsExpanded());\n        },\n        getExpandedDepth: () => {\n          let t = 0;\n          return (!0 === e.getState().expanded ? Object.keys(e.getRowModel().rowsById) : Object.keys(e.getState().expanded)).forEach(e => {\n            const n = e.split(\".\");\n            t = Math.max(t, n.length);\n          }), t;\n        },\n        getPreExpandedRowModel: () => e.getGroupedRowModel(),\n        getExpandedRowModel: () => (!e._getExpandedRowModel && e.options.getExpandedRowModel && (e._getExpandedRowModel = e.options.getExpandedRowModel(e)), e.options.manualExpanding || !e._getExpandedRowModel ? e.getPreExpandedRowModel() : e._getExpandedRowModel())\n      };\n    },\n    createRow: (e, t) => ({\n      toggleExpanded: n => {\n        t.setExpanded(l => {\n          var o;\n          const i = !0 === l || !(null == l || !l[e.id]);\n          let r = {};\n          if (!0 === l ? Object.keys(t.getRowModel().rowsById).forEach(e => {\n            r[e] = !0;\n          }) : r = l, n = null != (o = n) ? o : !i, !i && n) return { ...r,\n            [e.id]: !0\n          };\n\n          if (i && !n) {\n            const {\n              [e.id]: t,\n              ...n\n            } = r;\n            return n;\n          }\n\n          return l;\n        });\n      },\n      getIsExpanded: () => {\n        var n;\n        const l = t.getState().expanded;\n        return !!(null != (n = null == t.options.getIsRowExpanded ? void 0 : t.options.getIsRowExpanded(e)) ? n : !0 === l || (null == l ? void 0 : l[e.id]));\n      },\n      getCanExpand: () => {\n        var n, l, o;\n        return (null == (n = null == t.options.getRowCanExpand ? void 0 : t.options.getRowCanExpand(e)) || n) && (null == (l = t.options.enableExpanding) || l) && !(null == (o = e.subRows) || !o.length);\n      },\n      getToggleExpandedHandler: () => {\n        const t = e.getCanExpand();\n        return () => {\n          t && e.toggleExpanded();\n        };\n      }\n    })\n  },\n        C = (e, t, n) => {\n    const l = n.toLowerCase();\n    return e.getValue(t).toLowerCase().includes(l);\n  };\n\n  C.autoRemove = e => x(e);\n\n  const h = (e, t, n) => e.getValue(t).includes(n);\n\n  h.autoRemove = e => x(e);\n\n  const S = (e, t, n) => e.getValue(t).toLowerCase() === n.toLowerCase();\n\n  S.autoRemove = e => x(e);\n\n  const R = (e, t, n) => e.getValue(t).includes(n);\n\n  R.autoRemove = e => x(e) || !(null != e && e.length);\n\n  const F = (e, t, n) => !n.some(n => !e.getValue(t).includes(n));\n\n  F.autoRemove = e => x(e) || !(null != e && e.length);\n\n  const M = (e, t, n) => n.some(n => e.getValue(t).includes(n));\n\n  M.autoRemove = e => x(e) || !(null != e && e.length);\n\n  const y = (e, t, n) => e.getValue(t) === n;\n\n  y.autoRemove = e => x(e);\n\n  const I = (e, t, n) => e.getValue(t) == n;\n\n  I.autoRemove = e => x(e);\n\n  const V = (e, t, n) => {\n    let [l, o] = n;\n    const i = e.getValue(t);\n    return i >= l && i <= o;\n  };\n\n  V.resolveFilterValue = e => {\n    let [t, n] = e,\n        l = \"number\" != typeof t ? parseFloat(t) : t,\n        o = \"number\" != typeof n ? parseFloat(n) : n,\n        i = null === t || Number.isNaN(l) ? -1 / 0 : l,\n        r = null === n || Number.isNaN(o) ? 1 / 0 : o;\n\n    if (i > r) {\n      const e = i;\n      i = r, r = e;\n    }\n\n    return [i, r];\n  }, V.autoRemove = e => x(e) || x(e[0]) && x(e[1]);\n  const _ = {\n    includesString: C,\n    includesStringSensitive: h,\n    equalsString: S,\n    arrIncludes: R,\n    arrIncludesAll: F,\n    arrIncludesSome: M,\n    equals: y,\n    weakEquals: I,\n    inNumberRange: V\n  };\n\n  function x(e) {\n    return null == e || \"\" === e;\n  }\n\n  const A = {\n    getDefaultColumnDef: () => ({\n      filterFn: \"auto\"\n    }),\n    getInitialState: e => ({\n      columnFilters: [],\n      globalFilter: void 0,\n      ...e\n    }),\n    getDefaultOptions: e => ({\n      onColumnFiltersChange: i(\"columnFilters\", e),\n      onGlobalFilterChange: i(\"globalFilter\", e),\n      filterFromLeafRows: !1,\n      globalFilterFn: \"auto\",\n      getColumnCanGlobalFilter: t => {\n        var n, l;\n        return \"string\" == typeof (null == (n = e.getCoreRowModel().flatRows[0]) || null == (l = n._getAllCellsByColumnId()[t.id]) ? void 0 : l.getValue());\n      }\n    }),\n    createColumn: (e, t) => ({\n      getAutoFilterFn: () => {\n        const n = t.getCoreRowModel().flatRows[0],\n              l = null == n ? void 0 : n.getValue(e.id);\n        return \"string\" == typeof l ? _.includesString : \"number\" == typeof l ? _.inNumberRange : \"boolean\" == typeof l || null !== l && \"object\" == typeof l ? _.equals : Array.isArray(l) ? _.arrIncludes : _.weakEquals;\n      },\n      getFilterFn: () => {\n        var n;\n        const l = t.options.filterFns;\n        return r(e.columnDef.filterFn) ? e.columnDef.filterFn : \"auto\" === e.columnDef.filterFn ? e.getAutoFilterFn() : null != (n = null == l ? void 0 : l[e.columnDef.filterFn]) ? n : _[e.columnDef.filterFn];\n      },\n      getCanFilter: () => {\n        var n, l, o;\n        return (null == (n = e.columnDef.enableColumnFilter) || n) && (null == (l = t.options.enableColumnFilters) || l) && (null == (o = t.options.enableFilters) || o) && !!e.accessorFn;\n      },\n      getCanGlobalFilter: () => {\n        var n, l, o, i;\n        return (null == (n = e.columnDef.enableGlobalFilter) || n) && (null == (l = t.options.enableGlobalFilter) || l) && (null == (o = t.options.enableFilters) || o) && (null == (i = null == t.options.getColumnCanGlobalFilter ? void 0 : t.options.getColumnCanGlobalFilter(e)) || i) && !!e.accessorFn;\n      },\n      getIsFiltered: () => e.getFilterIndex() > -1,\n      getFilterValue: () => {\n        var n, l;\n        return null == (n = t.getState().columnFilters) || null == (l = n.find(t => t.id === e.id)) ? void 0 : l.value;\n      },\n      getFilterIndex: () => {\n        var n, l;\n        return null != (n = null == (l = t.getState().columnFilters) ? void 0 : l.findIndex(t => t.id === e.id)) ? n : -1;\n      },\n      setFilterValue: n => {\n        t.setColumnFilters(t => {\n          const l = e.getFilterFn(),\n                i = null == t ? void 0 : t.find(t => t.id === e.id),\n                r = o(n, i ? i.value : void 0);\n          var u;\n          if (P(l, r, e)) return null != (u = null == t ? void 0 : t.filter(t => t.id !== e.id)) ? u : [];\n          const a = {\n            id: e.id,\n            value: r\n          };\n          var s;\n          return i ? null != (s = null == t ? void 0 : t.map(t => t.id === e.id ? a : t)) ? s : [] : null != t && t.length ? [...t, a] : [a];\n        });\n      },\n      _getFacetedRowModel: t.options.getFacetedRowModel && t.options.getFacetedRowModel(t, e.id),\n      getFacetedRowModel: () => e._getFacetedRowModel ? e._getFacetedRowModel() : t.getPreFilteredRowModel(),\n      _getFacetedUniqueValues: t.options.getFacetedUniqueValues && t.options.getFacetedUniqueValues(t, e.id),\n      getFacetedUniqueValues: () => e._getFacetedUniqueValues ? e._getFacetedUniqueValues() : new Map(),\n      _getFacetedMinMaxValues: t.options.getFacetedMinMaxValues && t.options.getFacetedMinMaxValues(t, e.id),\n      getFacetedMinMaxValues: () => {\n        if (e._getFacetedMinMaxValues) return e._getFacetedMinMaxValues();\n      }\n    }),\n    createRow: (e, t) => ({\n      columnFilters: {},\n      columnFiltersMeta: {}\n    }),\n    createInstance: e => ({\n      getGlobalAutoFilterFn: () => _.includesString,\n      getGlobalFilterFn: () => {\n        var t;\n        const {\n          filterFns: n,\n          globalFilterFn: l\n        } = e.options;\n        return r(l) ? l : \"auto\" === l ? e.getGlobalAutoFilterFn() : null != (t = null == n ? void 0 : n[l]) ? t : _[l];\n      },\n      setColumnFilters: t => {\n        const n = e.getAllLeafColumns();\n        null == e.options.onColumnFiltersChange || e.options.onColumnFiltersChange(e => {\n          var l;\n          return null == (l = o(t, e)) ? void 0 : l.filter(e => {\n            const t = n.find(t => t.id === e.id);\n\n            if (t) {\n              if (P(t.getFilterFn(), e.value, t)) return !1;\n            }\n\n            return !0;\n          });\n        });\n      },\n      setGlobalFilter: t => {\n        null == e.options.onGlobalFilterChange || e.options.onGlobalFilterChange(t);\n      },\n      resetGlobalFilter: t => {\n        e.setGlobalFilter(t ? void 0 : e.initialState.globalFilter);\n      },\n      resetColumnFilters: t => {\n        var n, l;\n        e.setColumnFilters(t ? [] : null != (n = null == (l = e.initialState) ? void 0 : l.columnFilters) ? n : []);\n      },\n      getPreFilteredRowModel: () => e.getCoreRowModel(),\n      _getFilteredRowModel: e.options.getFilteredRowModel && e.options.getFilteredRowModel(e),\n      getFilteredRowModel: () => e.options.manualFiltering || !e._getFilteredRowModel ? e.getPreFilteredRowModel() : e._getFilteredRowModel(),\n      _getGlobalFacetedRowModel: e.options.getFacetedRowModel && e.options.getFacetedRowModel(e, \"__global__\"),\n      getGlobalFacetedRowModel: () => e.options.manualFiltering || !e._getGlobalFacetedRowModel ? e.getPreFilteredRowModel() : e._getGlobalFacetedRowModel(),\n      _getGlobalFacetedUniqueValues: e.options.getFacetedUniqueValues && e.options.getFacetedUniqueValues(e, \"__global__\"),\n      getGlobalFacetedUniqueValues: () => e._getGlobalFacetedUniqueValues ? e._getGlobalFacetedUniqueValues() : new Map(),\n      _getGlobalFacetedMinMaxValues: e.options.getFacetedMinMaxValues && e.options.getFacetedMinMaxValues(e, \"__global__\"),\n      getGlobalFacetedMinMaxValues: () => {\n        if (e._getGlobalFacetedMinMaxValues) return e._getGlobalFacetedMinMaxValues();\n      }\n    })\n  };\n\n  function P(e, t, n) {\n    return !(!e || !e.autoRemove) && e.autoRemove(t, n) || void 0 === t || \"string\" == typeof t && !t;\n  }\n\n  const E = {\n    sum: (e, t, n) => n.reduce((e, t) => e + (\"number\" == typeof t ? t : 0), 0),\n    min: (e, t, n) => {\n      let l;\n      return n.forEach(t => {\n        const n = t.getValue(e);\n        null != n && (l > n || void 0 === l && n >= n) && (l = n);\n      }), l;\n    },\n    max: (e, t, n) => {\n      let l;\n      return n.forEach(t => {\n        const n = t.getValue(e);\n        null != n && (l < n || void 0 === l && n >= n) && (l = n);\n      }), l;\n    },\n    extent: (e, t, n) => {\n      let l, o;\n      return n.forEach(t => {\n        const n = t.getValue(e);\n        null != n && (void 0 === l ? n >= n && (l = o = n) : (l > n && (l = n), o < n && (o = n)));\n      }), [l, o];\n    },\n    mean: (e, t) => {\n      let n = 0,\n          l = 0;\n      if (t.forEach(t => {\n        let o = t.getValue(e);\n        null != o && (o = +o) >= o && (++n, l += o);\n      }), n) return l / n;\n    },\n    median: (e, t) => {\n      if (!t.length) return;\n      let n = 0,\n          l = 0;\n      return t.forEach(t => {\n        let o = t.getValue(e);\n        \"number\" == typeof o && (n = Math.min(n, o), l = Math.max(l, o));\n      }), (n + l) / 2;\n    },\n    unique: (e, t) => Array.from(new Set(t.map(t => t.getValue(e))).values()),\n    uniqueCount: (e, t) => new Set(t.map(t => t.getValue(e))).size,\n    count: (e, t) => t.length\n  },\n        G = {\n    getDefaultColumnDef: () => ({\n      aggregatedCell: e => {\n        var t, n;\n        return null != (t = null == (n = e.getValue()) || null == n.toString ? void 0 : n.toString()) ? t : null;\n      },\n      aggregationFn: \"auto\"\n    }),\n    getInitialState: e => ({\n      grouping: [],\n      ...e\n    }),\n    getDefaultOptions: e => ({\n      onGroupingChange: i(\"grouping\", e),\n      groupedColumnMode: \"reorder\"\n    }),\n    createColumn: (e, t) => ({\n      toggleGrouping: () => {\n        t.setGrouping(t => null != t && t.includes(e.id) ? t.filter(t => t !== e.id) : [...(null != t ? t : []), e.id]);\n      },\n      getCanGroup: () => {\n        var n, l, o, i;\n        return null != (n = null == (l = null != (o = null == (i = e.columnDef.enableGrouping) || i) ? o : t.options.enableGrouping) || l) ? n : !!e.accessorFn;\n      },\n      getIsGrouped: () => {\n        var n;\n        return null == (n = t.getState().grouping) ? void 0 : n.includes(e.id);\n      },\n      getGroupedIndex: () => {\n        var n;\n        return null == (n = t.getState().grouping) ? void 0 : n.indexOf(e.id);\n      },\n      getToggleGroupingHandler: () => {\n        const t = e.getCanGroup();\n        return () => {\n          t && e.toggleGrouping();\n        };\n      },\n      getAutoAggregationFn: () => {\n        const n = t.getCoreRowModel().flatRows[0],\n              l = null == n ? void 0 : n.getValue(e.id);\n        return \"number\" == typeof l ? E.sum : \"[object Date]\" === Object.prototype.toString.call(l) ? E.extent : void 0;\n      },\n      getAggregationFn: () => {\n        var n;\n        const l = t.options.aggregationFns;\n        if (!e) throw new Error();\n        return r(e.columnDef.aggregationFn) ? e.columnDef.aggregationFn : \"auto\" === e.columnDef.aggregationFn ? e.getAutoAggregationFn() : null != (n = null == l ? void 0 : l[e.columnDef.aggregationFn]) ? n : E[e.columnDef.aggregationFn];\n      }\n    }),\n    createInstance: e => ({\n      setGrouping: t => null == e.options.onGroupingChange ? void 0 : e.options.onGroupingChange(t),\n      resetGrouping: t => {\n        var n, l;\n        e.setGrouping(t ? [] : null != (n = null == (l = e.initialState) ? void 0 : l.grouping) ? n : []);\n      },\n      getPreGroupedRowModel: () => e.getSortedRowModel(),\n      getGroupedRowModel: () => (!e._getGroupedRowModel && e.options.getGroupedRowModel && (e._getGroupedRowModel = e.options.getGroupedRowModel(e)), e.options.manualGrouping || !e._getGroupedRowModel ? e.getPreGroupedRowModel() : e._getGroupedRowModel())\n    }),\n    createRow: e => ({\n      getIsGrouped: () => !!e.groupingColumnId,\n      _groupingValuesCache: {}\n    }),\n    createCell: (e, t, n, l) => ({\n      getIsGrouped: () => t.getIsGrouped() && t.id === n.groupingColumnId,\n      getIsPlaceholder: () => !e.getIsGrouped() && t.getIsGrouped(),\n      getIsAggregated: () => {\n        var t;\n        return !e.getIsGrouped() && !e.getIsPlaceholder() && (null == (t = n.subRows) ? void 0 : t.length) > 1;\n      },\n      renderAggregatedCell: () => {\n        var o;\n        const i = null != (o = t.columnDef.aggregatedCell) ? o : t.columnDef.cell;\n        return i ? l._render(i, {\n          instance: l,\n          column: t,\n          row: n,\n          cell: e,\n          getValue: e.getValue\n        }) : null;\n      }\n    })\n  };\n\n  function z(e, t, n) {\n    if (null == t || !t.length || !n) return e;\n    const l = e.filter(e => !t.includes(e.id));\n    if (\"remove\" === n) return l;\n    return [...t.map(t => e.find(e => e.id === t)).filter(Boolean), ...l];\n  }\n\n  const H = {\n    getInitialState: e => ({\n      columnOrder: [],\n      ...e\n    }),\n    getDefaultOptions: e => ({\n      onColumnOrderChange: i(\"columnOrder\", e)\n    }),\n    createInstance: e => ({\n      setColumnOrder: t => null == e.options.onColumnOrderChange ? void 0 : e.options.onColumnOrderChange(t),\n      resetColumnOrder: t => {\n        var n;\n        e.setColumnOrder(t ? [] : null != (n = e.initialState.columnOrder) ? n : []);\n      },\n      _getOrderColumnsFn: a(() => [e.getState().columnOrder, e.getState().grouping, e.options.groupedColumnMode], (e, t, n) => l => {\n        let o = [];\n\n        if (null != e && e.length) {\n          const t = [...e],\n                n = [...l];\n\n          for (; n.length && t.length;) {\n            const e = t.shift(),\n                  l = n.findIndex(t => t.id === e);\n            l > -1 && o.push(n.splice(l, 1)[0]);\n          }\n\n          o = [...o, ...n];\n        } else o = l;\n\n        return z(o, t, n);\n      }, {\n        key: !1\n      })\n    })\n  },\n        D = {\n    getInitialState: e => ({ ...e,\n      pagination: {\n        pageIndex: 0,\n        pageSize: 10,\n        ...(null == e ? void 0 : e.pagination)\n      }\n    }),\n    getDefaultOptions: e => ({\n      onPaginationChange: i(\"pagination\", e)\n    }),\n    createInstance: e => {\n      let t = !1,\n          n = !1;\n      return {\n        _autoResetPageIndex: () => {\n          var l, o;\n\n          if (t) {\n            if (null != (l = null != (o = e.options.autoResetAll) ? o : e.options.autoResetPageIndex) ? l : !e.options.manualPagination) {\n              if (n) return;\n              n = !0, e._queue(() => {\n                e.resetPageIndex(), n = !1;\n              });\n            }\n          } else e._queue(() => {\n            t = !0;\n          });\n        },\n        setPagination: t => null == e.options.onPaginationChange ? void 0 : e.options.onPaginationChange(e => o(t, e)),\n        resetPagination: t => {\n          var n;\n          e.setPagination(t ? {\n            pageIndex: 0,\n            pageSize: 10\n          } : null != (n = e.initialState.pagination) ? n : {\n            pageIndex: 0,\n            pageSize: 10\n          });\n        },\n        setPageIndex: t => {\n          e.setPagination(e => {\n            let n = o(t, e.pageIndex);\n            const l = void 0 !== e.pageCount ? e.pageCount - 1 : Number.MAX_SAFE_INTEGER;\n            return n = Math.min(Math.max(0, n), l), { ...e,\n              pageIndex: n\n            };\n          });\n        },\n        resetPageIndex: t => {\n          var n, l, o;\n          e.setPageIndex(t ? 0 : null != (n = null == (l = e.initialState) || null == (o = l.pagination) ? void 0 : o.pageIndex) ? n : 0);\n        },\n        resetPageSize: t => {\n          var n, l, o;\n          e.setPageSize(t ? 10 : null != (n = null == (l = e.initialState) || null == (o = l.pagination) ? void 0 : o.pageSize) ? n : 10);\n        },\n        setPageSize: t => {\n          e.setPagination(e => {\n            const n = Math.max(1, o(t, e.pageSize)),\n                  l = e.pageSize * e.pageIndex,\n                  i = Math.floor(l / n);\n            return { ...e,\n              pageIndex: i,\n              pageSize: n\n            };\n          });\n        },\n        setPageCount: t => e.setPagination(e => {\n          var n;\n          let l = o(t, null != (n = e.pageCount) ? n : -1);\n          return \"number\" == typeof l && (l = Math.max(-1, l)), { ...e,\n            pageCount: l\n          };\n        }),\n        getPageOptions: a(() => [e.getState().pagination.pageSize, e.getState().pagination.pageCount], (e, t) => {\n          let n = [];\n          return t && t > 0 && (n = [...new Array(t)].fill(null).map((e, t) => t)), n;\n        }, {\n          key: !1,\n          debug: () => {\n            var t;\n            return null != (t = e.options.debugAll) ? t : e.options.debugTable;\n          }\n        }),\n        getCanPreviousPage: () => e.getState().pagination.pageIndex > 0,\n        getCanNextPage: () => {\n          const {\n            pageIndex: t\n          } = e.getState().pagination,\n                n = e.getPageCount();\n          return -1 === n || 0 !== n && t < n - 1;\n        },\n        previousPage: () => e.setPageIndex(e => e - 1),\n        nextPage: () => e.setPageIndex(e => e + 1),\n        getPrePaginationRowModel: () => e.getExpandedRowModel(),\n        getPaginationRowModel: () => (!e._getPaginationRowModel && e.options.getPaginationRowModel && (e._getPaginationRowModel = e.options.getPaginationRowModel(e)), e.options.manualPagination || !e._getPaginationRowModel ? e.getPrePaginationRowModel() : e._getPaginationRowModel()),\n        getPageCount: () => {\n          const {\n            pageCount: t\n          } = e.getState().pagination;\n          return void 0 !== t ? t : Math.ceil(e.getPrePaginationRowModel().rows.length / e.getState().pagination.pageSize);\n        }\n      };\n    }\n  },\n        L = {\n    getInitialState: e => ({\n      columnPinning: {\n        left: [],\n        right: []\n      },\n      ...e\n    }),\n    getDefaultOptions: e => ({\n      onColumnPinningChange: i(\"columnPinning\", e)\n    }),\n    createColumn: (e, t) => ({\n      pin: n => {\n        const l = e.getLeafColumns().map(e => e.id).filter(Boolean);\n        t.setColumnPinning(e => {\n          var t, o, i, r, u, a;\n          return \"right\" === n ? {\n            left: (null != (i = null == e ? void 0 : e.left) ? i : []).filter(e => !(null != l && l.includes(e))),\n            right: [...(null != (r = null == e ? void 0 : e.right) ? r : []).filter(e => !(null != l && l.includes(e))), ...l]\n          } : \"left\" === n ? {\n            left: [...(null != (u = null == e ? void 0 : e.left) ? u : []).filter(e => !(null != l && l.includes(e))), ...l],\n            right: (null != (a = null == e ? void 0 : e.right) ? a : []).filter(e => !(null != l && l.includes(e)))\n          } : {\n            left: (null != (t = null == e ? void 0 : e.left) ? t : []).filter(e => !(null != l && l.includes(e))),\n            right: (null != (o = null == e ? void 0 : e.right) ? o : []).filter(e => !(null != l && l.includes(e)))\n          };\n        });\n      },\n      getCanPin: () => e.getLeafColumns().some(e => {\n        var n, l;\n        return (null == (n = e.columnDef.enablePinning) || n) && (null == (l = t.options.enablePinning) || l);\n      }),\n      getIsPinned: () => {\n        const n = e.getLeafColumns().map(e => e.id),\n              {\n          left: l,\n          right: o\n        } = t.getState().columnPinning,\n              i = n.some(e => null == l ? void 0 : l.includes(e)),\n              r = n.some(e => null == o ? void 0 : o.includes(e));\n        return i ? \"left\" : !!r && \"right\";\n      },\n      getPinnedIndex: () => {\n        var n, l, o;\n        const i = e.getIsPinned();\n        return i ? null != (n = null == (l = t.getState().columnPinning) || null == (o = l[i]) ? void 0 : o.indexOf(e.id)) ? n : -1 : 0;\n      }\n    }),\n    createRow: (e, t) => ({\n      getCenterVisibleCells: a(() => [e._getAllVisibleCells(), t.getState().columnPinning.left, t.getState().columnPinning.right], (e, t, n) => {\n        const l = [...(null != t ? t : []), ...(null != n ? n : [])];\n        return e.filter(e => !l.includes(e.column.id));\n      }, {\n        key: \"row.getCenterVisibleCells\",\n        debug: () => {\n          var e;\n          return null != (e = t.options.debugAll) ? e : t.options.debugRows;\n        }\n      }),\n      getLeftVisibleCells: a(() => [e._getAllVisibleCells(), t.getState().columnPinning.left,,], (e, t) => (null != t ? t : []).map(t => e.find(e => e.column.id === t)).filter(Boolean).map(e => ({ ...e,\n        position: \"left\"\n      })), {\n        key: \"row.getLeftVisibleCells\",\n        debug: () => {\n          var e;\n          return null != (e = t.options.debugAll) ? e : t.options.debugRows;\n        }\n      }),\n      getRightVisibleCells: a(() => [e._getAllVisibleCells(), t.getState().columnPinning.right], (e, t) => (null != t ? t : []).map(t => e.find(e => e.column.id === t)).filter(Boolean).map(e => ({ ...e,\n        position: \"left\"\n      })), {\n        key: \"row.getRightVisibleCells\",\n        debug: () => {\n          var e;\n          return null != (e = t.options.debugAll) ? e : t.options.debugRows;\n        }\n      })\n    }),\n    createInstance: e => ({\n      setColumnPinning: t => null == e.options.onColumnPinningChange ? void 0 : e.options.onColumnPinningChange(t),\n      resetColumnPinning: t => {\n        var n, l;\n        return e.setColumnPinning(t ? {\n          left: [],\n          right: []\n        } : null != (n = null == (l = e.initialState) ? void 0 : l.columnPinning) ? n : {\n          left: [],\n          right: []\n        });\n      },\n      getIsSomeColumnsPinned: t => {\n        var n;\n        const l = e.getState().columnPinning;\n        var o, i;\n        return t ? Boolean(null == (n = l[t]) ? void 0 : n.length) : Boolean((null == (o = l.left) ? void 0 : o.length) || (null == (i = l.right) ? void 0 : i.length));\n      },\n      getLeftLeafColumns: a(() => [e.getAllLeafColumns(), e.getState().columnPinning.left], (e, t) => (null != t ? t : []).map(t => e.find(e => e.id === t)).filter(Boolean), {\n        key: !1,\n        debug: () => {\n          var t;\n          return null != (t = e.options.debugAll) ? t : e.options.debugColumns;\n        }\n      }),\n      getRightLeafColumns: a(() => [e.getAllLeafColumns(), e.getState().columnPinning.right], (e, t) => (null != t ? t : []).map(t => e.find(e => e.id === t)).filter(Boolean), {\n        key: !1,\n        debug: () => {\n          var t;\n          return null != (t = e.options.debugAll) ? t : e.options.debugColumns;\n        }\n      }),\n      getCenterLeafColumns: a(() => [e.getAllLeafColumns(), e.getState().columnPinning.left, e.getState().columnPinning.right], (e, t, n) => {\n        const l = [...(null != t ? t : []), ...(null != n ? n : [])];\n        return e.filter(e => !l.includes(e.id));\n      }, {\n        key: !1,\n        debug: () => {\n          var t;\n          return null != (t = e.options.debugAll) ? t : e.options.debugColumns;\n        }\n      })\n    })\n  },\n        O = {\n    getInitialState: e => ({\n      rowSelection: {},\n      ...e\n    }),\n    getDefaultOptions: e => ({\n      onRowSelectionChange: i(\"rowSelection\", e),\n      enableRowSelection: !0,\n      enableMultiRowSelection: !0,\n      enableSubRowSelection: !0\n    }),\n    createInstance: e => ({\n      setRowSelection: t => null == e.options.onRowSelectionChange ? void 0 : e.options.onRowSelectionChange(t),\n      resetRowSelection: t => {\n        var n;\n        return e.setRowSelection(t ? {} : null != (n = e.initialState.rowSelection) ? n : {});\n      },\n      toggleAllRowsSelected: t => {\n        e.setRowSelection(n => {\n          t = void 0 !== t ? t : !e.getIsAllRowsSelected();\n          const l = { ...n\n          },\n                o = e.getPreGroupedRowModel().flatRows;\n          return t ? o.forEach(e => {\n            l[e.id] = !0;\n          }) : o.forEach(e => {\n            delete l[e.id];\n          }), l;\n        });\n      },\n      toggleAllPageRowsSelected: t => e.setRowSelection(n => {\n        void 0 !== t || e.getIsAllPageRowsSelected();\n        const l = { ...n\n        };\n        return e.getRowModel().rows.forEach(n => {\n          k(l, n.id, t, e);\n        }), l;\n      }),\n      getPreSelectedRowModel: () => e.getCoreRowModel(),\n      getSelectedRowModel: a(() => [e.getState().rowSelection, e.getCoreRowModel()], (t, n) => Object.keys(t).length ? T(e, n) : {\n        rows: [],\n        flatRows: [],\n        rowsById: {}\n      }, {\n        key: !1,\n        debug: () => {\n          var t;\n          return null != (t = e.options.debugAll) ? t : e.options.debugTable;\n        }\n      }),\n      getFilteredSelectedRowModel: a(() => [e.getState().rowSelection, e.getFilteredRowModel()], (t, n) => Object.keys(t).length ? T(e, n) : {\n        rows: [],\n        flatRows: [],\n        rowsById: {}\n      }, {\n        key: \"getFilteredSelectedRowModel\",\n        debug: () => {\n          var t;\n          return null != (t = e.options.debugAll) ? t : e.options.debugTable;\n        }\n      }),\n      getGroupedSelectedRowModel: a(() => [e.getState().rowSelection, e.getGroupedRowModel()], (t, n) => Object.keys(t).length ? T(e, n) : {\n        rows: [],\n        flatRows: [],\n        rowsById: {}\n      }, {\n        key: \"getGroupedSelectedRowModel\",\n        debug: () => {\n          var t;\n          return null != (t = e.options.debugAll) ? t : e.options.debugTable;\n        }\n      }),\n      getIsAllRowsSelected: () => {\n        const t = e.getPreFilteredRowModel().flatRows,\n              {\n          rowSelection: n\n        } = e.getState();\n        let l = Boolean(t.length && Object.keys(n).length);\n        return l && t.some(e => !n[e.id]) && (l = !1), l;\n      },\n      getIsAllPageRowsSelected: () => {\n        const t = e.getPaginationRowModel().flatRows,\n              {\n          rowSelection: n\n        } = e.getState();\n        let l = !!t.length;\n        return l && t.some(e => !n[e.id]) && (l = !1), l;\n      },\n      getIsSomeRowsSelected: () => {\n        var t;\n        return !e.getIsAllRowsSelected() && !!Object.keys(null != (t = e.getState().rowSelection) ? t : {}).length;\n      },\n      getIsSomePageRowsSelected: () => {\n        const t = e.getPaginationRowModel().flatRows;\n        return !e.getIsAllPageRowsSelected() && !(null == t || !t.length);\n      },\n      getToggleAllRowsSelectedHandler: () => t => {\n        e.toggleAllRowsSelected(t.target.checked);\n      },\n      getToggleAllPageRowsSelectedHandler: () => t => {\n        e.toggleAllPageRowsSelected(t.target.checked);\n      }\n    }),\n    createRow: (e, t) => ({\n      toggleSelected: n => {\n        const l = e.getIsSelected();\n        t.setRowSelection(o => {\n          if (l === (n = void 0 !== n ? n : !l)) return o;\n          const i = { ...o\n          };\n          return k(i, e.id, n, t), i;\n        });\n      },\n      getIsSelected: () => {\n        const {\n          rowSelection: n\n        } = t.getState();\n        return !0 === B(e, n);\n      },\n      getIsSomeSelected: () => {\n        const {\n          rowSelection: n\n        } = t.getState();\n        return \"some\" === B(e, n);\n      },\n      getCanSelect: () => {\n        var n;\n        return \"function\" == typeof t.options.enableRowSelection ? t.options.enableRowSelection(e) : null == (n = t.options.enableRowSelection) || n;\n      },\n      getCanSelectSubRows: () => {\n        var n;\n        return \"function\" == typeof t.options.enableSubRowSelection ? t.options.enableSubRowSelection(e) : null == (n = t.options.enableSubRowSelection) || n;\n      },\n      getCanMultiSelect: () => {\n        var n;\n        return \"function\" == typeof t.options.enableMultiRowSelection ? t.options.enableMultiRowSelection(e) : null == (n = t.options.enableMultiRowSelection) || n;\n      },\n      getToggleSelectedHandler: () => {\n        const t = e.getCanSelect();\n        return n => {\n          var l;\n          t && e.toggleSelected(null == (l = n.target) ? void 0 : l.checked);\n        };\n      }\n    })\n  },\n        k = (e, t, n, l) => {\n    var o;\n    const i = l.getRow(t);\n    i.getIsGrouped(), n ? e[t] = !0 : delete e[t], null != (o = i.subRows) && o.length && i.getCanSelectSubRows() && i.subRows.forEach(t => k(e, t.id, n, l));\n  };\n\n  function T(e, t) {\n    const n = e.getState().rowSelection,\n          l = [],\n          o = {},\n          i = function (e, t) {\n      return void 0 === t && (t = 0), e.map(e => {\n        var r;\n        const u = !0 === B(e, n);\n        if (u && (l.push(e), o[e.id] = e), null != (r = e.subRows) && r.length && (e = { ...e,\n          subRows: i(e.subRows, t + 1)\n        }), u) return e;\n      }).filter(Boolean);\n    };\n\n    return {\n      rows: i(t.rows),\n      flatRows: l,\n      rowsById: o\n    };\n  }\n\n  function B(e, t, n) {\n    if (t[e.id]) return !0;\n\n    if (e.subRows && e.subRows.length) {\n      let n = !0,\n          l = !1;\n      return e.subRows.forEach(e => {\n        l && !n || (B(e, t) ? l = !0 : n = !1);\n      }), !!n || !!l && \"some\";\n    }\n\n    return !1;\n  }\n\n  const j = /([0-9]+)/gm;\n\n  function q(e, t) {\n    return e === t ? 0 : e > t ? 1 : -1;\n  }\n\n  function N(e) {\n    return \"number\" == typeof e ? isNaN(e) || e === 1 / 0 || e === -1 / 0 ? \"\" : String(e) : \"string\" == typeof e ? e : \"\";\n  }\n\n  function U(e, t) {\n    const n = e.split(j).filter(Boolean),\n          l = t.split(j).filter(Boolean);\n\n    for (; n.length && l.length;) {\n      const e = n.shift(),\n            t = l.shift(),\n            o = parseInt(e, 10),\n            i = parseInt(t, 10),\n            r = [o, i].sort();\n\n      if (isNaN(r[0])) {\n        if (e > t) return 1;\n        if (t > e) return -1;\n      } else {\n        if (isNaN(r[1])) return isNaN(o) ? -1 : 1;\n        if (o > i) return 1;\n        if (i > o) return -1;\n      }\n    }\n\n    return n.length - l.length;\n  }\n\n  const X = {\n    alphanumeric: (e, t, n) => U(N(e.getValue(n)).toLowerCase(), N(t.getValue(n)).toLowerCase()),\n    alphanumericCaseSensitive: (e, t, n) => U(N(e.getValue(n)), N(t.getValue(n))),\n    text: (e, t, n) => q(N(e.getValue(n)).toLowerCase(), N(t.getValue(n)).toLowerCase()),\n    textCaseSensitive: (e, t, n) => q(N(e.getValue(n)), N(t.getValue(n))),\n    datetime: (e, t, n) => q(e.getValue(n).getTime(), t.getValue(n).getTime()),\n    basic: (e, t, n) => q(e.getValue(n), t.getValue(n))\n  },\n        K = {\n    getInitialState: e => ({\n      sorting: [],\n      ...e\n    }),\n    getDefaultColumnDef: () => ({\n      sortingFn: \"auto\"\n    }),\n    getDefaultOptions: e => ({\n      onSortingChange: i(\"sorting\", e),\n      isMultiSortEvent: e => e.shiftKey\n    }),\n    createColumn: (e, t) => ({\n      getAutoSortingFn: () => {\n        const n = t.getFilteredRowModel().flatRows.slice(10);\n        let l = !1;\n\n        for (const t of n) {\n          const n = null == t ? void 0 : t.getValue(e.id);\n          if (\"[object Date]\" === Object.prototype.toString.call(n)) return X.datetime;\n          if (\"string\" == typeof n && (l = !0, n.split(j).length > 1)) return X.alphanumeric;\n        }\n\n        return l ? X.text : X.basic;\n      },\n      getAutoSortDir: () => {\n        const n = t.getFilteredRowModel().flatRows[0];\n        return \"string\" == typeof (null == n ? void 0 : n.getValue(e.id)) ? \"asc\" : \"desc\";\n      },\n      getSortingFn: () => {\n        var n;\n        const l = t.options.sortingFns;\n        if (!e) throw new Error();\n        return r(e.columnDef.sortingFn) ? e.columnDef.sortingFn : \"auto\" === e.columnDef.sortingFn ? e.getAutoSortingFn() : null != (n = null == l ? void 0 : l[e.columnDef.sortingFn]) ? n : X[e.columnDef.sortingFn];\n      },\n      toggleSorting: (n, l) => {\n        t.setSorting(o => {\n          var i, r, u, a;\n          const s = null == o ? void 0 : o.find(t => t.id === e.id),\n                g = null == o ? void 0 : o.findIndex(t => t.id === e.id),\n                d = null != n;\n          let c,\n              p = [];\n          c = e.getCanMultiSort() && l ? s ? \"toggle\" : \"add\" : null != o && o.length && g !== o.length - 1 ? \"replace\" : s ? \"toggle\" : \"replace\";\n          const f = null != (i = null != (r = e.columnDef.sortDescFirst) ? r : t.options.sortDescFirst) ? i : \"desc\" === e.getAutoSortDir();\n          if (\"toggle\" !== c || null != (u = t.options.enableSortingRemoval) && !u || d || l && null != (a = t.options.enableMultiRemove) && !a || (null != s && s.desc ? f : !f) || (c = \"remove\"), \"replace\" === c) p = [{\n            id: e.id,\n            desc: d ? n : !!f\n          }];else if (\"add\" === c && null != o && o.length) {\n            var m;\n            p = [...o, {\n              id: e.id,\n              desc: d ? n : !!f\n            }], p.splice(0, p.length - (null != (m = t.options.maxMultiSortColCount) ? m : Number.MAX_SAFE_INTEGER));\n          } else \"toggle\" === c && null != o && o.length ? p = o.map(t => t.id === e.id ? { ...t,\n            desc: d ? n : !(null != s && s.desc)\n          } : t) : \"remove\" === c && null != o && o.length && (p = o.filter(t => t.id !== e.id));\n          return p;\n        });\n      },\n      getCanSort: () => {\n        var n, l;\n        return (null == (n = e.columnDef.enableSorting) || n) && (null == (l = t.options.enableSorting) || l) && !!e.accessorFn;\n      },\n      getCanMultiSort: () => {\n        var n, l;\n        return null != (n = null != (l = e.columnDef.enableMultiSort) ? l : t.options.enableMultiSort) ? n : !!e.accessorFn;\n      },\n      getIsSorted: () => {\n        var n;\n        const l = null == (n = t.getState().sorting) ? void 0 : n.find(t => t.id === e.id);\n        return !!l && (l.desc ? \"desc\" : \"asc\");\n      },\n      getSortIndex: () => {\n        var n, l;\n        return null != (n = null == (l = t.getState().sorting) ? void 0 : l.findIndex(t => t.id === e.id)) ? n : -1;\n      },\n      clearSorting: () => {\n        t.setSorting(t => null != t && t.length ? t.filter(t => t.id !== e.id) : []);\n      },\n      getToggleSortingHandler: () => {\n        const n = e.getCanSort();\n        return l => {\n          n && (null == l.persist || l.persist(), null == e.toggleSorting || e.toggleSorting(void 0, !!e.getCanMultiSort() && (null == t.options.isMultiSortEvent ? void 0 : t.options.isMultiSortEvent(l))));\n        };\n      }\n    }),\n    createInstance: e => ({\n      setSorting: t => null == e.options.onSortingChange ? void 0 : e.options.onSortingChange(t),\n      resetSorting: t => {\n        var n, l;\n        e.setSorting(t ? [] : null != (n = null == (l = e.initialState) ? void 0 : l.sorting) ? n : []);\n      },\n      getPreSortedRowModel: () => e.getFilteredRowModel(),\n      getSortedRowModel: () => (!e._getSortedRowModel && e.options.getSortedRowModel && (e._getSortedRowModel = e.options.getSortedRowModel(e)), e.options.manualSorting || !e._getSortedRowModel ? e.getPreSortedRowModel() : e._getSortedRowModel())\n    })\n  },\n        $ = {\n    getInitialState: e => ({\n      columnVisibility: {},\n      ...e\n    }),\n    getDefaultOptions: e => ({\n      onColumnVisibilityChange: i(\"columnVisibility\", e)\n    }),\n    createColumn: (e, t) => ({\n      toggleVisibility: n => {\n        e.getCanHide() && t.setColumnVisibility(t => ({ ...t,\n          [e.id]: null != n ? n : !e.getIsVisible()\n        }));\n      },\n      getIsVisible: () => {\n        var n, l;\n        return null == (n = null == (l = t.getState().columnVisibility) ? void 0 : l[e.id]) || n;\n      },\n      getCanHide: () => {\n        var n, l;\n        return (null == (n = e.columnDef.enableHiding) || n) && (null == (l = t.options.enableHiding) || l);\n      },\n      getToggleVisibilityHandler: () => t => {\n        null == e.toggleVisibility || e.toggleVisibility(t.target.checked);\n      }\n    }),\n    createRow: (e, t) => ({\n      _getAllVisibleCells: a(() => [e.getAllCells(), t.getState().columnVisibility], e => e.filter(e => e.column.getIsVisible()), {\n        key: \"row._getAllVisibleCells\",\n        debug: () => {\n          var e;\n          return null != (e = t.options.debugAll) ? e : t.options.debugRows;\n        }\n      }),\n      getVisibleCells: a(() => [e.getLeftVisibleCells(), e.getCenterVisibleCells(), e.getRightVisibleCells()], (e, t, n) => [...e, ...t, ...n], {\n        key: !1,\n        debug: () => {\n          var e;\n          return null != (e = t.options.debugAll) ? e : t.options.debugRows;\n        }\n      })\n    }),\n    createInstance: e => {\n      const t = (t, n) => a(() => [n(), n().filter(e => e.getIsVisible()).map(e => e.id).join(\"_\")], e => e.filter(e => null == e.getIsVisible ? void 0 : e.getIsVisible()), {\n        key: t,\n        debug: () => {\n          var t;\n          return null != (t = e.options.debugAll) ? t : e.options.debugColumns;\n        }\n      });\n\n      return {\n        getVisibleFlatColumns: t(\"getVisibleFlatColumns\", () => e.getAllFlatColumns()),\n        getVisibleLeafColumns: t(\"getVisibleLeafColumns\", () => e.getAllLeafColumns()),\n        getLeftVisibleLeafColumns: t(\"getLeftVisibleLeafColumns\", () => e.getLeftLeafColumns()),\n        getRightVisibleLeafColumns: t(\"getRightVisibleLeafColumns\", () => e.getRightLeafColumns()),\n        getCenterVisibleLeafColumns: t(\"getCenterVisibleLeafColumns\", () => e.getCenterLeafColumns()),\n        setColumnVisibility: t => null == e.options.onColumnVisibilityChange ? void 0 : e.options.onColumnVisibilityChange(t),\n        resetColumnVisibility: t => {\n          var n;\n          e.setColumnVisibility(t ? {} : null != (n = e.initialState.columnVisibility) ? n : {});\n        },\n        toggleAllColumnsVisible: t => {\n          var n;\n          t = null != (n = t) ? n : !e.getIsAllColumnsVisible(), e.setColumnVisibility(e.getAllLeafColumns().reduce((e, n) => ({ ...e,\n            [n.id]: t || !(null != n.getCanHide && n.getCanHide())\n          }), {}));\n        },\n        getIsAllColumnsVisible: () => !e.getAllLeafColumns().some(e => !(null != e.getIsVisible && e.getIsVisible())),\n        getIsSomeColumnsVisible: () => e.getAllLeafColumns().some(e => null == e.getIsVisible ? void 0 : e.getIsVisible()),\n        getToggleAllColumnsVisibilityHandler: () => t => {\n          var n;\n          e.toggleAllColumnsVisible(null == (n = t.target) ? void 0 : n.checked);\n        }\n      };\n    }\n  },\n        J = [d, $, H, L, A, K, G, v, D, O, f];\n\n  function Q(e) {\n    var t;\n    (e.debugAll || e.debugTable) && console.info(\"Creating Table Instance...\");\n    let n = {\n      _features: J\n    };\n\n    const l = n._features.reduce((e, t) => Object.assign(e, null == t.getDefaultOptions ? void 0 : t.getDefaultOptions(n)), {});\n\n    let i = { ...(null != (t = e.initialState) ? t : {})\n    };\n\n    n._features.forEach(e => {\n      var t;\n      i = null != (t = null == e.getInitialState ? void 0 : e.getInitialState(i)) ? t : i;\n    });\n\n    const r = [];\n    let u = !1;\n    const g = {\n      _features: J,\n      options: { ...l,\n        ...e\n      },\n      initialState: i,\n      _queue: e => {\n        r.push(e), u || (u = !0, Promise.resolve().then(() => {\n          for (; r.length;) r.shift()();\n\n          u = !1;\n        }).catch(e => setTimeout(() => {\n          throw e;\n        })));\n      },\n      reset: () => {\n        n.setState(n.initialState);\n      },\n      setOptions: e => {\n        const t = o(e, n.options);\n\n        n.options = (e => n.options.mergeOptions ? n.options.mergeOptions(l, e) : { ...l,\n          ...e\n        })(t);\n      },\n      _render: (e, t) => \"function\" == typeof n.options.render ? n.options.render(e, t) : \"function\" == typeof e ? e(t) : e,\n      getState: () => n.options.state,\n      setState: e => {\n        null == n.options.onStateChange || n.options.onStateChange(e);\n      },\n      _getRowId: (e, t, l) => {\n        var o;\n        return null != (o = null == n.options.getRowId ? void 0 : n.options.getRowId(e, t, l)) ? o : \"\" + (l ? [l.id, t].join(\".\") : t);\n      },\n      getCoreRowModel: () => (n._getCoreRowModel || (n._getCoreRowModel = n.options.getCoreRowModel(n)), n._getCoreRowModel()),\n      getRowModel: () => n.getPaginationRowModel(),\n      getRow: e => {\n        const t = n.getRowModel().rowsById[e];\n        if (!t) throw new Error();\n        return t;\n      },\n      _getDefaultColumnDef: a(() => [n.options.defaultColumn], e => {\n        var t;\n        return e = null != (t = e) ? t : {}, {\n          header: e => e.header.column.id,\n          footer: e => e.header.column.id,\n          cell: e => {\n            var t, n;\n            return null != (t = null == (n = e.getValue()) || null == n.toString ? void 0 : n.toString()) ? t : null;\n          },\n          ...n._features.reduce((e, t) => Object.assign(e, null == t.getDefaultColumnDef ? void 0 : t.getDefaultColumnDef()), {}),\n          ...e\n        };\n      }, {\n        debug: () => {\n          var e;\n          return null != (e = n.options.debugAll) ? e : n.options.debugColumns;\n        },\n        key: !1\n      }),\n      _getColumnDefs: () => n.options.columns,\n      getAllColumns: a(() => [n._getColumnDefs()], e => {\n        const t = function (e, l, o) {\n          return void 0 === o && (o = 0), e.map(e => {\n            const i = s(n, e, o, l);\n            return i.columns = e.columns ? t(e.columns, i, o + 1) : [], i;\n          });\n        };\n\n        return t(e);\n      }, {\n        key: !1,\n        debug: () => {\n          var e;\n          return null != (e = n.options.debugAll) ? e : n.options.debugColumns;\n        }\n      }),\n      getAllFlatColumns: a(() => [n.getAllColumns()], e => e.flatMap(e => e.getFlatColumns()), {\n        key: !1,\n        debug: () => {\n          var e;\n          return null != (e = n.options.debugAll) ? e : n.options.debugColumns;\n        }\n      }),\n      _getAllFlatColumnsById: a(() => [n.getAllFlatColumns()], e => e.reduce((e, t) => (e[t.id] = t, e), {}), {\n        key: !1,\n        debug: () => {\n          var e;\n          return null != (e = n.options.debugAll) ? e : n.options.debugColumns;\n        }\n      }),\n      getAllLeafColumns: a(() => [n.getAllColumns(), n._getOrderColumnsFn()], (e, t) => t(e.flatMap(e => e.getLeafColumns())), {\n        key: !1,\n        debug: () => {\n          var e;\n          return null != (e = n.options.debugAll) ? e : n.options.debugColumns;\n        }\n      }),\n      getColumn: e => {\n        const t = n._getAllFlatColumnsById()[e];\n\n        if (!t) throw new Error();\n        return t;\n      }\n    };\n    return Object.assign(n, g), n._features.forEach(e => Object.assign(n, null == e.createInstance ? void 0 : e.createInstance(n))), n;\n  }\n\n  function W(e) {\n    return () => Y(void 0, void 0, e);\n  }\n\n  function Y(e, t, n) {\n    const l = {\n      generics: void 0,\n      options: null != n ? n : {\n        render: (() => {\n          throw new Error(\"\");\n        })()\n      },\n      setRowType: () => l,\n      setTableMetaType: () => l,\n      setColumnMetaType: () => l,\n      setFilterMetaType: () => l,\n      setOptions: l => Y(e, t, { ...n,\n        ...l\n      }),\n      createDisplayColumn: e => ({ ...e,\n        columnDefType: \"display\"\n      }),\n      createGroup: e => ({ ...e,\n        columnDefType: \"group\"\n      }),\n      createDataColumn: (e, t) => {\n        var n;\n        if (t = { ...t,\n          columnDefType: \"data\",\n          id: t.id\n        }, \"string\" == typeof e) return { ...t,\n          id: null != (n = t.id) ? n : e,\n          accessorKey: e\n        };\n        if (\"function\" == typeof e) return { ...t,\n          accessorFn: e\n        };\n        throw new Error(\"Invalid accessor\");\n      },\n      createOptions: e => e\n    };\n    return l;\n  }\n\n  const Z = (e, t, n, l, o, i) => {\n    let r = {\n      id: t,\n      index: l,\n      original: n,\n      depth: o,\n      _valuesCache: {},\n      getValue: t => {\n        if (r._valuesCache.hasOwnProperty(t)) return r._valuesCache[t];\n        const n = e.getColumn(t);\n        return n.accessorFn ? (r._valuesCache[t] = n.accessorFn(r.original, l), r._valuesCache[t]) : void 0;\n      },\n      subRows: null != i ? i : [],\n      getLeafRows: () => u(r.subRows, e => e.subRows),\n      getAllCells: a(() => [e.getAllLeafColumns()], t => t.map(t => function (e, t, n, l) {\n        const o = {\n          id: t.id + \"_\" + n.id,\n          row: t,\n          column: n,\n          getValue: () => t.getValue(l),\n          renderCell: () => n.columnDef.cell ? e._render(n.columnDef.cell, {\n            instance: e,\n            column: n,\n            row: t,\n            cell: o,\n            getValue: o.getValue\n          }) : null\n        };\n        return e._features.forEach(l => {\n          Object.assign(o, null == l.createCell ? void 0 : l.createCell(o, n, t, e));\n        }, {}), o;\n      }(e, r, t, t.id)), {\n        key: !1,\n        debug: () => {\n          var t;\n          return null != (t = e.options.debugAll) ? t : e.options.debugRows;\n        }\n      }),\n      _getAllCellsByColumnId: a(() => [r.getAllCells()], e => e.reduce((e, t) => (e[t.column.id] = t, e), {}), {\n        key: \"row.getAllCellsByColumnId\",\n        debug: () => {\n          var t;\n          return null != (t = e.options.debugAll) ? t : e.options.debugRows;\n        }\n      })\n    };\n\n    for (let t = 0; t < e._features.length; t++) {\n      const n = e._features[t];\n      Object.assign(r, null == n || null == n.createRow ? void 0 : n.createRow(r, e));\n    }\n\n    return r;\n  };\n\n  function ee(e, t, n) {\n    return n.options.filterFromLeafRows ? function (e, t, n) {\n      const l = [],\n            o = {};\n      let i, r;\n\n      const u = function (e, l) {\n        void 0 === l && (l = 0);\n        const a = [];\n\n        for (let g = 0; g < e.length; g++) {\n          var s;\n\n          if (i = e[g], null != (s = i.subRows) && s.length) {\n            if (r = Z(n, i.id, i.original, i.index, i.depth), r.columnFilters = i.columnFilters, r.subRows = u(i.subRows, l + 1), !r.subRows.length) continue;\n            i = r;\n          }\n\n          t(i) && (a.push(i), o[i.id] = i, o[g] = i);\n        }\n\n        return a;\n      };\n\n      return {\n        rows: u(e),\n        flatRows: l,\n        rowsById: o\n      };\n    }(e, t, n) : function (e, t, n) {\n      const l = [],\n            o = {};\n      let i, r, u;\n\n      const a = function (e, s) {\n        void 0 === s && (s = 0), i = [];\n\n        for (let d = 0; d < e.length; d++) {\n          r = e[d];\n          var g;\n          if (t(r)) null != (g = r.subRows) && g.length && (u = Z(n, r.id, r.original, r.index, r.depth), u.subRows = a(r.subRows, s + 1), r = u), i.push(r), l.push(r), o[r.id] = r;\n        }\n\n        return i;\n      };\n\n      return {\n        rows: a(e),\n        flatRows: l,\n        rowsById: o\n      };\n    }(e, t, n);\n  }\n\n  function te(e, t) {\n    const n = [],\n          l = e => {\n      var t;\n      n.push(e), null != (t = e.subRows) && t.length && e.getIsExpanded() && e.subRows.forEach(l);\n    };\n\n    return e.rows.forEach(l), {\n      rows: n,\n      flatRows: e.flatRows,\n      rowsById: e.rowsById\n    };\n  }\n\n  const ne = (e, t) => {\n    return e ? function (e) {\n      return \"function\" == typeof e && (() => {\n        const t = Object.getPrototypeOf(e);\n        return t.prototype && t.prototype.isReactComponent;\n      })();\n    }(n = e) || \"function\" == typeof n || function (e) {\n      return \"object\" == typeof e && \"symbol\" == typeof e.$$typeof && [\"react.memo\", \"react.forward_ref\"].includes(e.$$typeof.description);\n    }(n) ? l.createElement(e, t) : e : null;\n    var n;\n  };\n\n  const le = W({\n    render: ne\n  });\n  e.ColumnSizing = f, e.Expanding = v, e.Filters = A, e.Grouping = G, e.Headers = d, e.Ordering = H, e.Pagination = D, e.Pinning = L, e.RowSelection = O, e.Sorting = K, e.Visibility = $, e.aggregationFns = E, e.buildHeaderGroups = c, e.createColumn = s, e.createRow = Z, e.createTable = le, e.createTableFactory = W, e.createTableInstance = Q, e.defaultColumnSizing = p, e.expandRows = te, e.filterFns = _, e.flattenBy = u, e.functionalUpdate = o, e.getCoreRowModel = function () {\n    return e => a(() => [e.options.data], t => {\n      const n = {\n        rows: [],\n        flatRows: [],\n        rowsById: {}\n      },\n            l = function (t, o, i) {\n        void 0 === o && (o = 0);\n        const r = [];\n\n        for (let a = 0; a < t.length; a++) {\n          const s = Z(e, e._getRowId(t[a], a, i), t[a], a, o);\n          var u;\n          if (n.flatRows.push(s), n.rowsById[s.id] = s, r.push(s), e.options.getSubRows) s.originalSubRows = e.options.getSubRows(t[a], a), null != (u = s.originalSubRows) && u.length && (s.subRows = l(s.originalSubRows, o + 1, s));\n        }\n\n        return r;\n      };\n\n      return n.rows = l(t), n;\n    }, {\n      key: !1,\n      debug: () => {\n        var t;\n        return null != (t = e.options.debugAll) ? t : e.options.debugTable;\n      },\n      onChange: () => {\n        e._autoResetPageIndex();\n      }\n    });\n  }, e.getExpandedRowModel = function () {\n    return e => a(() => [e.getState().expanded, e.getPreExpandedRowModel(), e.options.paginateExpandedRows], (e, t, n) => t.rows.length && n && (!0 === e || Object.keys(null != e ? e : {}).length) ? te(t) : t, {\n      key: !1,\n      debug: () => {\n        var t;\n        return null != (t = e.options.debugAll) ? t : e.options.debugTable;\n      }\n    });\n  }, e.getFacetedMinMaxValues = function () {\n    return (e, t) => a(() => [e.getColumn(t).getFacetedRowModel()], e => {\n      var n;\n      const l = null == (n = e.flatRows[0]) ? void 0 : n.getValue(t);\n      if (void 0 === l) return;\n      let o = [l, l];\n\n      for (let n = 0; n < e.flatRows.length; n++) {\n        var i;\n        const l = null == (i = e.flatRows[n]) ? void 0 : i.getValue(t);\n        l < o[0] ? o[0] = l : l > o[1] && (o[1] = l);\n      }\n\n      return o;\n    }, {\n      key: !1,\n      debug: () => {\n        var t;\n        return null != (t = e.options.debugAll) ? t : e.options.debugTable;\n      },\n      onChange: () => {}\n    });\n  }, e.getFacetedRowModel = function () {\n    return (e, t) => a(() => [e.getPreFilteredRowModel(), e.getState().columnFilters, e.getState().globalFilter, e.getFilteredRowModel()], (n, l, o) => {\n      if (!n.rows.length || (null == l || !l.length) && !o) return n;\n      const i = [...l.map(e => e.id).filter(e => e !== t), o ? \"__global__\" : void 0].filter(Boolean);\n      return ee(n.rows, e => {\n        for (let t = 0; t < i.length; t++) if (!1 === e.columnFilters[i[t]]) return !1;\n\n        return !0;\n      }, e);\n    }, {\n      key: !1,\n      debug: () => {\n        var t;\n        return null != (t = e.options.debugAll) ? t : e.options.debugTable;\n      },\n      onChange: () => {}\n    });\n  }, e.getFacetedUniqueValues = function () {\n    return (e, t) => a(() => [e.getColumn(t).getFacetedRowModel()], e => {\n      let n = new Map();\n\n      for (let i = 0; i < e.flatRows.length; i++) {\n        var l;\n        const r = null == (l = e.flatRows[i]) ? void 0 : l.getValue(t);\n        var o;\n        if (n.has(r)) n.set(r, (null != (o = n.get(r)) ? o : 0) + 1);else n.set(r, 1);\n      }\n\n      return n;\n    }, {\n      key: !1,\n      debug: () => {\n        var t;\n        return null != (t = e.options.debugAll) ? t : e.options.debugTable;\n      },\n      onChange: () => {}\n    });\n  }, e.getFilteredRowModel = function () {\n    return e => a(() => [e.getPreFilteredRowModel(), e.getState().columnFilters, e.getState().globalFilter], (t, n, l) => {\n      if (!t.rows.length || (null == n || !n.length) && !l) {\n        for (let e = 0; e < t.flatRows.length; e++) t.flatRows[e].columnFilters = {}, t.flatRows[e].columnFiltersMeta = {};\n\n        return t;\n      }\n\n      const o = [],\n            i = [];\n      (null != n ? n : []).forEach(t => {\n        var n;\n        const l = e.getColumn(t.id).getFilterFn();\n        l && o.push({\n          id: t.id,\n          filterFn: l,\n          resolvedValue: null != (n = null == l.resolveFilterValue ? void 0 : l.resolveFilterValue(t.value)) ? n : t.value\n        });\n      });\n      const r = n.map(e => e.id),\n            u = e.getGlobalFilterFn(),\n            a = e.getAllLeafColumns().filter(e => e.getCanGlobalFilter());\n      let s, g;\n      l && u && a.length && (r.push(\"__global__\"), a.forEach(e => {\n        var t;\n        i.push({\n          id: e.id,\n          filterFn: u,\n          resolvedValue: null != (t = null == u.resolveFilterValue ? void 0 : u.resolveFilterValue(l)) ? t : l\n        });\n      }));\n\n      for (let e = 0; e < t.flatRows.length; e++) {\n        const n = t.flatRows[e];\n        if (n.columnFilters = {}, o.length) for (let e = 0; e < o.length; e++) {\n          s = o[e];\n          const t = s.id;\n          n.columnFilters[t] = s.filterFn(n, t, s.resolvedValue, e => {\n            n.columnFiltersMeta[t] = e;\n          });\n        }\n\n        if (i.length) {\n          for (let e = 0; e < i.length; e++) {\n            g = i[e];\n            const t = g.id;\n\n            if (g.filterFn(n, t, g.resolvedValue, e => {\n              n.columnFiltersMeta[t] = e;\n            })) {\n              n.columnFilters.__global__ = !0;\n              break;\n            }\n          }\n\n          !0 !== n.columnFilters.__global__ && (n.columnFilters.__global__ = !1);\n        }\n      }\n\n      return ee(t.rows, e => {\n        for (let t = 0; t < r.length; t++) if (!1 === e.columnFilters[r[t]]) return !1;\n\n        return !0;\n      }, e);\n    }, {\n      key: !1,\n      debug: () => {\n        var t;\n        return null != (t = e.options.debugAll) ? t : e.options.debugTable;\n      },\n      onChange: () => {\n        e._autoResetPageIndex();\n      }\n    });\n  }, e.getGroupedRowModel = function () {\n    return e => a(() => [e.getState().grouping, e.getPreGroupedRowModel()], (t, n) => {\n      if (!n.rows.length || !t.length) return n;\n\n      const l = t.filter(t => e.getColumn(t)),\n            o = [],\n            i = {},\n            r = function (t, n, a) {\n        if (void 0 === n && (n = 0), n === l.length) return t;\n\n        const s = l[n],\n              g = function (e, t) {\n          const n = new Map();\n          return e.reduce((e, n) => {\n            const l = \"\" + n.getValue(t),\n                  o = e.get(l);\n            return o ? e.set(l, [...o, n]) : e.set(l, [n]), e;\n          }, n);\n        }(t, s),\n              d = Array.from(g.entries()).map((t, g) => {\n          let [d, c] = t,\n              p = s + \":\" + d;\n          p = a ? a + \">\" + p : p;\n          const f = r(c, n + 1, p),\n                m = n ? u(c, e => e.subRows) : c,\n                b = Z(e, p, void 0, g, n);\n          return Object.assign(b, {\n            groupingColumnId: s,\n            groupingValue: d,\n            subRows: f,\n            leafRows: m,\n            getValue: t => {\n              if (l.includes(t)) {\n                if (b._valuesCache.hasOwnProperty(t)) return b._valuesCache[t];\n                var n;\n                if (c[0]) b._valuesCache[t] = null != (n = c[0].getValue(t)) ? n : void 0;\n                return b._valuesCache[t];\n              }\n\n              if (b._groupingValuesCache.hasOwnProperty(t)) return b._groupingValuesCache[t];\n              const o = e.getColumn(t).getAggregationFn();\n              return o ? (b._groupingValuesCache[t] = o(t, m, c), b._groupingValuesCache[t]) : void 0;\n            }\n          }), f.forEach(e => {\n            o.push(e), i[e.id] = e;\n          }), b;\n        });\n\n        return d;\n      },\n            a = r(n.rows, 0, \"\");\n\n      return a.forEach(e => {\n        o.push(e), i[e.id] = e;\n      }), {\n        rows: a,\n        flatRows: o,\n        rowsById: i\n      };\n    }, {\n      key: !1,\n      debug: () => {\n        var t;\n        return null != (t = e.options.debugAll) ? t : e.options.debugTable;\n      },\n      onChange: () => {\n        e._queue(() => {\n          e._autoResetExpanded(), e._autoResetPageIndex();\n        });\n      }\n    });\n  }, e.getPaginationRowModel = function (e) {\n    return e => a(() => [e.getState().pagination, e.getPrePaginationRowModel()], (t, n) => {\n      if (!n.rows.length) return n;\n      const {\n        pageSize: l,\n        pageIndex: o\n      } = t;\n      let {\n        rows: i,\n        flatRows: r,\n        rowsById: u\n      } = n;\n      const a = l * o,\n            s = a + l;\n      return i = i.slice(a, s), e.options.paginateExpandedRows ? {\n        rows: i,\n        flatRows: r,\n        rowsById: u\n      } : te({\n        rows: i,\n        flatRows: r,\n        rowsById: u\n      });\n    }, {\n      key: !1,\n      debug: () => {\n        var t;\n        return null != (t = e.options.debugAll) ? t : e.options.debugTable;\n      }\n    });\n  }, e.getSortedRowModel = function () {\n    return e => a(() => [e.getState().sorting, e.getPreSortedRowModel()], (t, n) => {\n      if (!n.rows.length || null == t || !t.length) return n;\n      const l = e.getState().sorting,\n            o = [],\n            i = l.filter(t => e.getColumn(t.id).getCanSort()),\n            r = {};\n      i.forEach(t => {\n        const n = e.getColumn(t.id);\n        r[t.id] = {\n          sortUndefined: n.columnDef.sortUndefined,\n          invertSorting: n.columnDef.invertSorting,\n          sortingFn: n.getSortingFn()\n        };\n      });\n\n      const u = e => {\n        const t = e.slice();\n        return t.sort((e, t) => {\n          for (let l = 0; l < i.length; l += 1) {\n            var n;\n            const o = i[l],\n                  u = r[o.id],\n                  a = null != (n = null == o ? void 0 : o.desc) && n;\n\n            if (u.sortUndefined) {\n              const n = void 0 === e.getValue(o.id),\n                    l = void 0 === t.getValue(o.id);\n              if (n || l) return n && l ? 0 : n ? u.sortUndefined : -u.sortUndefined;\n            }\n\n            let s = u.sortingFn(e, t, o.id);\n            if (0 !== s) return a && (s *= -1), u.invertSorting && (s *= -1), s;\n          }\n\n          return e.index - t.index;\n        }), t.forEach(e => {\n          o.push(e), !e.subRows || e.subRows.length <= 1 || (e.subRows = u(e.subRows));\n        }), t;\n      };\n\n      return {\n        rows: u(n.rows),\n        flatRows: o,\n        rowsById: n.rowsById\n      };\n    }, {\n      key: !1,\n      debug: () => {\n        var t;\n        return null != (t = e.options.debugAll) ? t : e.options.debugTable;\n      },\n      onChange: () => {\n        e._autoResetPageIndex();\n      }\n    });\n  }, e.isFunction = r, e.isRowSelected = B, e.makeStateUpdater = i, e.memo = a, e.noop = function () {}, e.orderColumns = z, e.passiveEventSupported = b, e.reSplitAlphaNumeric = j, e.render = ne, e.selectRowsFn = T, e.shouldAutoRemoveFilter = P, e.sortingFns = X, e.useTableInstance = function (e, t) {\n    const n = { ...e.options,\n      state: {},\n      onStateChange: () => {},\n      render: ne,\n      ...t\n    },\n          [o] = l.useState(() => ({\n      current: Q(n)\n    })),\n          [i, r] = l.useState(() => o.current.initialState);\n    return o.current.setOptions(e => ({ ...e,\n      ...t,\n      state: { ...i,\n        ...t.state\n      },\n      onStateChange: e => {\n        r(e), null == t.onStateChange || t.onStateChange(e);\n      }\n    })), o.current;\n  }, Object.defineProperty(e, \"__esModule\", {\n    value: !0\n  });\n});","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAUA,SAASA,CAAT,CAA0BC,CAA1B,EAAmCC,CAAnC,EAAmCA;IACjC,OAA0B,qBAAZD,CAAY,GAAaA,EAAQC,CAARD,CAAb,GAA8BA,CAAxD;EAIF;;EAAA,SAASE,CAAT,CAA0BC,CAA1B,EAA+BC,CAA/B,EAA+BA;IAC7B,OAAOJ;MACLI,EAASC,QAATD,CAAkBE,MACT,KAAKA,CAAL;QACLH,CAACA,CAADA,GAAOJ,EAAiBC,CAAjBD,EAA0BO,EAAIH,CAAJG,CAA1BP;MADF,CADSO,CAAlBF;IAEyCD,CAH3C;EAQF;;EAAA,SAASI,CAAT,CAAoBC,CAApB,EAAoBA;IAClB,OAAOA,aAAaC,QAApB;EAEF;;EAAA,SAASC,CAAT,CAAmBC,CAAnB,EAAwBC,CAAxB,EAAwBA;IACtB,MAAMC,IAAO,EAAb;IAAA,MAEMC,IAAUC;MACdA,EAAOC,OAAPD,CAAeE;QACbJ,EAAKK,IAALL,CAAUI,CAAVJ;QACA,MAAMM,IAAWP,EAAYK,CAAZL,CAAjB;QAEgB,QAAZO,CAAY,IAAQA,EAASC,MAAjB,IACdN,EAAQK,CAARL,CADc;MACNK,CALZJ;IAKYI,CARd;;IAcA,OADAL,EAAQH,CAARG,GACOD,CAAP;EAEF;;EAAA,SAASQ,CAAT,CAAcC,CAAd,EAAuBC,CAAvB,EAA2BC,CAA3B,EAA2BA;IACzB,IACIC,CADJ;IAAA,IAAIC,IAAO,EAAX;IAEA,OAAO;MACL,IAAIC,CAAJ;MACIH,EAAKrB,GAALqB,IAAYA,EAAKI,KAAjBJ,KAAwBG,IAAUE,KAAKC,GAALD,EAAlCL;MACJ,MAAMO,IAAUT,GAAhB;MAGA,MAFoBS,EAAQX,MAARW,KAAmBL,EAAKN,MAAxBW,IAAkCA,EAAQC,IAARD,CAAa,CAACE,CAAD,EAAMC,CAAN,KAAgBR,EAAKQ,CAALR,MAAgBO,CAA7CF,CAEtD,GACE,OAAON,CAAP;MAIF,IAAIU,CAAJ;;MAKA,IANAT,IAAOK,CAAPL,EAEIF,EAAKrB,GAALqB,IAAYA,EAAKI,KAAjBJ,KAAwBW,IAAaN,KAAKC,GAALD,EAArCL,CAFJE,EAGAD,IAASF,KAAMQ,CAANR,CAHTG,EAIQ,QAARF,CAAQ,IAAiC,QAAjBA,EAAKY,QAArB,IAAiDZ,EAAKY,QAALZ,CAAcC,CAAdD,CAJzDE,EAMIF,EAAKrB,GAALqB,IAAYA,EAAKI,KAAjBJ,IACU,QAARA,CADFA,IACkBA,EAAKI,KAALJ,EADtB,EACoC;QAChC,MAAMa,IAAaC,KAAKC,KAALD,CAAoC,OAAxBT,KAAKC,GAALD,KAAaF,CAAW,CAApCW,IAA2C,GAA9D;QAAA,MACME,IAAgBF,KAAKC,KAALD,CAAuC,OAA3BT,KAAKC,GAALD,KAAaM,CAAc,CAAvCG,IAA8C,GADpE;QAAA,MAEMG,IAAsBD,IAAgB,EAF5C;QAAA,MAIME,IAAM,CAACC,CAAD,EAAMC,CAAN,KAAMA;UAGhB,KAFAD,IAAME,OAAOF,CAAPE,CAEN,EAAOF,EAAIvB,MAAJuB,GAAaC,CAApB,GACED,IAAM,MAAMA,CAAZA;;UAGF,OAAOA,CAAP;QAAOA,CAXT;;QAcAG,QAAQC,IAARD,CAAa,SAAcJ,EAAIF,CAAJE,EAAmB,CAAnBA,CAAd,GAAsC,IAAtC,GAA6CA,EAAIL,CAAJK,EAAgB,CAAhBA,CAA7C,GAAkE,KAA/EI,EAAsF,6FAA6FR,KAAKU,GAALV,CAAS,CAATA,EAAYA,KAAKW,GAALX,CAAS,MAAM,MAAMG,CAArBH,EAA0C,GAA1CA,CAAZA,CAA7F,GAA2J,gBAAjPQ,EAA2Q,QAARtB,CAAQ,GAARA,KAAe,CAAP,GAAgBA,EAAKrB,GAAhS2C;MAIJ;;MAAA,OAAOrB,CAAP;IAAOA,CApCT;EAwCF;;EAAA,SAASyB,CAAT,CAAsB9C,CAAtB,EAAgC+C,CAAhC,EAA2CC,CAA3C,EAAkDC,CAAlD,EAAkDA;IAChD,IAAIC,CAAJ,EAAUC,CAAV;;IAEA,MAAMC,IAAgBpD,EAASqD,oBAATrD,EAAtB;;IAKA,IACIsD,CADJ;IAAA,IAAIC,IAAgG,SAA1FL,IAAyC,SAAjCC,KAHlBJ,IAAY,KAAKK,CAAL;MAAKA,GACZL;IADO,CAGMI,EAA0BI,EAAO,IAAOJ,CAAP,GAAuBJ,EAAUS,WAAgB,IAAON,CAAP,GAA0C,mBAArBH,EAAUU,MAAW,GAAWV,EAAUU,MAArB,GAAqBA,KAASC,CAA5K;IASA,IANIX,EAAUO,UAAVP,GACFO,IAAaP,EAAUO,UADrBP,GAEOA,EAAUS,WAAVT,KACTO,IAAaK,KAAeA,EAAYZ,EAAUS,WAAtBG,CADnBZ,CAFPA,EAGgDS,CAG/CD,CAAL,EAKE,MAAM,IAAIK,KAAJ,EAAN;IAGF,IAAIC,IAAS;MACXN,IAAI,KAAKA,CADE;MAEXD,aAFW;MAGXL,QAAQA,CAHG;MAIXD,QAJW;MAKXD,YALW;MAMXe,eAAef,EAAUe,aANd;MAOXC,SAAS,EAPE;MAQXC,gBAAgB/C,EAAK,MAAM,EAAC,CAAD,CAAXA,EAAmB;QACjC,IAAIgD,CAAJ;QAEA,OAAO,CAACJ,CAAD,EAACA,IAAkD,SAArCI,IAAkBJ,EAAOE,OAAY,IAAZA,KAAmB,CAAP,GAAgBE,EAAgBC,OAAhBD,CAAwB7D,KAAKA,EAAE4D,cAAF5D,EAA7B6D,CAAlEJ,CAAD,CAAP;MAAyGG,CAH3F/C,EAIb;QACDlB,KAA8C,uBAD7C;QAEDyB,OAAO;UACL,IAAI2C,CAAJ;UAEA,OAA8D,SAAtDA,IAAwBnE,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOF,CAAP,GAA+BnE,EAASoE,OAATpE,CAAiBsE,YAA9G;QAA8GA;MAL/G,CAJarD,CARL;MAoBXsD,gBAAgBtD,EAAK,MAAM,CAACjB,EAASwE,kBAATxE,EAAD,CAAXiB,EAA4CwD;QAC1D,IAAIC,CAAJ;;QAEA,IAA2C,SAAtCA,IAAmBb,EAAOE,OAAY,KAAQW,EAAiB1D,MAApE,EAA4E;UAC1E,IAAI2D,IAAcd,EAAOE,OAAPF,CAAeK,OAAfL,CAAuBA,KAAUA,EAAOU,cAAPV,EAAjCA,CAAlB;UACA,OAAOY,EAAaE,CAAbF,CAAP;QAGF;;QAAA,OAAO,CAACZ,CAAD,CAAP;MAAQA,CARM5C,EASb;QACDlB,KAA8C,uBAD7C;QAEDyB,OAAO;UACL,IAAIoD,CAAJ;UAEA,OAA+D,SAAvDA,IAAyB5E,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOO,CAAP,GAAgC5E,EAASoE,OAATpE,CAAiBsE,YAAhH;QAAgHA;MALjH,CATarD;IApBL,CAAb;IA0CA,OAJA4C,IAAS7D,EAAS6E,SAAT7E,CAAmB8E,MAAnB9E,CAA0B,CAAC+E,CAAD,EAAMC,CAAN,KAC1BC,OAAOC,MAAPD,CAAcF,CAAdE,EAA2C,QAAxBD,EAAQlC,YAAgB,GAAhBA,KAAuB,CAAP,GAAgBkC,EAAQlC,YAARkC,CAAqBnB,CAArBmB,EAA6BhF,CAA7BgF,CAA3DC,CADAjF,EAEN6D,CAFM7D,CAAT6D,EAIOA,CAAP;EAIF;;EAAA,SAASsB,CAAT,CAAsBnF,CAAtB,EAAgC6D,CAAhC,EAAwCO,CAAxC,EAAwCA;IACtC,IAAIgB,CAAJ;IAGA,IAAI3B,IAAS;MACXF,IAFuC,SAA7B6B,IAAchB,EAAQb,EAAO,IAAO6B,CAAP,GAAqBvB,EAAON,EACxD;MAEXM,SAFW;MAGX/B,OAAOsC,EAAQtC,KAHJ;MAIXuD,iBAAiBjB,EAAQiB,aAJd;MAKXC,eAAelB,EAAQkB,aALZ;MAMXtC,OAAOoB,EAAQpB,KANJ;MAOXuC,YAAY,EAPD;MAQXC,SAAS,CARE;MASXC,SAAS,CATE;MAUXC,aAAa,IAVF;MAWXC,gBAAgB;QACd,MAAMC,IAAc,EAApB;QAAA,MAEMC,IAAgBC;UAChBA,EAAEP,UAAFO,IAAgBA,EAAEP,UAAFO,CAAa9E,MAA7B8E,IACFA,EAAEP,UAAFO,CAAaC,GAAbD,CAAiBD,CAAjBC,CADEA,EAIJF,EAAY9E,IAAZ8E,CAAiBE,CAAjBF,CAJIE;QAIaA,CAPnB;;QAWA,OADAD,EAAcpC,CAAdoC,GACOD,CAAP;MAAOA,CAvBE;MAyBXI,cAAc,MAAMnC,EAAOd,SAAPc,CAAiBJ,MAAjBI,GAA0B7D,EAASiG,OAATjG,CAAiB6D,EAAOd,SAAPc,CAAiBJ,MAAlCzD,EAA0C;QACtFA,WADsF;QAEtFyD,QAAQA,CAF8E;QAGtFI;MAHsF,CAA1C7D,CAA1B6D,GAIf,IA7BM;MA8BXqC,cAAc,MAAMrC,EAAOd,SAAPc,CAAiBsC,MAAjBtC,GAA0B7D,EAASiG,OAATjG,CAAiB6D,EAAOd,SAAPc,CAAiBsC,MAAlCnG,EAA0C;QACtFA,WADsF;QAEtFyD,QAAQA,CAF8E;QAGtFI;MAHsF,CAA1C7D,CAA1B6D,GAIf;IAlCM,CAAb;IAyCA,OAJA7D,EAAS6E,SAAT7E,CAAmBY,OAAnBZ,CAA2BgF;MACzBC,OAAOC,MAAPD,CAAcxB,CAAdwB,EAA8C,QAAxBD,EAAQG,YAAgB,GAAhBA,KAAuB,CAAP,GAAgBH,EAAQG,YAARH,CAAqBvB,CAArBuB,EAA6BhF,CAA7BgF,CAA9DC;IAA2FjF,CAD7FA,GAIOyD,CAAP;EAGG;;EAAA,MAAC2C,IAAU;IACdC,gBAAgBrG,MACP;MAELsG,iBAAiBrF,EAAK,MAAM,CAACjB,EAASuG,aAATvG,EAAD,EAA2BA,EAASwG,qBAATxG,EAA3B,EAA6DA,EAASyG,QAATzG,GAAoB0G,aAApB1G,CAAkC2G,IAA/F,EAAqG3G,EAASyG,QAATzG,GAAoB0G,aAApB1G,CAAkC4G,KAAvI,CAAX3F,EAA0J,CAAC4F,CAAD,EAAalC,CAAb,EAA0BgC,CAA1B,EAAgCC,CAAhC,KAAgCA;QACzM,IAAIE,CAAJ,EAAsBC,CAAtB;QAEA,MAAMC,IAA6I,SAA9HF,IAA2B,QAARH,CAAQ,GAARA,KAAe,CAAP,GAAgBA,EAAKZ,GAALY,CAASM,KAAYtC,EAAYuC,IAAZvC,CAAiBvE,KAAKA,EAAEmD,EAAFnD,KAAS6G,CAA/BtC,CAArBgC,EAA+DQ,MAA/DR,CAAsES,OAAtET,CAAmF,IAAOG,CAAP,GAA0B,EAA7K;QAAA,MACMO,IAAiJ,SAAjIN,IAA6B,QAATH,CAAS,GAATA,KAAgB,CAAP,GAAgBA,EAAMb,GAANa,CAAUK,KAAYtC,EAAYuC,IAAZvC,CAAiBvE,KAAKA,EAAEmD,EAAFnD,KAAS6G,CAA/BtC,CAAtBiC,EAAgEO,MAAhEP,CAAuEQ,OAAvER,CAAoF,IAAOG,CAAP,GAA2B,EADlL;QAIA,OADqBO,EAAkBT,CAAlBS,EAA8B,IAAIN,CAAJ,EAAIA,GADjCrC,EAAYwC,MAAZxC,CAAmBd,OAAoB,QAAR8C,CAAQ,IAAQA,EAAKY,QAALZ,CAAc9C,EAAON,EAArBoD,CAAR,IAAgD,QAATC,CAAS,IAAQA,EAAMW,QAANX,CAAe/C,EAAON,EAAtBqD,CAA5E/C,CAAnBc,CAC6B,EADwFpB,GAClD8D,CAAtC,CAA9BC,EAAmFtH,CAAnFsH,CACrB;MADwGtH,CANzFiB,EAQd;QACDlB,MAAK,CADJ;QAEDyB,OAAO;UACL,IAAI2C,CAAJ;UAEA,OAA8D,SAAtDA,IAAwBnE,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOF,CAAP,GAA+BnE,EAASoE,OAATpE,CAAiBwH,YAA9G;QAA8GA;MAL/G,CARcvG,CAFZ;MAkBLwG,uBAAuBxG,EAAK,MAAM,CAACjB,EAASuG,aAATvG,EAAD,EAA2BA,EAASwG,qBAATxG,EAA3B,EAA6DA,EAASyG,QAATzG,GAAoB0G,aAApB1G,CAAkC2G,IAA/F,EAAqG3G,EAASyG,QAATzG,GAAoB0G,aAApB1G,CAAkC4G,KAAvI,CAAX3F,EAA0J,CAAC4F,CAAD,EAAalC,CAAb,EAA0BgC,CAA1B,EAAgCC,CAAhC,KAExKU,EAAkBT,CAAlBS,EADP3C,IAAcA,EAAYwC,MAAZxC,CAAmBd,OAAoB,QAAR8C,CAAQ,IAAQA,EAAKY,QAALZ,CAAc9C,EAAON,EAArBoD,CAAR,IAAgD,QAATC,CAAS,IAAQA,EAAMW,QAANX,CAAe/C,EAAON,EAAtBqD,CAA5E/C,CAAnBc,CACP2C,EAA2CtH,CAA3CsH,EAAqD,QAArDA,CAFcrG,EAGpB;QACDlB,MAAK,CADJ;QAEDyB,OAAO;UACL,IAAIoD,CAAJ;UAEA,OAA+D,SAAvDA,IAAyB5E,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOO,CAAP,GAAgC5E,EAASoE,OAATpE,CAAiBwH,YAAhH;QAAgHA;MALjH,CAHoBvG,CAlBlB;MA6BLyG,qBAAqBzG,EAAK,MAAM,CAACjB,EAASuG,aAATvG,EAAD,EAA2BA,EAASwG,qBAATxG,EAA3B,EAA6DA,EAASyG,QAATzG,GAAoB0G,aAApB1G,CAAkC2G,IAA/F,CAAX1F,EAAiH,CAAC4F,CAAD,EAAalC,CAAb,EAA0BgC,CAA1B,KAA0BA;QAC9J,IAAIgB,CAAJ;QAGA,OAAOL,EAAkBT,CAAlBS,EADoJ,SAA/HK,IAA4B,QAARhB,CAAQ,GAARA,KAAe,CAAP,GAAgBA,EAAKZ,GAALY,CAASM,KAAYtC,EAAYuC,IAAZvC,CAAiBvE,KAAKA,EAAEmD,EAAFnD,KAAS6G,CAA/BtC,CAArBgC,EAA+DQ,MAA/DR,CAAsES,OAAtET,CAAmF,IAAOgB,CAAP,GAA2B,EAC/KL,EAAkDtH,CAAlDsH,EAA4D,MAA5DA,CAAP;MAAmE,CAJhDrG,EAKlB;QACDlB,MAAK,CADJ;QAEDyB,OAAO;UACL,IAAIoG,CAAJ;UAEA,OAA+D,SAAvDA,IAAyB5H,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOuD,CAAP,GAAgC5H,EAASoE,OAATpE,CAAiBwH,YAAhH;QAAgHA;MALjH,CALkBvG,CA7BhB;MA0CL4G,sBAAsB5G,EAAK,MAAM,CAACjB,EAASuG,aAATvG,EAAD,EAA2BA,EAASwG,qBAATxG,EAA3B,EAA6DA,EAASyG,QAATzG,GAAoB0G,aAApB1G,CAAkC4G,KAA/F,CAAX3F,EAAkH,CAAC4F,CAAD,EAAalC,CAAb,EAA0BiC,CAA1B,KAA0BA;QAChK,IAAIkB,CAAJ;QAGA,OAAOR,EAAkBT,CAAlBS,EADuJ,SAAlIQ,IAA8B,QAATlB,CAAS,GAATA,KAAgB,CAAP,GAAgBA,EAAMb,GAANa,CAAUK,KAAYtC,EAAYuC,IAAZvC,CAAiBvE,KAAKA,EAAEmD,EAAFnD,KAAS6G,CAA/BtC,CAAtBiC,EAAgEO,MAAhEP,CAAuEQ,OAAvER,CAAoF,IAAOkB,CAAP,GAA4B,EACnLR,EAAkDtH,CAAlDsH,EAA4D,OAA5DA,CAAP;MAAmE,CAJ/CrG,EAKnB;QACDlB,MAAK,CADJ;QAEDyB,OAAO;UACL,IAAIuG,CAAJ;UAEA,OAA+D,SAAvDA,IAAyB/H,EAASoE,OAATpE,CAAiBqE,QAAa,IAAO0D,CAAP,GAAgC/H,EAASoE,OAATpE,CAAiBwH,YAAhH;QAAgHA;MALjH,CALmBvG,CA1CjB;MAwDL+G,iBAAiB/G,EAAK,MAAM,CAACjB,EAASsG,eAATtG,EAAD,CAAXiB,EAAyCgH,KACjD,IAAIA,CAAJ,EAAkBC,OAAlB,EADQjH,EAEd;QACDlB,MAAK,CADJ;QAEDyB,OAAO;UACL,IAAI2G,CAAJ;UAEA,OAA+D,SAAvDA,IAAyBnI,EAASoE,OAATpE,CAAiBqE,QAAa,IAAO8D,CAAP,GAAgCnI,EAASoE,OAATpE,CAAiBwH,YAAhH;QAAgHA;MALjH,CAFcvG,CAxDZ;MAkELmH,qBAAqBnH,EAAK,MAAM,CAACjB,EAAS0H,mBAAT1H,EAAD,CAAXiB,EAA6CgH,KACzD,IAAIA,CAAJ,EAAkBC,OAAlB,EADYjH,EAElB;QACDlB,MAAK,CADJ;QAEDyB,OAAO;UACL,IAAI6G,CAAJ;UAEA,OAA+D,SAAvDA,IAAyBrI,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOgE,CAAP,GAAgCrI,EAASoE,OAATpE,CAAiBwH,YAAhH;QAAgHA;MALjH,CAFkBvG,CAlEhB;MA4ELqH,uBAAuBrH,EAAK,MAAM,CAACjB,EAASyH,qBAATzH,EAAD,CAAXiB,EAA+CgH,KAC7D,IAAIA,CAAJ,EAAkBC,OAAlB,EADcjH,EAEpB;QACDlB,MAAK,CADJ;QAEDyB,OAAO;UACL,IAAI+G,CAAJ;UAEA,OAA+D,SAAvDA,IAAyBvI,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOkE,CAAP,GAAgCvI,EAASoE,OAATpE,CAAiBwH,YAAhH;QAAgHA;MALjH,CAFoBvG,CA5ElB;MAsFLuH,sBAAsBvH,EAAK,MAAM,CAACjB,EAAS6H,oBAAT7H,EAAD,CAAXiB,EAA8CgH,KAC3D,IAAIA,CAAJ,EAAkBC,OAAlB,EADajH,EAEnB;QACDlB,MAAK,CADJ;QAEDyB,OAAO;UACL,IAAIiH,CAAJ;UAEA,OAA+D,SAAvDA,IAAyBzI,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOoE,CAAP,GAAgCzI,EAASoE,OAATpE,CAAiBwH,YAAhH;QAAgHA;MALjH,CAFmBvG,CAtFjB;MAiGLyH,gBAAgBzH,EAAK,MAAM,CAACjB,EAASsG,eAATtG,EAAD,CAAXiB,EAAyCgH,KAChDA,EAAalC,GAAbkC,CAAiBvC,KACfA,EAAYiD,OADdV,EAEJxH,IAFIwH,EADOhH,EAIb;QACDlB,MAAK,CADJ;QAEDyB,OAAO;UACL,IAAIoH,CAAJ;UAEA,OAA+D,SAAvDA,IAAyB5I,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOuE,CAAP,GAAgC5I,EAASoE,OAATpE,CAAiBwH,YAAhH;QAAgHA;MALjH,CAJavG,CAjGX;MA6GL4H,oBAAoB5H,EAAK,MAAM,CAACjB,EAAS0H,mBAAT1H,EAAD,CAAXiB,EAA6C0F,KACxDA,EAAKZ,GAALY,CAASjB,KACPA,EAAYiD,OADdhC,EAEJlG,IAFIkG,EADW1F,EAIjB;QACDlB,MAAK,CADJ;QAEDyB,OAAO;UACL,IAAIsH,CAAJ;UAEA,OAAgE,SAAxDA,IAA0B9I,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOyE,CAAP,GAAiC9I,EAASoE,OAATpE,CAAiBwH,YAAlH;QAAkHA;MALnH,CAJiBvG,CA7Gf;MAyHL8H,sBAAsB9H,EAAK,MAAM,CAACjB,EAASyH,qBAATzH,EAAD,CAAXiB,EAA+C0F,KAC5DA,EAAKZ,GAALY,CAASjB,KACPA,EAAYiD,OADdhC,EAEJlG,IAFIkG,EADa1F,EAInB;QACDlB,MAAK,CADJ;QAEDyB,OAAO;UACL,IAAIwH,CAAJ;UAEA,OAAgE,SAAxDA,IAA0BhJ,EAASoE,OAATpE,CAAiBqE,QAAa,IAAO2E,CAAP,GAAiChJ,EAASoE,OAATpE,CAAiBwH,YAAlH;QAAkHA;MALnH,CAJmBvG,CAzHjB;MAqILgI,qBAAqBhI,EAAK,MAAM,CAACjB,EAAS6H,oBAAT7H,EAAD,CAAXiB,EAA8C0F,KAC1DA,EAAKZ,GAALY,CAASjB,KACPA,EAAYiD,OADdhC,EAEJlG,IAFIkG,EADY1F,EAIlB;QACDlB,MAAK,CADJ;QAEDyB,OAAO;UACL,IAAI0H,CAAJ;UAEA,OAAgE,SAAxDA,IAA0BlJ,EAASoE,OAATpE,CAAiBqE,QAAa,IAAO6E,CAAP,GAAiClJ,EAASoE,OAATpE,CAAiBwH,YAAlH;QAAkHA;MALnH,CAJkBvG,CArIhB;MAkJLkI,sBAAsBlI,EAAK,MAAM,CAACjB,EAAS+I,oBAAT/I,EAAD,CAAXiB,EAA8CmI,KAC3DA,EAAYjC,MAAZiC,CAAmB3F;QACxB,IAAI4F,CAAJ;QAEA,SAAqD,SAA3CA,IAAqB5F,EAAO8B,UAAe,KAAQ8D,EAAmBrI,MAAhF;MAAgFA,CAH3EoI,CADanI,EAMnB;QACDlB,MAAK,CADJ;QAEDyB,OAAO;UACL,IAAI8H,CAAJ;UAEA,OAAgE,SAAxDA,IAA0BtJ,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOiF,CAAP,GAAiCtJ,EAASoE,OAATpE,CAAiBwH,YAAlH;QAAkHA;MALnH,CANmBvG,CAlJjB;MAgKLsI,oBAAoBtI,EAAK,MAAM,CAACjB,EAAS6I,kBAAT7I,EAAD,CAAXiB,EAA4CmI,KACvDA,EAAYjC,MAAZiC,CAAmB3F;QACxB,IAAI+F,CAAJ;QAEA,SAAsD,SAA5CA,IAAsB/F,EAAO8B,UAAe,KAAQiE,EAAoBxI,MAAlF;MAAkFA,CAH7EoI,CADWnI,EAMjB;QACDlB,MAAK,CADJ;QAEDyB,OAAO;UACL,IAAIiI,CAAJ;UAEA,OAAgE,SAAxDA,IAA0BzJ,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOoF,CAAP,GAAiCzJ,EAASoE,OAATpE,CAAiBwH,YAAlH;QAAkHA;MALnH,CANiBvG,CAhKf;MA8KLyI,qBAAqBzI,EAAK,MAAM,CAACjB,EAASiJ,mBAATjJ,EAAD,CAAXiB,EAA6CmI,KACzDA,EAAYjC,MAAZiC,CAAmB3F;QACxB,IAAIkG,CAAJ;QAEA,SAAsD,SAA5CA,IAAsBlG,EAAO8B,UAAe,KAAQoE,EAAoB3I,MAAlF;MAAkFA,CAH7EoI,CADYnI,EAMlB;QACDlB,MAAK,CADJ;QAEDyB,OAAO;UACL,IAAIoI,CAAJ;UAEA,OAAgE,SAAxDA,IAA0B5J,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOuF,CAAP,GAAiC5J,EAASoE,OAATpE,CAAiBwH,YAAlH;QAAkHA;MALnH,CANkBvG,CA9KhB;MA4LL0E,gBAAgB1E,EAAK,MAAM,CAACjB,EAAS0H,mBAAT1H,EAAD,EAAiCA,EAASyH,qBAATzH,EAAjC,EAAmEA,EAAS6H,oBAAT7H,EAAnE,CAAXiB,EAAgH,CAAC0F,CAAD,EAAOkD,CAAP,EAAejD,CAAf,KAAeA;QAC7I,IAAIkD,CAAJ,EAAqBC,CAArB,EAA6BC,CAA7B,EAAgDC,CAAhD,EAA0DC,CAA1D,EAA4EC,CAA5E;QAEA,OAAO,KAAiF,SAA3EL,IAAwC,SAArBC,IAASpD,EAAK,CAALA,CAAY,IAAP,KAAc,CAAP,GAAgBoD,EAAOpB,OAAY,IAAOmB,CAAP,GAAyB,EAA1G,GAA0G,IAA6F,SAAnFE,IAA8C,SAAzBC,IAAWJ,EAAO,CAAPA,CAAc,IAAP,KAAc,CAAP,GAAgBI,EAAStB,OAAY,IAAOqB,CAAP,GAA2B,EAAxH,CAA1G,EAAkO,IAAyF,SAA/EE,IAA2C,SAAvBC,IAAUvD,EAAM,CAANA,CAAa,IAAP,KAAc,CAAP,GAAgBuD,EAAQxB,OAAY,IAAOuB,CAAP,GAA0B,EAAnH,CAAlO,EAA0VnE,GAA1V,CAA8VtC,KAC5VA,EAAOkC,cAAPlC,EADF,EAEJhD,IAFI,EAAP;MAEGA,CALWQ,EAMb;QACDlB,MAAK,CADJ;QAEDyB,OAAO;UACL,IAAI4I,CAAJ;UAEA,OAAgE,SAAxDA,IAA0BpK,EAASoE,OAATpE,CAAiBqE,QAAa,IAAO+F,CAAP,GAAiCpK,EAASoE,OAATpE,CAAiBwH,YAAlH;QAAkHA;MALnH,CANavG;IA5LX,CADOjB;EADF,CAAX;;EA+ML,SAASsH,CAAT,CAA2BT,CAA3B,EAAuCwD,CAAvC,EAAuDrK,CAAvD,EAAiEsK,CAAjE,EAAiEA;IAC/D,IAAIC,CAAJ,EAA2BC,CAA3B;IAOA,IAAIC,IAAW,CAAf;;IAEA,MAAMC,IAAe,UAAU3G,CAAV,EAAmBf,CAAnB,EAAmBA;MAAAA,KACxB,CADwBA,KAClCA,CADkCA,KAEpCA,IAAQ,CAF4BA,GAKtCyH,IAAWvI,KAAKU,GAALV,CAASuI,CAATvI,EAAmBc,CAAnBd,CAL2Bc,EAMtCe,EAAQoD,MAARpD,CAAeF,KAAUA,EAAO8G,YAAP9G,EAAzBE,EAAgDnD,OAAhDmD,CAAwDF;QACtD,IAAII,CAAJ;QAE0C,SAArCA,IAAkBJ,EAAOE,OAAY,KAAQE,EAAgBjD,MAAxB,IACxC0J,EAAa7G,EAAOE,OAApB2G,EAA6B1H,IAAQ,CAArC0H,CADwC;MACH,CAJzC3G,EAMG,CANHA,CANsCf;IAYnC,CAZL;;IAeA0H,EAAa7D,CAAb6D;IACA,IAAIzC,IAAe,EAAnB;;IAEA,MAAM2C,IAAoB,CAACC,CAAD,EAAiB7H,CAAjB,KAAiBA;MAEzC,MAAM0C,IAAc;QAClB1C,QADkB;QAElBO,IAAI,CAAC+G,CAAD,EAAe,KAAKtH,CAApB,EAA2BmE,MAA3B,CAAkCC,OAAlC,EAA2C0D,IAA3C,CAAgD,GAAhD,CAFc;QAGlBnC,SAAS;MAHS,CAApB;MAAA,MAMMoC,IAAuB,EAN7B;MAQAF,EAAejK,OAAfiK,CAAuBG;QAErB,MAAMC,IAA4B,IAAIF,CAAJ,EAA0B7C,OAA1B,GAAoC,CAApC,CAAlC;QAEA,IAAIrE,CAAJ;QAAA,IACIwB,KAAgB,CADpB;QAYA,IAbqB2F,EAAcnH,MAAdmH,CAAqBhI,KAArBgI,KAA+BtF,EAAY1C,KAA3CgI,IAIDA,EAAcnH,MAAdmH,CAAqB/H,MAJpB+H,GAMnBnH,IAASmH,EAAcnH,MAAdmH,CAAqB/H,MANX+H,IASnBnH,IAASmH,EAAcnH,MAAvBA,EACAwB,KAAgB,CAVG2F,GAUH,CAGgB,QAA7BC,CAA6B,GAA7BA,KAAoC,CAAP,GAAgBA,EAA0BpH,MAH1D,MAGsEA,CAAxF,EAEEoH,EAA0B1F,UAA1B0F,CAAqCnK,IAArCmK,CAA0CD,CAA1CC,EAFF,KAGO;UAEL,MAAMxH,IAAS0B,EAAanF,CAAbmF,EAAuBtB,CAAvBsB,EAA+B;YAC5C5B,IAAI,CAAC+G,CAAD,EAAetH,CAAf,EAAsBa,EAAON,EAA7B,EAAkD,QAAjByH,CAAiB,GAAjBA,KAAwB,CAAP,GAAgBA,EAAczH,EAAhF,EAAoF4D,MAApF,CAA2FC,OAA3F,EAAoG0D,IAApG,CAAyG,GAAzG,CADwC;YAE5CzF,gBAF4C;YAG5CC,eAAeD,IAAgB,KAAK0F,EAAqB5D,MAArB4D,CAA4B3K,KAAKA,EAAEyD,MAAFzD,KAAayD,CAA9CkH,EAAsD/J,MAA3EqE,GAA2ErE,KAAS0C,CAHvD;YAI5CV,QAJ4C;YAK5ClB,OAAOiJ,EAAqB/J;UALgB,CAA/BmE,CAAf;UAQA1B,EAAO8B,UAAP9B,CAAkB3C,IAAlB2C,CAAuBuH,CAAvBvH,GAGAsH,EAAqBjK,IAArBiK,CAA0BtH,CAA1BsH,CAHAtH;QAMFiC;QAAAA,EAAYiD,OAAZjD,CAAoB5E,IAApB4E,CAAyBsF,CAAzBtF,GACAsF,EAActF,WAAdsF,GAA4BtF,CAD5BA;MAC4BA,CApC9BmF,GAsCA5C,EAAanH,IAAbmH,CAAkBvC,CAAlBuC,CAtCA4C,EAwCI7H,IAAQ,CAARA,IACF4H,EAAkBG,CAAlBH,EAAwC5H,IAAQ,CAAhD4H,CAzCFC;IAyCkD,CAnDpD;IAAA,MAuDMK,IAAgBb,EAAetE,GAAfsE,CAAmB,CAACxG,CAAD,EAAS/B,CAAT,KAAmBqD,EAAanF,CAAbmF,EAAuBtB,CAAvBsB,EAA+B;MACzFnC,OAAOyH,CADkF;MAEzF3I;IAFyF,CAA/BqD,CAAtCkF,CAvDtB;;IA2DAO,EAAkBM,CAAlBN,EAAiCH,IAAW,CAA5CG,GACA3C,EAAaC,OAAbD,EADA2C;;IAKA,MAAMO,IAAyBxC,KACLA,EAAQxB,MAARwB,CAAelF,KAAUA,EAAOI,MAAPJ,CAAckH,YAAdlH,EAAzBkF,EACD5C,GADC4C,CACGlF;MACzB,IAAI+B,IAAU,CAAd;MAAA,IACIC,IAAU,CADd;MAAA,IAEI2F,IAAgB,CAAC,CAAD,CAFpB;MAII3H,EAAO8B,UAAP9B,IAAqBA,EAAO8B,UAAP9B,CAAkBzC,MAAvCyC,IACF2H,IAAgB,EAAhBA,EACAD,EAAuB1H,EAAO8B,UAA9B4F,EAA0CvK,OAA1CuK,CAAkDjI;QAChD;UACEsC,SAAS6F,CADX;UAEE5F,SAAS6F;QAFX,IAGIpI,CAHJ;QAIAsC,KAAW6F,CAAX7F,EACA4F,EAActK,IAAdsK,CAAmBE,CAAnBF,CADA5F;MACmB8F,CANrBH,CAFE1H,IAWF+B,IAAU,CAXR/B;MAkBJ,OAHAgC,KADwBvD,KAAKW,GAALX,CAAKW,GAAOuI,CAAZlJ,CACxBuD,EACAhC,EAAO+B,OAAP/B,GAAiB+B,CADjBC,EAEAhC,EAAOgC,OAAPhC,GAAiBgC,CAFjBA,EAGO;QACLD,UADK;QAELC;MAFK,CAAP;IAEEA,CA1BoBkD,CAD1B;;IAiCA,OADAwC,EAAiI,SAAzGZ,IAA8D,SAArCC,IAAiBvC,EAAa,CAAbA,CAAoB,IAAP,KAAc,CAAP,GAAgBuC,EAAe7B,OAAY,IAAO4B,CAAP,GAA+B,EAAhKY,GACOlD,CAAP;EAIG;;EAAA,MAACsD,IAAsB;IAC1BC,MAAM,GADoB;IAE1BC,SAAS,EAFiB;IAG1BC,SAASC,OAAOC;EAHU,CAAvB;EAAA,MAeCC,IAAe;IACnBC,qBAAqB,MACZP,CAFU;IAInBQ,iBAAiBC,MACR;MACLC,cAAc,EADT;MAELC,kBAhByC;QAC7CC,aAAa,IADgC;QAE7CC,WAAW,IAFkC;QAG7CC,aAAa,IAHgC;QAI7CC,iBAAiB,IAJ4B;QAK7CC,mBAAkB,CAL2B;QAM7CC,mBAAmB;MAN0B,CAcpC;MARU,GAWZR;IAHE,CADQA,CAJE;IAWnBS,mBAAmBzM,MACV;MACL0M,kBAAkB,OADb;MAELC,sBAAsB7M,EAAiB,cAAjBA,EAAiCE,CAAjCF,CAFjB;MAGL8M,0BAA0B9M,EAAiB,kBAAjBA,EAAqCE,CAArCF;IAHrB,CADUE,CAXA;IAkBnB8C,cAAc,CAACe,CAAD,EAAS7D,CAAT,MACL;MACL6M,SAAS;QACP,IAAIC,CAAJ,EAA2B5J,CAA3B,EAAiC6J,CAAjC;QAEA,MAAMC,IAAahN,EAASyG,QAATzG,GAAoBiM,YAApBjM,CAAiC6D,EAAON,EAAxCvD,CAAnB;QACA,OAAOkC,KAAKW,GAALX,CAASA,KAAKU,GAALV,CAA+D,SAArD4K,IAAwBjJ,EAAOd,SAAPc,CAAiB4H,OAAY,IAAOqB,CAAP,GAA+BvB,EAAoBE,OAAlHvJ,EAA+L,SAAnEgB,IAAqB,QAAd8J,CAAc,GAAOA,CAAP,GAAoBnJ,EAAOd,SAAPc,CAAiB2H,IAAS,IAAOtI,CAAP,GAAcqI,EAAoBC,IAAjOtJ,CAATA,EAAuS,SAArD6K,IAAwBlJ,EAAOd,SAAPc,CAAiB6H,OAAY,IAAOqB,CAAP,GAA+BxB,EAAoBG,OAA1VxJ,CAAP;MAAiWwJ,CAL9V;MAOLuB,UAAUC;QACR,MAAMnJ,IAAWmJ,IAA2D,WAAbA,CAAa,GAASlN,EAASmN,yBAATnN,EAAT,GAAgDA,EAASoN,0BAATpN,EAA3GkN,GAAWlN,EAASwG,qBAATxG,EAA5B;QAAA,MACM8B,IAAQiC,EAAQsJ,SAARtJ,CAAkB3D,KAAKA,EAAEmD,EAAFnD,KAASyD,EAAON,EAAvCQ,CADd;;QAGA,IAAIjC,IAAQ,CAAZ,EAAe;UACb,MAAMwL,IAAoBvJ,EAAQjC,IAAQ,CAAhBiC,CAA1B;UACA,OAAOuJ,EAAkBL,QAAlBK,CAA2BJ,CAA3BI,IAAuCA,EAAkBT,OAAlBS,EAA9C;QAGF;;QAAA,OAAO,CAAP;MAAO,CAhBJ;MAkBLC,WAAW;QACTvN,EAASwN,eAATxN,CAAyByN;UACvB;YACE,CAAC5J,EAAON,EAAR,GAAamK,CADf;YACeA,GACVC;UAFL,IAGIF,CAHJ;UAIA,OAAOE,CAAP;QAAOA,CALT3N;MAKS2N,CAxBN;MA2BLC,cAAc;QACZ,IAAIC,CAAJ,EAA2BC,CAA3B;QAEA,QAAqE,SAA5DD,IAAwBhK,EAAOd,SAAPc,CAAiBkK,cAAmB,KAAOF,CAA5E,MAAiL,SAAlEC,IAAwB9N,EAASoE,OAATpE,CAAiBgO,oBAAyB,KAAOF,CAAxL;MAAwLA,CA9BrL;MAgCLG,eAAe,MACNjO,EAASyG,QAATzG,GAAoBkM,gBAApBlM,CAAqCuM,gBAArCvM,KAA0D6D,EAAON;IAjCrE,CADK,CAlBK;IAwDnB4B,cAAc,CAAC1B,CAAD,EAASzD,CAAT,MACL;MACL6M,SAAS;QACP,IAAIqB,IAAM,CAAV;;QAEA,MAAMxN,IAAU+C;UAIZ,IAAI0K,CAAJ;UAHE1K,EAAO8B,UAAP9B,CAAkBzC,MAAlByC,GACFA,EAAO8B,UAAP9B,CAAkB7C,OAAlB6C,CAA0B/C,CAA1B+C,CADEA,GAKFyK,KAA4D,SAApDC,IAAwB1K,EAAOI,MAAPJ,CAAcoJ,OAAdpJ,EAA4B,IAAO0K,CAAP,GAA+B,CALzF1K;QAKyF,CAN/F;;QAWA,OADA/C,EAAQ+C,CAAR/C,GACOwN,CAAP;MAAOA,CAfJ;MAiBLjB,UAAU;QACR,IAAIxJ,EAAO3B,KAAP2B,GAAe,CAAnB,EAAsB;UACpB,MAAM2K,IAAoB3K,EAAOiC,WAAPjC,CAAmBkF,OAAnBlF,CAA2BA,EAAO3B,KAAP2B,GAAe,CAA1CA,CAA1B;UACA,OAAO2K,EAAkBnB,QAAlBmB,KAA+BA,EAAkBvB,OAAlBuB,EAAtC;QAGF;;QAAA,OAAO,CAAP;MAAO,CAvBJ;MAyBLC,kBAAkB;QAChB,MAAMxK,IAAS7D,EAASsO,SAATtO,CAAmByD,EAAOI,MAAPJ,CAAcF,EAAjCvD,CAAf;QAAA,MACMuO,IAAY1K,EAAO+J,YAAP/J,EADlB;QAEA,OAAO2K;UACL,KAAKD,CAAL,EACE;UAIF,IAFa,QAAbC,EAAEC,OAAW,IAAgBD,EAAEC,OAAFD,EAAhB,EAETE,EAAkBF,CAAlBE,KAEEF,EAAEG,OAFJD,IAEeF,EAAEG,OAAFH,CAAUxN,MAAVwN,GAAmB,CAFtC,EAGI;;UAIJ,MAAMpC,IAAY3I,EAAOoJ,OAAPpJ,EAAlB;UAAA,MACM+I,IAAoB/I,IAASA,EAAOkC,cAAPlC,GAAwBsC,GAAxBtC,CAA4BrD,KAAK,CAACA,EAAEyD,MAAFzD,CAASmD,EAAV,EAAcnD,EAAEyD,MAAFzD,CAASyM,OAATzM,EAAd,CAAjCqD,CAATA,GAA+E,CAAC,CAACI,EAAON,EAAR,EAAYM,EAAOgJ,OAAPhJ,EAAZ,CAAD,CADzG;UAAA,MAEM+K,IAAUF,EAAkBF,CAAlBE,IAAuBxM,KAAKC,KAALD,CAAWsM,EAAEG,OAAFH,CAAU,CAAVA,EAAaI,OAAxB1M,CAAvBwM,GAA0DF,EAAEI,OAF5E;UAAA,MAIMC,IAAe,CAACC,CAAD,EAAYC,CAAZ,KAAYA;YAC/B,IAA0B,mBAAfA,CAAX,EACE;YAGF,IAAIC,IAAkB,EAAtB;YACAhP,EAASiP,mBAATjP,CAA6BE;cAC3B,IAAIgP,CAAJ,EAAsBC,CAAtB;cAEA,MAAM9C,IAAc0C,KAA6E,SAA9DG,IAA0B,QAAPhP,CAAO,GAAPA,KAAc,CAAP,GAAgBA,EAAIiM,WAAgB,IAAO+C,CAAP,GAA0B,CAAvGH,CAApB;cAAA,MACMzC,IAAkBpK,KAAKU,GAALV,CAASmK,KAA0E,SAA1D8C,IAAwB,QAAPjP,CAAO,GAAPA,KAAc,CAAP,GAAgBA,EAAIkM,SAAc,IAAO+C,CAAP,GAAwB,CAAlG9C,CAATnK,EAA2G,CAAK,OAAhHA,CADxB;cAMA,OAJAhC,EAAIsM,iBAAJtM,CAAsBU,OAAtBV,CAA8BkP;gBAC5B,KAAKnI,CAAL,EAAeoI,CAAf,IAA6BD,CAA7B;gBACAJ,EAAgB/H,CAAhB+H,IAA4B9M,KAAKC,KAALD,CAAoE,MAAzDA,KAAKU,GAALV,CAASmN,IAAaA,IAAa/C,CAAnCpK,EAAoD,CAApDA,CAAXA,IAA2E,GAAvG8M;cAAuG,CAFzG9O,GAIO,KAAKA,CAAL;gBACLmM,cADK;gBAELC;cAFK,CAAP;YAEEA,CAXJtM,GAe0C,eAAtCA,EAASoE,OAATpE,CAAiB0M,gBAAqB,IAA4B,UAAdoC,CAAd,IACxC9O,EAASwN,eAATxN,CAAyBE,MAAQ,KAAKA,CAAL;cAAKA,GACjC8O;YAD4B,CAAR9O,CAAzBF,CAhBFA;UAiBOgP,CA3BT;UAAA,MA8CMM,IAAc;YAClBC,aAAaf;cAAKgB,OAfLT,IAeYP,EAAEI,OAfdG,EAAcF,EAAa,MAAbA,EAAqBE,CAArBF,CAeTW;cAfLT;YAAAA,CAcK;YAElBU,WAAWjB;cAdCO;cAeVW,SAASC,mBAATD,CAA6B,WAA7BA,EAA0CJ,EAAYC,WAAtDG,GACAA,SAASC,mBAATD,CAA6B,SAA7BA,EAAwCJ,EAAYG,SAApDC,CADAA,EAfUX,IAiBJP,EAAEI,OAFRc,EAdFb,EAAa,KAAbA,EAAoBE,CAApBF,CAcEa,EAbF1P,EAASiP,mBAATjP,CAA6BE,MAAQ,KAAKA,CAAL;gBACnCqM,mBAAkB,CADiB;gBAEnCJ,aAAa,IAFsB;gBAGnCC,WAAW,IAHwB;gBAInCC,aAAa,IAJsB;gBAKnCC,iBAAiB,IALkB;gBAMnCE,mBAAmB;cANgB,CAARtM,CAA7BF,CAaE0P;YAPmB;UAIH,CA9CpB;UAAA,MAsDME,MAAqBC,GAArBD,IAA+C;YACnDE,UAAS;UAD0C,CAtDrD;;UA0DIpB,EAAkBF,CAAlBE,MACFgB,SAASK,gBAATL,CAA0B,WAA1BA,EAAuCJ,EAAYC,WAAnDG,EAAgEE,CAAhEF,GACAA,SAASK,gBAATL,CAA0B,SAA1BA,EAAqCJ,EAAYG,SAAjDC,EAA4DE,CAA5DF,CAFEhB,GAKJ1O,EAASiP,mBAATjP,CAA6BE,MAAQ,KAAKA,CAAL;YACnCiM,aAAayC,CADsB;YAEnCxC,YAFmC;YAGnCC,aAAa,CAHsB;YAInCC,iBAAiB,CAJkB;YAKnCE,oBALmC;YAMnCD,kBAAkB1I,EAAON;UANU,CAARrD,CAA7BF,CALI0O;QAWuBnL,CAlF7B;MAkF6BA;IA9G1B,CADK,CAxDK;IA6KnB8C,gBAAgBrG,MACP;MACLwN,iBAAiB5N,KAAoD,QAAzCI,EAASoE,OAATpE,CAAiB2M,oBAAwB,GAAxBA,KAA+B,CAAP,GAAgB3M,EAASoE,OAATpE,CAAiB2M,oBAAjB3M,CAAsCJ,CAAtCI,CADhF;MAELiP,qBAAqBrP,KAAwD,QAA7CI,EAASoE,OAATpE,CAAiB4M,wBAA4B,GAA5BA,KAAmC,CAAP,GAAgB5M,EAASoE,OAATpE,CAAiB4M,wBAAjB5M,CAA0CJ,CAA1CI,CAFxF;MAGLgQ,mBAAmBC;QACjB,IAAIC,CAAJ;QAEAlQ,EAASwN,eAATxN,CAAyBiQ,IAAe,EAAfA,GAAoF,SAA/DC,IAAwBlQ,EAASmQ,YAATnQ,CAAsBiM,YAAiB,IAAOiE,CAAP,GAA+B,EAA5IlQ;MAA4I,CANzI;MAQLoQ,qBAAqBH;QACnB,IAAII,CAAJ;QAEArQ,EAASiP,mBAATjP,CAA6BiQ,IAlMU;UAC7C9D,aAAa,IADgC;UAE7CC,WAAW,IAFkC;UAG7CC,aAAa,IAHgC;UAI7CC,iBAAiB,IAJ4B;UAK7CC,mBAAkB,CAL2B;UAM7CC,mBAAmB;QAN0B,CAkMVyD,GAAwH,SAApEI,IAAyBrQ,EAASmQ,YAATnQ,CAAsBkM,gBAAqB,IAAOmE,CAAP,GAlM9G;UAC7ClE,aAAa,IADgC;UAE7CC,WAAW,IAFkC;UAG7CC,aAAa,IAHgC;UAI7CC,iBAAiB,IAJ4B;UAK7CC,mBAAkB,CAL2B;UAM7CC,mBAAmB;QAN0B,CAkMvCxM;MA5La,CAiLV;MAaLsQ,cAAc;QACZ,IAAIC,CAAJ,EAA2BC,CAA3B;QAEA,OAEU,SAFFD,IAAoF,SAA3DC,IAAyBxQ,EAASsG,eAATtG,GAA2B,CAA3BA,CAAkC,IAAP,KAAc,CAAP,GAAgBwQ,EAAuB7H,OAAvB6H,CAA+B1L,MAA/B0L,CAAsC,CAACtC,CAAD,EAAMzK,CAAN,KACzIyK,IAAMzK,EAAOoJ,OAAPpJ,EAD6F+M,EAEzG,CAFyGA,CAElG,IAAOD,CAAP,GAA+B,CAFzC;MAEyC,CAlBtC;MAoBLE,kBAAkB;QAChB,IAAIC,CAAJ,EAA2BC,CAA3B;QAEA,OAEU,SAFFD,IAAwF,SAA/DC,IAAyB3Q,EAAS0H,mBAAT1H,GAA+B,CAA/BA,CAAsC,IAAP,KAAc,CAAP,GAAgB2Q,EAAuBhI,OAAvBgI,CAA+B7L,MAA/B6L,CAAsC,CAACzC,CAAD,EAAMzK,CAAN,KAC7IyK,IAAMzK,EAAOoJ,OAAPpJ,EADiGkN,EAE7G,CAF6GA,CAEtG,IAAOD,CAAP,GAA+B,CAFzC;MAEyC,CAzBtC;MA2BLE,oBAAoB;QAClB,IAAIC,CAAJ,EAA2BC,CAA3B;QAEA,OAEU,SAFFD,IAA0F,SAAjEC,IAAyB9Q,EAASyH,qBAATzH,GAAiC,CAAjCA,CAAwC,IAAP,KAAc,CAAP,GAAgB8Q,EAAuBnI,OAAvBmI,CAA+BhM,MAA/BgM,CAAsC,CAAC5C,CAAD,EAAMzK,CAAN,KAC/IyK,IAAMzK,EAAOoJ,OAAPpJ,EADmGqN,EAE/G,CAF+GA,CAExG,IAAOD,CAAP,GAA+B,CAFzC;MAEyC,CAhCtC;MAkCLE,mBAAmB;QACjB,IAAIC,CAAJ,EAA2BC,CAA3B;QAEA,OAEU,SAFFD,IAAyF,SAAhEC,IAAyBjR,EAAS6H,oBAAT7H,GAAgC,CAAhCA,CAAuC,IAAP,KAAc,CAAP,GAAgBiR,EAAuBtI,OAAvBsI,CAA+BnM,MAA/BmM,CAAsC,CAAC/C,CAAD,EAAMzK,CAAN,KAC9IyK,IAAMzK,EAAOoJ,OAAPpJ,EADkGwN,EAE9G,CAF8GA,CAEvG,IAAOD,CAAP,GAA+B,CAFzC;MAEyC;IAvCtC,CADOhR;EA7KG,CAfhB;EAyOL,IAAIkR,IAAmB,IAAvB;;EACA,SAASrB,CAAT,GAASA;IACP,IAAgC,oBAArBqB,CAAX,EAA2C,OAAOA,CAAP;IAC3C,IAAIC,KAAY,CAAhB;;IAEA;MACE,MAAM/M,IAAU;QACV0L;UAEF,OADAqB,KAAY,CAAZA,EAAY,CACL,CAAP;QAAO;;MAHK,CAAhB;MAAA,MAQMC,IAAO,QARb;;MAUAC,OAAOtB,gBAAPsB,CAAwB,MAAxBA,EAAgCD,CAAhCC,EAAsCjN,CAAtCiN,GACAA,OAAO1B,mBAAP0B,CAA2B,MAA3BA,EAAmCD,CAAnCC,CADAA;IAEA,CAbF,CAaE,OAAOC,CAAP,EAAOA;MACPH,KAAY,CAAZA;IAIF;;IAAA,OADAD,IAAmBC,CAAnBD,EACOA,CAAP;EAGF;;EAAA,SAASxC,CAAT,CAA2BF,CAA3B,EAA2BA;IACzB,OAAkB,iBAAXA,EAAE+C,IAAT;EAIG;;EAAA,MAACC,IAAY;IAChBzF,iBAAiBC,MACR;MACLyF,UAAU,EADL;MACK,GACPzF;IAFE,CADQA,CADD;IAOhBS,mBAAmBzM,MACV;MACL0R,kBAAkB5R,EAAiB,UAAjBA,EAA6BE,CAA7BF,CADb;MAEL6R,oBAAmB,CAFd;MAGLC,uBAAsB;IAHjB,CADU5R,CAPH;IAchBqG,gBAAgBrG;MACd,IAAI6R,KAAa,CAAjB;MAAA,IACIC,KAAS,CADb;MAEA,OAAO;QACLC,oBAAoB;UAClB,IAAKF,CAAL,EAAKA;YAQL,KAAsC,CAAtC,KAAI7R,EAASoE,OAATpE,CAAiBgS,YAArB,KAAqBA,CAIiB,CAJjBA,KAIjBhS,EAASoE,OAATpE,CAAiBgS,YAJAA,IAIyBhS,EAASoE,OAATpE,CAAiB2R,iBAJ/D,GAIkF;cAChF,IAAIG,CAAJ,EAAY;cACZA,KAAS,CAATA,EAEA9R,EAASiS,MAATjS,CAAgB;gBACdA,EAASkS,aAATlS,IACA8R,KAAS,CADT9R;cACS,CAFXA,CAFA8R;YAIW;UAAA,CAlBb,MACE9R,EAASiS,MAATjS,CAAgB;YACd6R,KAAa,CAAbA;UAAa,CADf7R;QACe,CAJd;QAwBLmS,aAAavS,KAAgD,QAArCI,EAASoE,OAATpE,CAAiB0R,gBAAoB,GAApBA,KAA2B,CAAP,GAAgB1R,EAASoE,OAATpE,CAAiB0R,gBAAjB1R,CAAkCJ,CAAlCI,CAxBxE;QAyBLoS,uBAAuBX;UAAAA,CACL,QAAZA,CAAY,GAAOA,CAAP,GAAOA,CAAYzR,EAASqS,oBAATrS,EADdyR,IAEnBzR,EAASmS,WAATnS,CAASmS,CAAY,CAArBnS,CAFmByR,GAInBzR,EAASmS,WAATnS,CAAqB,EAArBA,CAJmByR;QAIE,CA7BpB;QAgCLS,eAAejC;UACb,IAAIC,CAAJ,EAA2BG,CAA3B;UAEArQ,EAASmS,WAATnS,CAAqBiQ,IAAe,EAAfA,GAAqJ,SAAhIC,IAA4E,SAAnDG,IAAyBrQ,EAASmQ,YAAiB,IAAjBA,KAAwB,CAAP,GAAgBE,EAAuBoB,QAAa,IAAOvB,CAAP,GAA+B,EAAzMlQ;QAAyM,CAnCtM;QAqCLsS,sBAAsB,MACbtS,EAASuS,WAATvS,GAAuBwS,QAAvBxS,CAAgC4B,IAAhC5B,CAAqCyS,KAAOA,EAAIC,YAAJD,EAA5CzS,CAtCJ;QAwCL2S,iCAAiC,MACxBnE;UACQ,QAAbA,EAAEC,OAAW,IAAgBD,EAAEC,OAAFD,EAAhB,EACbxO,EAASoS,qBAATpS,EADa;QACJoS,CA3CR;QA8CLQ,uBAAuB;UACrB,MAAMnB,IAAWzR,EAASyG,QAATzG,GAAoByR,QAArC;UACA,QAAoB,CAApB,KAAOA,CAAP,IAA4BxM,OAAO4N,MAAP5N,CAAcwM,CAAdxM,EAAwBrD,IAAxBqD,CAA6BmC,OAA7BnC,CAA5B;QAAyDmC,CAhDtD;QAkDLiL,sBAAsB;UACpB,MAAMZ,IAAWzR,EAASyG,QAATzG,GAAoByR,QAArC;UAEA,OAAwB,oBAAbA,CAAa,GAAbA,CACW,CADXA,KACFA,CADe,GACfA,EAGJxM,OAAO6N,IAAP7N,CAAYwM,CAAZxM,EAAsBjE,MAHlByQ,IAGkBzQ,CAKvBhB,EAASuS,WAATvS,GAAuBwS,QAAvBxS,CAAgC4B,IAAhC5B,CAAqCyS,KAAOA,EAAIM,aAAJN,EAA5CzS,CATJ;QASoD+S,CA9DjD;QAqELC,kBAAkB;UAChB,IAAIvI,IAAW,CAAf;UAMA,SALgD,CAKhD,KALezK,EAASyG,QAATzG,GAAoByR,QAKnC,GALuDxM,OAAO6N,IAAP7N,CAAYjF,EAASuS,WAATvS,GAAuBiT,QAAnChO,CAKvD,GALsGA,OAAO6N,IAAP7N,CAAYjF,EAASyG,QAATzG,GAAoByR,QAAhCxM,CAKtG,EAJOrE,OAIP,CAJe2C;YACb,MAAM2P,IAAU3P,EAAG4P,KAAH5P,CAAS,GAATA,CAAhB;YACAkH,IAAWvI,KAAKU,GAALV,CAASuI,CAATvI,EAAmBgR,EAAQlS,MAA3BkB,CAAXuI;UAAsCzJ,CAExC,GAAOyJ,CAAP;QAAOA,CA5EJ;QA8EL2I,wBAAwB,MAAMpT,EAASqT,kBAATrT,EA9EzB;QA+ELsT,qBAAqB,QACdtT,EAASuT,oBADK,IACmBvT,EAASoE,OAATpE,CAAiBsT,mBADpC,KAEjBtT,EAASuT,oBAATvT,GAAgCA,EAASoE,OAATpE,CAAiBsT,mBAAjBtT,CAAqCA,CAArCA,CAFf,GAKfA,EAASoE,OAATpE,CAAiBwT,eAAjBxT,IAAiBwT,CAAoBxT,EAASuT,oBAA9CvT,GACKA,EAASoT,sBAATpT,EADLA,GAIGA,EAASuT,oBAATvT,EATY;MA/EhB,CAAP;IAwFoBuT,CAzGN;IA6GhBE,WAAW,CAAChB,CAAD,EAAMzS,CAAN,MACF;MACL0T,gBAAgBjC;QACdzR,EAASmS,WAATnS,CAAqBE;UACnB,IAAIyT,CAAJ;UAEA,MAAMC,KAAiB,CAAjBA,KAAS1T,CAAT0T,IAAS1T,EAAgC,QAAPA,CAAO,IAAPA,CAAeA,EAAIuS,EAAIlP,EAARrD,CAAxCA,CAAf;UACA,IAAI2T,IAAc,EAAlB;UAYA,KAVY,CAUZ,KAVI3T,CAUJ,GATE+E,OAAO6N,IAAP7N,CAAYjF,EAASuS,WAATvS,GAAuBiT,QAAnChO,EAA6CrE,OAA7CqE,CAAqD6O;YACnDD,EAAYC,CAAZD,IAAYC,CAAS,CAArBD;UAAqB,CADvB5O,CASF,GALE4O,IAAc3T,CAKhB,EAFAuR,IAAqC,SAAzBkC,IAAYlC,CAAa,IAAOkC,CAAP,GAAOA,CAAaC,CAEzD,EAFyDA,CAEpDA,CAFoDA,IAE1CnC,CAAf,EACE,OAAO,KAAKoC,CAAL;YACL,CAACpB,EAAIlP,EAAL,GAAKA,CAAK;UADL,CAAP;;UAKF,IAAIqQ,MAAWnC,CAAf,EAAyB;YACvB;cACE,CAACgB,EAAIlP,EAAL,GAAUmK,CADZ;cACYA,GACPC;YAFL,IAGIkG,CAHJ;YAIA,OAAOlG,CAAP;UAGF;;UAAA,OAAOzN,CAAP;QAAOA,CA9BTF;MA8BSE,CAhCN;MAmCL6S,eAAe;QACb,IAAIgB,CAAJ;QAEA,MAAMtC,IAAWzR,EAASyG,QAATzG,GAAoByR,QAArC;QACA,UAAmI,SAAxHsC,IAA6D,QAArC/T,EAASoE,OAATpE,CAAiBgU,gBAAoB,GAApBA,KAA2B,CAAP,GAAgBhU,EAASoE,OAATpE,CAAiBgU,gBAAjBhU,CAAkCyS,CAAlCzS,CAA2C,IAAO+T,CAAP,GAAOA,CAAqC,CAArCA,KAAwBtC,CAAxBsC,KAA0D,QAAZtC,CAAY,GAAZA,KAAmB,CAAP,GAAgBA,EAASgB,EAAIlP,EAAbkO,CAA1EsC,CAA1I;MAAiOxQ,CAvC9N;MAyCLmP,cAAc;QACZ,IAAIuB,CAAJ,EAA4BnG,CAA5B,EAAmDoG,CAAnD;QAEA,QAAgI,SAAvHD,IAA6D,QAApCjU,EAASoE,OAATpE,CAAiBmU,eAAmB,GAAnBA,KAA0B,CAAP,GAAgBnU,EAASoE,OAATpE,CAAiBmU,eAAjBnU,CAAiCyS,CAAjCzS,CAA0C,KAAOiU,CAAvI,MAAwO,SAA7DnG,IAAwB9N,EAASoE,OAATpE,CAAiBoU,eAAoB,KAAOtG,CAA/O,KAA+OA,EAAoE,SAA/BoG,IAAezB,EAAI4B,OAAY,KAAZA,CAAoBH,EAAalT,MAAzF8M,CAA/O;MAAwU9M,CA5CrU;MA8CLsT,0BAA0B;QACxB,MAAMC,IAAY9B,EAAIC,YAAJD,EAAlB;QACA,OAAO;UACA8B,KACL9B,EAAIiB,cAAJjB,EADK8B;QACDb,CAFN;MAEMA;IAlDH,CADE;EA7GK,CAAb;EAAA,MAuKCc,IAAiB,CAAC/B,CAAD,EAAMxL,CAAN,EAAgBwN,CAAhB,KAAgBA;IACrC,MAAMC,IAASD,EAAYE,WAAZF,EAAf;IACA,OAAOhC,EAAImC,QAAJnC,CAAaxL,CAAbwL,EAAuBkC,WAAvBlC,GAAqClL,QAArCkL,CAA8CiC,CAA9CjC,CAAP;EAAqDiC,CAzKlD;;EA4KLF,EAAeK,UAAfL,GAA4BM,KAAOC,EAAWD,CAAXC,CAAnCP;;EAEA,MAAMQ,IAA0B,CAACvC,CAAD,EAAMxL,CAAN,EAAgBwN,CAAhB,KACvBhC,EAAImC,QAAJnC,CAAaxL,CAAbwL,EAAuBlL,QAAvBkL,CAAgCgC,CAAhChC,CADT;;EAIAuC,EAAwBH,UAAxBG,GAAqCF,KAAOC,EAAWD,CAAXC,CAA5CC;;EAEA,MAAMC,IAAe,CAACxC,CAAD,EAAMxL,CAAN,EAAgBwN,CAAhB,KACZhC,EAAImC,QAAJnC,CAAaxL,CAAbwL,EAAuBkC,WAAvBlC,OAAyCgC,EAAYE,WAAZF,EADlD;;EAIAQ,EAAaJ,UAAbI,GAA0BH,KAAOC,EAAWD,CAAXC,CAAjCE;;EAEA,MAAMC,IAAc,CAACzC,CAAD,EAAMxL,CAAN,EAAgBwN,CAAhB,KACXhC,EAAImC,QAAJnC,CAAaxL,CAAbwL,EAAuBlL,QAAvBkL,CAAgCgC,CAAhChC,CADT;;EAIAyC,EAAYL,UAAZK,GAAyBJ,KAAOC,EAAWD,CAAXC,KAAWD,EAAiB,QAAPA,CAAO,IAAQA,EAAI9T,MAA7B8T,CAA3CI;;EAEA,MAAMC,IAAiB,CAAC1C,CAAD,EAAMxL,CAAN,EAAgBwN,CAAhB,KAAgBA,CAC7BA,EAAY7S,IAAZ6S,CAAiBK,MAAQrC,EAAImC,QAAJnC,CAAaxL,CAAbwL,EAAuBlL,QAAvBkL,CAAgCqC,CAAhCrC,CAAzBgC,CADV;;EAIAU,EAAeN,UAAfM,GAA4BL,KAAOC,EAAWD,CAAXC,KAAWD,EAAiB,QAAPA,CAAO,IAAQA,EAAI9T,MAA7B8T,CAA9CK;;EAEA,MAAMC,IAAkB,CAAC3C,CAAD,EAAMxL,CAAN,EAAgBwN,CAAhB,KACfA,EAAY7S,IAAZ6S,CAAiBK,KAAOrC,EAAImC,QAAJnC,CAAaxL,CAAbwL,EAAuBlL,QAAvBkL,CAAgCqC,CAAhCrC,CAAxBgC,CADT;;EAIAW,EAAgBP,UAAhBO,GAA6BN,KAAOC,EAAWD,CAAXC,KAAWD,EAAiB,QAAPA,CAAO,IAAQA,EAAI9T,MAA7B8T,CAA/CM;;EAEA,MAAMC,IAAS,CAAC5C,CAAD,EAAMxL,CAAN,EAAgBwN,CAAhB,KACNhC,EAAImC,QAAJnC,CAAaxL,CAAbwL,MAA2BgC,CADpC;;EAIAY,EAAOR,UAAPQ,GAAoBP,KAAOC,EAAWD,CAAXC,CAA3BM;;EAEA,MAAMC,IAAa,CAAC7C,CAAD,EAAMxL,CAAN,EAAgBwN,CAAhB,KACVhC,EAAImC,QAAJnC,CAAaxL,CAAbwL,KAA0BgC,CADnC;;EAIAa,EAAWT,UAAXS,GAAwBR,KAAOC,EAAWD,CAAXC,CAA/BO;;EAEA,MAAMC,IAAgB,CAAC9C,CAAD,EAAMxL,CAAN,EAAgBwN,CAAhB,KAAgBA;IACpC,KAAK5R,CAAL,EAAUD,CAAV,IAAiB6R,CAAjB;IACA,MAAMe,IAAW/C,EAAImC,QAAJnC,CAAaxL,CAAbwL,CAAjB;IACA,OAAO+C,KAAY3S,CAAZ2S,IAAmBA,KAAY5S,CAAtC;EAAsCA,CAHxC;;EAMA2S,EAAcE,kBAAdF,GAAmCT;IACjC,KAAKY,CAAL,EAAgBC,CAAhB,IAA6Bb,CAA7B;IAAA,IACIc,IAAiC,mBAAdF,CAAc,GAAWG,WAAWH,CAAXG,CAAX,GAAmCH,CADxE;IAAA,IAEII,IAAiC,mBAAdH,CAAc,GAAWE,WAAWF,CAAXE,CAAX,GAAmCF,CAFxE;IAAA,IAGI9S,IAAoB,SAAd6S,CAAc,IAAQ/J,OAAOoK,KAAPpK,CAAaiK,CAAbjK,CAAR,GAAqBiK,CAAcI,CAAdJ,GAAcI,CAAnC,GAA8CJ,CAHtE;IAAA,IAIIhT,IAAoB,SAAd+S,CAAc,IAAQhK,OAAOoK,KAAPpK,CAAamK,CAAbnK,CAAR,GAAkCqK,KAAlC,GAA6CF,CAJrE;;IAMA,IAAIjT,IAAMD,CAAV,EAAe;MACb,MAAMqT,IAAOpT,CAAb;MACAA,IAAMD,CAANC,EACAD,IAAMqT,CADNpT;IAIF;;IAAA,OAAO,CAACA,CAAD,EAAMD,CAAN,CAAP;EAAaA,CAbf2S,EAgBAA,EAAcV,UAAdU,GAA2BT,KAAOC,EAAWD,CAAXC,KAAmBA,EAAWD,EAAI,CAAJA,CAAXC,KAAsBA,EAAWD,EAAI,CAAJA,CAAXC,CAhB3EQ;EAmBK,MAACW,IAAY;IAChB1B,iBADgB;IAEhBQ,0BAFgB;IAGhBC,eAHgB;IAIhBC,cAJgB;IAKhBC,iBALgB;IAMhBC,kBANgB;IAOhBC,SAPgB;IAQhBC,aARgB;IAShBC;EATgB,CAAb;;EAaL,SAASR,CAAT,CAAoBD,CAApB,EAAoBA;IAClB,OAAOA,aAA6C,OAARA,CAA5C;EAIG;;EAAA,MAACqB,IAAU;IACdrK,qBAAqB,OACZ;MACLsK,UAAU;IADL,CADY,CADP;IAMdrK,iBAAiBC,MACR;MACLqK,eAAe,EADV;MAELC,mBAAc5S,CAFT;MAESA,GAGXsI;IALE,CADQA,CANH;IAedS,mBAAmBzM,MACV;MACLuW,uBAAuBzW,EAAiB,eAAjBA,EAAkCE,CAAlCF,CADlB;MAEL0W,sBAAsB1W,EAAiB,cAAjBA,EAAiCE,CAAjCF,CAFjB;MAGL2W,qBAAoB,CAHf;MAILC,gBAAgB,MAJX;MAKLC,0BAA0B9S;QACxB,IAAI+S,CAAJ,EAA2BC,CAA3B;QAGA,OAAwB,oBAD0D,SAAnED,IAAwB5W,EAAS8W,eAAT9W,GAA2BwS,QAA3BxS,CAAoC,CAApCA,CAA2C,KAAwG,SAAvF6W,IAAyBD,EAAsBG,sBAAtBH,GAA+C/S,EAAON,EAAtDqT,CAA8D,CAAxG,GAAgGrT,KAAzF,CAAP,GAAwHsT,EAAuBjC,QAAvBiC,EAClL,CAAxB;MADiOjC;IAR9N,CADU5U,CAfL;IA6Bd8C,cAAc,CAACe,CAAD,EAAS7D,CAAT,MACL;MACLgX,iBAAiB;QACf,MAAMC,IAAWjX,EAAS8W,eAAT9W,GAA2BwS,QAA3BxS,CAAoC,CAApCA,CAAjB;QAAA,MACMkX,IAAoB,QAAZD,CAAY,GAAZA,KAAmB,CAAP,GAAgBA,EAASrC,QAATqC,CAAkBpT,EAAON,EAAzB0T,CAD1C;QAGA,OAAqB,mBAAVC,CAAU,GACZhB,EAAU1B,cADE,GAIA,mBAAV0C,CAAU,GACZhB,EAAUX,aADE,GAIA,oBAAV2B,CAAU,IAIP,SAAVA,CAAU,IAAyB,mBAAVA,CAJR,GACZhB,EAAUb,MADE,GAQjB8B,MAAMC,OAAND,CAAcD,CAAdC,IACKjB,EAAUhB,WADfiC,GAIGjB,EAAUZ,UApBjB;MAoBiBA,CAzBd;MA2BL+B,aAAa;QACX,IAAInU,CAAJ;QAEA,MAAMoU,IAAgBtX,EAASoE,OAATpE,CAAiBkW,SAAvC;QACA,OAAO/V,EAAW0D,EAAOd,SAAPc,CAAiBuS,QAA5BjW,IAAwC0D,EAAOd,SAAPc,CAAiBuS,QAAzDjW,GAAkG,WAA9B0D,EAAOd,SAAPc,CAAiBuS,QAAa,GAASvS,EAAOmT,eAAPnT,EAAT,GAA0H,SAArFX,IAAwB,QAAjBoU,CAAiB,GAAjBA,KAAwB,CAAP,GAAgBA,EAAczT,EAAOd,SAAPc,CAAiBuS,QAA/BkB,CAA6C,IAAOpU,CAAP,GAAcgT,EAAUrS,EAAOd,SAAPc,CAAiBuS,QAA3BF,CAAjP;MAA4QE,CA/BzQ;MAiCLmB,cAAc;QACZ,IAAI1J,CAAJ,EAA2BC,CAA3B,EAAkD0J,CAAlD;QAEA,QAAyE,SAAhE3J,IAAwBhK,EAAOd,SAAPc,CAAiB4T,kBAAuB,KAAO5J,CAAhF,MAAoL,SAAjEC,IAAwB9N,EAASoE,OAATpE,CAAiB0X,mBAAwB,KAAO5J,CAA3L,MAA0R,SAA5D0J,IAAyBxX,EAASoE,OAATpE,CAAiB2X,aAAkB,KAAOH,CAAjS,KAAiSA,EAAoC3T,EAAOP,UAA5U;MAA4UA,CApCzU;MAsCLsU,oBAAoB;QAClB,IAAIC,CAAJ,EAA4BC,CAA5B,EAAoDC,CAApD,EAA4EhE,CAA5E;QAEA,QAA0E,SAAjE8D,IAAyBhU,EAAOd,SAAPc,CAAiBmU,kBAAuB,KAAOH,CAAjF,MAAsL,SAAjEC,IAAyB9X,EAASoE,OAATpE,CAAiBgY,kBAAuB,KAAOF,CAA7L,MAA6R,SAA5DC,IAAyB/X,EAASoE,OAATpE,CAAiB2X,aAAkB,KAAOI,CAApS,MAAmd,SAA3IhE,IAAqE,QAA7C/T,EAASoE,OAATpE,CAAiB2W,wBAA4B,GAA5BA,KAAmC,CAAP,GAAgB3W,EAASoE,OAATpE,CAAiB2W,wBAAjB3W,CAA0C6D,CAA1C7D,CAAsD,KAAO+T,CAA1d,KAA0dA,EAAmClQ,EAAOP,UAApgB;MAAogBA,CAzCjgB;MA2CL2U,eAAe,MAAMpU,EAAOqU,cAAPrU,KAAOqU,CAAoB,CA3C3C;MA4CLC,gBAAgB;QACd,IAAIC,CAAJ,EAA2BC,CAA3B;QAEA,OAAsE,SAA9DD,IAAwBpY,EAASyG,QAATzG,GAAoBqW,aAAkB,KAAkG,SAAjFgC,IAAyBD,EAAsBlR,IAAtBkR,CAA2BhY,KAAKA,EAAEmD,EAAFnD,KAASyD,EAAON,EAAhD6U,CAAwD,CAAlG,GAA0F7U,KAAnF,CAAP,GAAkH8U,EAAuBnB,KAA/M;MAA+MA,CA/C5M;MAiDLgB,gBAAgB;QACd,IAAII,CAAJ,EAA4BC,CAA5B;QAEA,OAA+K,SAAvKD,IAAyF,SAA/DC,IAAyBvY,EAASyG,QAATzG,GAAoBqW,aAAkB,IAAlBA,KAAyB,CAAP,GAAgBkC,EAAuBlL,SAAvBkL,CAAiCnY,KAAKA,EAAEmD,EAAFnD,KAASyD,EAAON,EAAtDgV,CAA8D,IAAOD,CAAP,GAAOA,CAA0B,CAAhN;MAAgN,CApD7M;MAsDLE,gBAAgBtB;QACdlX,EAASyY,gBAATzY,CAA0BE;UACxB,MAAMkW,IAAWvS,EAAOwT,WAAPxT,EAAjB;UAAA,MACM6U,IAAwB,QAAPxY,CAAO,GAAPA,KAAc,CAAP,GAAgBA,EAAIgH,IAAJhH,CAASE,KAAKA,EAAEmD,EAAFnD,KAASyD,EAAON,EAA9BrD,CAD9C;UAAA,MAEMyY,IAAYhZ,EAAiBuX,CAAjBvX,EAAwB+Y,IAAiBA,EAAexB,KAAhCwB,GAAgCxB,KAAQxT,CAAhE/D,CAFlB;UAKE,IAAIiZ,CAAJ;UADF,IAAIC,EAAuBzC,CAAvByC,EAAiCF,CAAjCE,EAA4ChV,CAA5CgV,CAAJ,EAGE,OAAqF,SAA7ED,IAAqB,QAAP1Y,CAAO,GAAPA,KAAc,CAAP,GAAgBA,EAAIiH,MAAJjH,CAAWE,KAAKA,EAAEmD,EAAFnD,KAASyD,EAAON,EAAhCrD,CAAwC,IAAO0Y,CAAP,GAAqB,EAA1G;UAGF,MAAME,IAAe;YACnBvV,IAAIM,EAAON,EADQ;YAEnB2T,OAAOyB;UAFY,CAArB;UAME,IAAII,CAAJ;UADF,OAAIL,IASK,SANCK,IAAkB,QAAP7Y,CAAO,GAAPA,KAAc,CAAP,GAAgBA,EAAI6F,GAAJ7F,CAAQE,KAC5CA,EAAEmD,EAAFnD,KAASyD,EAAON,EAAhBnD,GACK0Y,CADL1Y,GAIGA,CALiCF,CAMnC,IAAO6Y,CAAP,GAAkB,EATvBL,GAYO,QAAPxY,CAAO,IAAQA,EAAIc,MAAZ,GACF,IAAId,CAAJ,EAAS4Y,CAAT,CADE,GAIJ,CAACA,CAAD,CAhBP;QAgBQA,CAhCV9Y;MAgCU8Y,CAvFP;MA0FLE,qBAAqBhZ,EAASoE,OAATpE,CAAiBiZ,kBAAjBjZ,IAAuCA,EAASoE,OAATpE,CAAiBiZ,kBAAjBjZ,CAAoCA,CAApCA,EAA8C6D,EAAON,EAArDvD,CA1FvD;MA2FLiZ,oBAAoB,MACbpV,EAAOmV,mBAAPnV,GAIEA,EAAOmV,mBAAPnV,EAJFA,GACI7D,EAASkZ,sBAATlZ,EA7FN;MAkGLmZ,yBAAyBnZ,EAASoE,OAATpE,CAAiBoZ,sBAAjBpZ,IAA2CA,EAASoE,OAATpE,CAAiBoZ,sBAAjBpZ,CAAwCA,CAAxCA,EAAkD6D,EAAON,EAAzDvD,CAlG/D;MAmGLoZ,wBAAwB,MACjBvV,EAAOsV,uBAAPtV,GAIEA,EAAOsV,uBAAPtV,EAJFA,GACI,IAAIwV,GAAJ,EArGN;MA0GLC,yBAAyBtZ,EAASoE,OAATpE,CAAiBuZ,sBAAjBvZ,IAA2CA,EAASoE,OAATpE,CAAiBuZ,sBAAjBvZ,CAAwCA,CAAxCA,EAAkD6D,EAAON,EAAzDvD,CA1G/D;MA2GLuZ,wBAAwB;QACtB,IAAK1V,EAAOyV,uBAAZ,EAIA,OAAOzV,EAAOyV,uBAAPzV,EAAP;MAAcyV;IAhHX,CADK,CA7BA;IAoJd7F,WAAW,CAAChB,CAAD,EAAMzS,CAAN,MACF;MACLqW,eAAe,EADV;MAELmD,mBAAmB;IAFd,CADE,CApJG;IA0JdnT,gBAAgBrG,MACP;MACLyZ,uBAAuB,MACdvD,EAAU1B,cAFd;MAILkF,mBAAmB;QACjB,IAAIjM,CAAJ;QAEA;UACEyI,WAAWoB,CADb;UAEEZ,gBAAgBA;QAFlB,IAGI1W,EAASoE,OAHb;QAIA,OAAOjE,EAAWuW,CAAXvW,IAA6BuW,CAA7BvW,GAAiE,WAAnBuW,CAAmB,GAAS1W,EAASyZ,qBAATzZ,EAAT,GAAwH,SAA3EyN,IAAyB,QAAjB6J,CAAiB,GAAjBA,KAAwB,CAAP,GAAgBA,EAAcZ,CAAdY,CAAkC,IAAO7J,CAAP,GAAeyI,EAAUQ,CAAVR,CAA/M;MAAyNQ,CAXtN;MAaL+B,kBAAkB7Y;QAChB,MAAM+E,IAAc3E,EAAS2Z,iBAAT3Z,EAApB;QAoB0C,QAA1CA,EAASoE,OAATpE,CAAiBuW,qBAAyB,IAAgBvW,EAASoE,OAATpE,CAAiBuW,qBAAjBvW,CAlBzCE;UACf,IAAI0Z,CAAJ;UAEA,OAA+D,SAAvDA,IAAoBja,EAAiBC,CAAjBD,EAA0BO,CAA1BP,CAAmC,IAATO,KAAgB,CAAP,GAAgB0Z,EAAkBzS,MAAlByS,CAAyBzS;YACtG,MAAMtD,IAASc,EAAYuC,IAAZvC,CAAiBvE,KAAKA,EAAEmD,EAAFnD,KAAS+G,EAAO5D,EAAtCoB,CAAf;;YAEA,IAAId,CAAJ,EAAY;cAGV,IAAIgV,EAFahV,EAAOwT,WAAPxT,EAEbgV,EAAiC1R,EAAO+P,KAAxC2B,EAA+ChV,CAA/CgV,CAAJ,EACE,QAAO,CAAP;YAIJ;;YAAA,QAAO,CAAP;UAAO,CAXsEe,CAA/E;QAWS,CAI+C5Z,CAAhB;MAJ/B,CA9BR;MAoCL6Z,iBAAiBja;QAC0B,QAAzCI,EAASoE,OAATpE,CAAiBwW,oBAAwB,IAAgBxW,EAASoE,OAATpE,CAAiBwW,oBAAjBxW,CAAsCJ,CAAtCI,CAAhB;MAAsDJ,CArC5F;MAuCLka,mBAAmB7J;QACjBjQ,EAAS6Z,eAAT7Z,CAAyBiQ,SAAevM,CAAfuM,GAA2BjQ,EAASmQ,YAATnQ,CAAsBsW,YAA1EtW;MAA0EsW,CAxCvE;MA0CLyD,oBAAoB9J;QAClB,IAAIC,CAAJ,EAA2BG,CAA3B;QAEArQ,EAASyY,gBAATzY,CAA0BiQ,IAAe,EAAfA,GAA0J,SAArIC,IAA4E,SAAnDG,IAAyBrQ,EAASmQ,YAAiB,IAAjBA,KAAwB,CAAP,GAAgBE,EAAuBgG,aAAkB,IAAOnG,CAAP,GAA+B,EAAnNlQ;MAAmN,CA7ChN;MA+CLkZ,wBAAwB,MAAMlZ,EAAS8W,eAAT9W,EA/CzB;MAgDLga,sBAAsBha,EAASoE,OAATpE,CAAiBia,mBAAjBja,IAAwCA,EAASoE,OAATpE,CAAiBia,mBAAjBja,CAAqCA,CAArCA,CAhDzD;MAiDLia,qBAAqB,MACfja,EAASoE,OAATpE,CAAiBka,eAAjBla,IAAiBka,CAAoBla,EAASga,oBAA9Cha,GACKA,EAASkZ,sBAATlZ,EADLA,GAIGA,EAASga,oBAATha,EAtDJ;MAwDLma,2BAA2Bna,EAASoE,OAATpE,CAAiBiZ,kBAAjBjZ,IAAuCA,EAASoE,OAATpE,CAAiBiZ,kBAAjBjZ,CAAoCA,CAApCA,EAA8C,YAA9CA,CAxD7D;MAyDLoa,0BAA0B,MACpBpa,EAASoE,OAATpE,CAAiBka,eAAjBla,IAAiBka,CAAoBla,EAASma,yBAA9Cna,GACKA,EAASkZ,sBAATlZ,EADLA,GAIGA,EAASma,yBAATna,EA9DJ;MAgELqa,+BAA+Bra,EAASoE,OAATpE,CAAiBoZ,sBAAjBpZ,IAA2CA,EAASoE,OAATpE,CAAiBoZ,sBAAjBpZ,CAAwCA,CAAxCA,EAAkD,YAAlDA,CAhErE;MAiELsa,8BAA8B,MACvBta,EAASqa,6BAATra,GAIEA,EAASqa,6BAATra,EAJFA,GACI,IAAIqZ,GAAJ,EAnEN;MAwELkB,+BAA+Bva,EAASoE,OAATpE,CAAiBuZ,sBAAjBvZ,IAA2CA,EAASoE,OAATpE,CAAiBuZ,sBAAjBvZ,CAAwCA,CAAxCA,EAAkD,YAAlDA,CAxErE;MAyELwa,8BAA8B;QAC5B,IAAKxa,EAASua,6BAAd,EAIA,OAAOva,EAASua,6BAATva,EAAP;MAAgBua;IA9Eb,CADOva;EA1JF,CAAX;;EA8OL,SAAS6Y,CAAT,CAAgCzC,CAAhC,EAA0Cc,CAA1C,EAAiDrT,CAAjD,EAAiDA;IAC/C,UAAQuS,CAAR,IAAQA,CAAYA,EAASvB,UAA7B,KAA0CuB,EAASvB,UAATuB,CAAoBc,CAApBd,EAA2BvS,CAA3BuS,CAA1C,IAAqEvS,KAAqC,CAArCA,KAA2BqT,CAAhG,IAA0I,mBAAVA,CAAU,IAAVA,CAAuBA,CAAvJ;EAGF;;EAAA,MA4FMuD,IAAiB;IACrBvM,KA7FU,CAACjH,CAAD,EAAWyT,CAAX,EAAsBC,CAAtB,KAGHA,EAAU7V,MAAV6V,CAAiB,CAACzM,CAAD,EAAM0M,CAAN,KAAe1M,KAAuB,mBAAT0M,CAAS,GAAWA,CAAX,GAAkB,CAAzC1M,CAAhCyM,EAA6E,CAA7EA,CAyFc;IAErB9X,KAxFU,CAACoE,CAAD,EAAWyT,CAAX,EAAsBC,CAAtB,KAAsBA;MAChC,IAAI9X,CAAJ;MAQA,OAPA8X,EAAU/Z,OAAV+Z,CAAkBlI;QAChB,MAAMyE,IAAQzE,EAAImC,QAAJnC,CAAaxL,CAAbwL,CAAd;QAEa,QAATyE,CAAS,KAASrU,IAAMqU,CAANrU,IAAMqU,KAAiBxT,CAAjBwT,KAASrU,CAATqU,IAA8BA,KAASA,CAAtD,MACXrU,IAAMqU,CADK;MACLA,CAJVyD,GAOO9X,CAAP;IAAOA,CA6Ec;IAGrBD,KA7EU,CAACqE,CAAD,EAAWyT,CAAX,EAAsBC,CAAtB,KAAsBA;MAChC,IAAI/X,CAAJ;MAQA,OAPA+X,EAAU/Z,OAAV+Z,CAAkBlI;QAChB,MAAMyE,IAAQzE,EAAImC,QAAJnC,CAAaxL,CAAbwL,CAAd;QAEa,QAATyE,CAAS,KAAStU,IAAMsU,CAANtU,IAAMsU,KAAiBxT,CAAjBwT,KAAStU,CAATsU,IAA8BA,KAASA,CAAtD,MACXtU,IAAMsU,CADK;MACLA,CAJVyD,GAOO/X,CAAP;IAAOA,CAiEc;IAIrBiY,QAlEa,CAAC5T,CAAD,EAAWyT,CAAX,EAAsBC,CAAtB,KAAsBA;MACnC,IAAI9X,CAAJ,EACID,CADJ;MAcA,OAZA+X,EAAU/Z,OAAV+Z,CAAkBlI;QAChB,MAAMyE,IAAQzE,EAAImC,QAAJnC,CAAaxL,CAAbwL,CAAd;QAEa,QAATyE,CAAS,KAATA,KACUxT,CADVwT,KACErU,CADFqU,GAEIA,KAASA,CAATA,KAAgBrU,IAAMD,IAAMsU,CAA5BA,CAFJA,IAIIrU,IAAMqU,CAANrU,KAAaA,IAAMqU,CAAnBrU,GACAD,IAAMsU,CAANtU,KAAaA,IAAMsU,CAAnBtU,CALJsU,CAAS;MAKcA,CAR7ByD,GAYO,CAAC9X,CAAD,EAAMD,CAAN,CAAP;IAAaA,CA+CQ;IAKrBkY,MAjDW,CAAC7T,CAAD,EAAW8T,CAAX,KAAWA;MACtB,IAAIC,IAAQ,CAAZ;MAAA,IACI9M,IAAM,CADV;MASA,IAPA6M,EAASna,OAATma,CAAiBtI;QACf,IAAIyE,IAAQzE,EAAImC,QAAJnC,CAAaxL,CAAbwL,CAAZ;QAEa,QAATyE,CAAS,IAATA,CAAkBA,KAASA,CAA3BA,KAAqCA,CAA5B,KAA4BA,EACrC8D,CADqC9D,EAC9BhJ,KAAOgJ,CADL;MACKA,CAJpB6D,GAOIC,CAAJ,EAAW,OAAO9M,IAAM8M,CAAb;IAAaA,CAkCH;IAMrBC,QApCa,CAAChU,CAAD,EAAW8T,CAAX,KAAWA;MACxB,KAAKA,EAAS/Z,MAAd,EACE;MAGF,IAAI6B,IAAM,CAAV;MAAA,IACID,IAAM,CADV;MAUA,OARAmY,EAASna,OAATma,CAAiBtI;QACf,IAAIyE,IAAQzE,EAAImC,QAAJnC,CAAaxL,CAAbwL,CAAZ;QAEqB,mBAAVyE,CAAU,KACnBrU,IAAMX,KAAKW,GAALX,CAASW,CAATX,EAAcgV,CAAdhV,CAANW,EACAD,IAAMV,KAAKU,GAALV,CAASU,CAATV,EAAcgV,CAAdhV,CAFa;MAECgV,CALxB6D,GAKwB7D,CAGhBrU,IAAMD,CAHUsU,IAGH,CAArB;IAAqB,CAeA;IAOrBgE,QAnBa,CAACjU,CAAD,EAAW8T,CAAX,KACN5D,MAAMgE,IAANhE,CAAW,IAAIiE,GAAJ,CAAQL,EAAShV,GAATgV,CAAa3a,KAAKA,EAAEwU,QAAFxU,CAAW6G,CAAX7G,CAAlB2a,CAAR,EAAiDlI,MAAjD,EAAXsE,CAWc;IAQrBkE,aAhBkB,CAACpU,CAAD,EAAW8T,CAAX,KACX,IAAIK,GAAJ,CAAQL,EAAShV,GAATgV,CAAa3a,KAAKA,EAAEwU,QAAFxU,CAAW6G,CAAX7G,CAAlB2a,CAAR,EAAiDvP,IAOnC;IASrBwP,OAbY,CAACM,CAAD,EAAYP,CAAZ,KACLA,EAAS/Z;EAGK,CA5FvB;EAAA,MAyGMua,IAAW;IACfzP,qBAAqB,OACZ;MACL0P,gBAAgBC;QACd,IAAIC,CAAJ,EAA2BC,CAA3B;QAEA,OAAmK,SAA3JD,IAAgE,SAAvCC,IAAkBF,EAAM7G,QAAN6G,EAAqB,KAA4C,QAA5BE,EAAgBC,QAAhC,GAAgCA,KAAzB,CAAP,GAA4DD,EAAgBC,QAAhBD,EAA+B,IAAOD,CAAP,GAA+B,IAAlM;MAAkM,CAJ/L;MAMLG,eAAe;IANV,CADY,CADN;IAWf9P,iBAAiBC,MACR;MACL8P,UAAU,EADL;MACK,GACP9P;IAFE,CADQA,CAXF;IAiBfS,mBAAmBzM,MACV;MACL+b,kBAAkBjc,EAAiB,UAAjBA,EAA6BE,CAA7BF,CADb;MAELkc,mBAAmB;IAFd,CADUhc,CAjBJ;IAuBf8C,cAAc,CAACe,CAAD,EAAS7D,CAAT,MACL;MACLic,gBAAgB;QACdjc,EAASkc,WAATlc,CAAqBE,KAER,QAAPA,CAAO,IAAQA,EAAIqH,QAAJrH,CAAa2D,EAAON,EAApBrD,CAAR,GACFA,EAAIiH,MAAJjH,CAAWE,KAAKA,MAAMyD,EAAON,EAA7BrD,CADE,GAIJ,KAAY,QAAPA,CAAO,GAAOA,CAAP,GAAa,EAAzB,GAA8B2D,EAAON,EAArC,CANTvD;MAM8CuD,CAR3C;MAWL4Y,aAAa;QACX,IAAIjZ,CAAJ,EAAUuK,CAAV,EAAiB2B,CAAjB,EAAwBvB,CAAxB;QAEA,OAAiN,SAAzM3K,IAAiL,SAAzKuK,IAAsH,SAA7G2B,IAAqE,SAA5DvB,IAAwBhK,EAAOd,SAAPc,CAAiBuY,cAAmB,KAAOvO,CAAiC,IAAOuB,CAAP,GAAepP,EAASoE,OAATpE,CAAiBoc,cAAmB,KAAO3O,CAAiB,IAAOvK,CAAP,GAAOA,EAASW,EAAOP,UAAxO;MAAwOA,CAdrO;MAgBL+Y,cAAc;QACZ,IAAIC,CAAJ;QAEA,OAAiE,SAAzDA,IAAwBtc,EAASyG,QAATzG,GAAoB8b,QAAa,IAAbA,KAAoB,CAAP,GAAgBQ,EAAsB/U,QAAtB+U,CAA+BzY,EAAON,EAAtC+Y,CAAjF;MAAuH/Y,CAnBpH;MAqBLgZ,iBAAiB;QACf,IAAIC,CAAJ;QAEA,OAAkE,SAA1DA,IAAyBxc,EAASyG,QAATzG,GAAoB8b,QAAa,IAAbA,KAAoB,CAAP,GAAgBU,EAAuBC,OAAvBD,CAA+B3Y,EAAON,EAAtCiZ,CAAlF;MAAwHjZ,CAxBrH;MA0BLmZ,0BAA0B;QACxB,MAAMC,IAAW9Y,EAAOsY,WAAPtY,EAAjB;QACA,OAAO;UACA8Y,KACL9Y,EAAOoY,cAAPpY,EADK8Y;QACEV,CAFT;MAESA,CA9BN;MAiCLW,sBAAsB;QACpB,MAAM3F,IAAWjX,EAAS8W,eAAT9W,GAA2BwS,QAA3BxS,CAAoC,CAApCA,CAAjB;QAAA,MACMkX,IAAoB,QAAZD,CAAY,GAAZA,KAAmB,CAAP,GAAgBA,EAASrC,QAATqC,CAAkBpT,EAAON,EAAzB0T,CAD1C;QAGA,OAAqB,mBAAVC,CAAU,GACZuD,EAAevM,GADH,GAIyB,oBAA1CjJ,OAAO4X,SAAP5X,CAAiB2W,QAAjB3W,CAA0B6X,IAA1B7X,CAA+BiS,CAA/BjS,CAA0C,GACrCwV,EAAeI,MADsB,GACtBA,KADxB,CAJA;MAIA,CAzCG;MA6CLkC,kBAAkB;QAChB,IAAIC,CAAJ;QAEA,MAAMC,IAAqBjd,EAASoE,OAATpE,CAAiBya,cAA5C;QAEA,KAAK5W,CAAL,EACE,MAAM,IAAID,KAAJ,EAAN;QAGF,OAAOzD,EAAW0D,EAAOd,SAAPc,CAAiBgY,aAA5B1b,IAA6C0D,EAAOd,SAAPc,CAAiBgY,aAA9D1b,GAAiH,WAAnC0D,EAAOd,SAAPc,CAAiBgY,aAAkB,GAAShY,EAAO+Y,oBAAP/Y,EAAT,GAA+I,SAArGmZ,IAA8B,QAAtBC,CAAsB,GAAtBA,KAA6B,CAAP,GAAgBA,EAAmBpZ,EAAOd,SAAPc,CAAiBgY,aAApCoB,CAAuD,IAAOD,CAAP,GAAevC,EAAe5W,EAAOd,SAAPc,CAAiBgY,aAAhCpB,CAAtR;MAAsToB;IAtDnT,CADK,CAvBC;IAkFfxV,gBAAgBrG,MACP;MACLkc,aAAatc,KAAgD,QAArCI,EAASoE,OAATpE,CAAiB+b,gBAAoB,GAApBA,KAA2B,CAAP,GAAgB/b,EAASoE,OAATpE,CAAiB+b,gBAAjB/b,CAAkCJ,CAAlCI,CADxE;MAELkd,eAAejN;QACb,IAAIC,CAAJ,EAA2BG,CAA3B;QAEArQ,EAASkc,WAATlc,CAAqBiQ,IAAe,EAAfA,GAAqJ,SAAhIC,IAA4E,SAAnDG,IAAyBrQ,EAASmQ,YAAiB,IAAjBA,KAAwB,CAAP,GAAgBE,EAAuByL,QAAa,IAAO5L,CAAP,GAA+B,EAAzMlQ;MAAyM,CALtM;MAOLmd,uBAAuB,MAAMnd,EAASod,iBAATpd,EAPxB;MAQLqT,oBAAoB,QACbrT,EAASqd,mBADI,IACmBrd,EAASoE,OAATpE,CAAiBqT,kBADpC,KAEhBrT,EAASqd,mBAATrd,GAA+BA,EAASoE,OAATpE,CAAiBqT,kBAAjBrT,CAAoCA,CAApCA,CAFf,GAKdA,EAASoE,OAATpE,CAAiBsd,cAAjBtd,IAAiBsd,CAAmBtd,EAASqd,mBAA7Crd,GACKA,EAASmd,qBAATnd,EADLA,GAIGA,EAASqd,mBAATrd,EATW;IARf,CADOA,CAlFD;IAwGfyT,WAAWhB,MACF;MACL4J,cAAc,QAAQ5J,EAAI8K,gBADrB;MAELC,sBAAsB;IAFjB,CADE/K,CAxGI;IA8GfgL,YAAY,CAACC,CAAD,EAAO7Z,CAAP,EAAe4O,CAAf,EAAoBzS,CAApB,MACH;MACLqc,cAAc,MAAMxY,EAAOwY,YAAPxY,MAAyBA,EAAON,EAAPM,KAAc4O,EAAI8K,gBAD1D;MAELI,kBAAkB,OAAOD,EAAKrB,YAALqB,EAAP,IAA8B7Z,EAAOwY,YAAPxY,EAF3C;MAGL+Z,iBAAiB;QACf,IAAI1J,CAAJ;QAEA,QAAQwJ,EAAKrB,YAALqB,EAAR,IAAarB,CAAmBqB,EAAKC,gBAALD,EAAhC,IAAqCC,CAAuD,SAA/BzJ,IAAezB,EAAI4B,OAAY,IAAZA,KAAmB,CAAP,GAAgBH,EAAalT,MAApF2c,IAA8F,CAAnI;MAAmI,CANhI;MAQLE,sBAAsB;QACpB,IAAIC,CAAJ;QAEA,MAAMC,IAAwE,SAA5DD,IAAwBja,EAAOd,SAAPc,CAAiB2X,cAAmB,IAAOsC,CAAP,GAA+Bja,EAAOd,SAAPc,CAAiB6Z,IAA9H;QACA,OAAOK,IAAW/d,EAASiG,OAATjG,CAAiB+d,CAAjB/d,EAA2B;UAC3CA,WAD2C;UAE3C6D,SAF2C;UAG3C4O,MAH2C;UAI3CiL,OAJ2C;UAK3C9I,UAAU8I,EAAK9I;QAL4B,CAA3B5U,CAAX+d,GAMF,IANL;MAMK;IAlBF,CADG;EA9GG,CAzGjB;;EA+OA,SAAStZ,CAAT,CAAsBE,CAAtB,EAAmCmX,CAAnC,EAA6CE,CAA7C,EAA6CA;IAC3C,IAAkB,QAAZF,CAAY,IAAZA,CAAoBA,EAAS9a,MAAjB,IAAiBA,CAAYgb,CAA/C,EACE,OAAOrX,CAAP;IAGF,MAAMqZ,IAAqBrZ,EAAYwC,MAAZxC,CAAmBsZ,MAAQnC,EAASvU,QAATuU,CAAkBmC,EAAI1a,EAAtBuY,CAA3BnX,CAA3B;IAEA,IAA0B,aAAtBqX,CAAJ,EACE,OAAOgC,CAAP;IAIF,OAAO,IADiBlC,EAAS/V,GAAT+V,CAAaoC,KAAKvZ,EAAYuC,IAAZvC,CAAiBsZ,KAAOA,EAAI1a,EAAJ0a,KAAWC,CAAnCvZ,CAAlBmX,EAAyD3U,MAAzD2U,CAAgE1U,OAAhE0U,CACjB,EADiF1U,GACzD4W,CAAxB,CAAP;EAIG;;EAAA,MAACG,IAAW;IACfpS,iBAAiBC,MACR;MACLoS,aAAa,EADR;MACQ,GACVpS;IAFE,CADQA,CADF;IAOfS,mBAAmBzM,MACV;MACLqe,qBAAqBve,EAAiB,aAAjBA,EAAgCE,CAAhCF;IADhB,CADUE,CAPJ;IAYfqG,gBAAgBrG,MACP;MACLse,gBAAgB1e,KAAmD,QAAxCI,EAASoE,OAATpE,CAAiBqe,mBAAuB,GAAvBA,KAA8B,CAAP,GAAgBre,EAASoE,OAATpE,CAAiBqe,mBAAjBre,CAAqCJ,CAArCI,CAD9E;MAELue,kBAAkBtO;QAChB,IAAIC,CAAJ;QAEAlQ,EAASse,cAATte,CAAwBiQ,IAAe,EAAfA,GAAmF,SAA9DC,IAAwBlQ,EAASmQ,YAATnQ,CAAsBoe,WAAgB,IAAOlO,CAAP,GAA+B,EAA1IlQ;MAA0I,CALvI;MAOLwE,oBAAoBvD,EAAK,MAAM,CAACjB,EAASyG,QAATzG,GAAoBoe,WAArB,EAAkCpe,EAASyG,QAATzG,GAAoB8b,QAAtD,EAAgE9b,EAASoE,OAATpE,CAAiBgc,iBAAjF,CAAX/a,EAAgH,CAACmd,CAAD,EAActC,CAAd,EAAwBE,CAAxB,KAA8CjY;QAGhL,IAAIya,IAAiB,EAArB;;QAEA,IAAqB,QAAfJ,CAAe,IAAQA,EAAYpd,MAAzC,EAEO;UACL,MAAMyd,IAAkB,IAAIL,CAAJ,CAAxB;UAAA,MAEMM,IAAc,IAAI3a,CAAJ,CAFpB;;UAKA,OAAO2a,EAAY1d,MAAZ0d,IAAsBD,EAAgBzd,MAA7C,GAAqD;YACnD,MAAM2d,IAAiBF,EAAgBG,KAAhBH,EAAvB;YAAA,MACMI,IAAaH,EAAYrR,SAAZqR,CAAsBte,KAAKA,EAAEmD,EAAFnD,KAASue,CAApCD,CADnB;YAGIG,KAAc,CAAdA,IACFL,EAAe1d,IAAf0d,CAAoBE,EAAYI,MAAZJ,CAAmBG,CAAnBH,EAA+B,CAA/BA,EAAkC,CAAlCA,CAApBF,CADEK;UAMNL;;UAAAA,IAAiB,IAAIA,CAAJ,EAAIA,GAAmBE,CAAvB,CAAjBF;QAAwCE,CAlB1C,MACEF,IAAiBza,CAAjBya;;QAoBF,OAAO/Z,EAAa+Z,CAAb/Z,EAA6BqX,CAA7BrX,EAAuCuX,CAAvCvX,CAAP;MAA8CuX,CA1B5B/a,EA2BjB;QACDlB,MAAK;MADJ,CA3BiBkB;IAPf,CADOjB;EAZD,CAAZ;EAAA,MAgEC+e,IAAa;IACjBhT,iBAAiBC,MACR,KAAKA,CAAL;MACLgT,YAAY;QAPhBC,WAJuB,CAWP;QANhBC,UAJsB,EAUN;QAVM,IAWH,QAATlT,CAAS,GAATA,KAAgB,CAAP,GAAgBA,EAAMgT,UAXnB;MAUN;IADP,CADQhT,CADA;IAQjBS,mBAAmBzM,MACV;MACLmf,oBAAoBrf,EAAiB,YAAjBA,EAA+BE,CAA/BF;IADf,CADUE,CARF;IAajBqG,gBAAgBrG;MACd,IAAI6R,KAAa,CAAjB;MAAA,IACIC,KAAS,CADb;MAEA,OAAO;QACLsN,qBAAqB;UACnB,IAAIlc,CAAJ,EAAUmc,CAAV;;UAEA,IAAKxN,CAAL,EAAKA;YAQL,IAA8I,SAAzI3O,IAAkE,SAA1Dmc,IAAwBrf,EAASoE,OAATpE,CAAiBgS,YAAiB,IAAOqN,CAAP,GAA+Brf,EAASoE,OAATpE,CAAiBsf,kBAAuB,IAAOpc,CAAP,GAAOA,CAAQlD,EAASoE,OAATpE,CAAiBuf,gBAA9K,EAAgM;cAC9L,IAAIzN,CAAJ,EAAY;cACZA,KAAS,CAATA,EAEA9R,EAASiS,MAATjS,CAAgB;gBACdA,EAASwf,cAATxf,IACA8R,KAAS,CADT9R;cACS,CAFXA,CAFA8R;YAIW;UAAA,CAdb,MACE9R,EAASiS,MAATjS,CAAgB;YACd6R,KAAa,CAAbA;UAAa,CADf7R;QACe,CANd;QAsBLyf,eAAe7f,KAMiC,QAAvCI,EAASoE,OAATpE,CAAiBmf,kBAAsB,GAAtBA,KAA6B,CAAP,GAAgBnf,EAASoE,OAATpE,CAAiBmf,kBAAjBnf,CAL1CE,KACHP,EAAiBC,CAAjBD,EAA0BO,CAA1BP,CAI6CK,CA5B3D;QA8BL0f,iBAAiBzP;UACf,IAAIC,CAAJ;UAEAlQ,EAASyf,aAATzf,CAAuBiQ,IAtDU;YACvCgP,WAJuB,CAGgB;YAEvCC,UAJsB;UAEiB,CAsDVjP,GAA2G,SAA7DC,IAAwBlQ,EAASmQ,YAATnQ,CAAsBgf,UAAe,IAAO9O,CAAP,GAtDjG;YACvC+O,WAJuB,CAGgB;YAEvCC,UAJsB;UAEiB,CAsDjClf;QAxDgB,CAuBb;QAmCL2f,cAAc/f;UACZI,EAASyf,aAATzf,CAAuBE;YACrB,IAAI+e,IAAYtf,EAAiBC,CAAjBD,EAA0BO,EAAI+e,SAA9Btf,CAAhB;YACA,MAAMigB,SAAwC,CAAxCA,KAAsB1f,EAAI2f,SAA1BD,GAAsD1f,EAAI2f,SAAJ3f,GAAgB,CAAtE0f,GAA0EjU,OAAOC,gBAAvF;YAEA,OADAqT,IAAY/c,KAAKW,GAALX,CAASA,KAAKU,GAALV,CAAS,CAATA,EAAY+c,CAAZ/c,CAATA,EAAiC0d,CAAjC1d,CAAZ+c,EACO,KAAK/e,CAAL;cACL+e;YADK,CAAP;UACEA,CALJjf;QAKIif,CAzCD;QA6CLO,gBAAgBvP;UACd,IAAII,CAAJ,EAA4ByP,CAA5B,EAAoDC,CAApD;UAEA/f,EAAS2f,YAAT3f,CAAsBiQ,IAxEL,CAwEKA,GAAqP,SAAlNI,IAA6E,SAAnDyP,IAAyB9f,EAASmQ,YAAiB,KAAgF,SAA/D4P,IAAyBD,EAAuBd,UAAe,CAAhF,GAAiEA,KAA1D,CAAP,GAAgGe,EAAuBd,SAAc,IAAO5O,CAAP,GAxE1P,CAwEjBrQ;QAxEiB,CAwBd;QAkDLggB,eAAe/P;UACb,IAAIgQ,CAAJ,EAA4BC,CAA5B,EAAoDC,CAApD;UAEAngB,EAASogB,WAATpgB,CAAqBiQ,IA5EL,EA4EKA,GAAmP,SAAjNgQ,IAA6E,SAAnDC,IAAyBlgB,EAASmQ,YAAiB,KAAgF,SAA/DgQ,IAAyBD,EAAuBlB,UAAe,CAAhF,GAAiEA,KAA1D,CAAP,GAAgGmB,EAAuBjB,QAAa,IAAOe,CAAP,GA5ExP,EA4EhBjgB;QA5EgB,CAuBb;QAuDLogB,aAAaxgB;UACXI,EAASyf,aAATzf,CAAuBE;YACrB,MAAMgf,IAAWhd,KAAKU,GAALV,CAAS,CAATA,EAAYvC,EAAiBC,CAAjBD,EAA0BO,EAAIgf,QAA9Bvf,CAAZuC,CAAjB;YAAA,MACMme,IAAcngB,EAAIgf,QAAJhf,GAAeA,EAAI+e,SADvC;YAAA,MAEMA,IAAY/c,KAAKoe,KAALpe,CAAWme,IAAcnB,CAAzBhd,CAFlB;YAGA,OAAO,KAAKhC,CAAL;cACL+e,YADK;cAELC;YAFK,CAAP;UAEEA,CANJlf;QAMIkf,CA9DD;QAkELqB,cAAc3gB,KAAWI,EAASyf,aAATzf,CAAuBE;UAC9C,IAAIsgB,CAAJ;UAEA,IAAIC,IAAe9gB,EAAiBC,CAAjBD,EAA8D,SAAnC6gB,IAAiBtgB,EAAI2f,SAAc,IAAOW,CAAP,GAAOA,CAAkB,CAAvF7gB,CAAnB;UAMA,OAJ4B,mBAAjB8gB,CAAiB,KAC1BA,IAAeve,KAAKU,GAALV,CAAKU,CAAK,CAAVV,EAAaue,CAAbve,CADW,GAIrB,KAAKhC,CAAL;YACL2f,WAAWY;UADN,CAAP;QACaA,CAVUzgB,CAlEpB;QA+EL0gB,gBAAgBzf,EAAK,MAAM,CAACjB,EAASyG,QAATzG,GAAoBgf,UAApBhf,CAA+Bkf,QAAhC,EAA0Clf,EAASyG,QAATzG,GAAoBgf,UAApBhf,CAA+B6f,SAAzE,CAAX5e,EAAgG,CAACie,CAAD,EAAWW,CAAX,KAAWA;UACzH,IAAIc,IAAc,EAAlB;UAMA,OAJId,KAAaA,IAAY,CAAzBA,KACFc,IAAc,IAAI,IAAIxJ,KAAJ,CAAU0I,CAAV,CAAJ,EAA0Be,IAA1B,CAA+B,IAA/B,EAAqC7a,GAArC,CAAyC,CAAC2H,CAAD,EAAImT,CAAJ,KAAUA,CAAnD,CADZhB,GAIGc,CAAP;QAAOA,CAPO1f,EAQb;UACDlB,MAAK,CADJ;UAEDyB,OAAO;YACL,IAAI2C,CAAJ;YAEA,OAA8D,SAAtDA,IAAwBnE,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOF,CAAP,GAA+BnE,EAASoE,OAATpE,CAAiB8gB,UAA9G;UAA8GA;QAL/G,CARa7f,CA/EX;QA+FL8f,oBAAoB,MAAM/gB,EAASyG,QAATzG,GAAoBgf,UAApBhf,CAA+Bif,SAA/Bjf,GAA2C,CA/FhE;QAgGLghB,gBAAgB;UACd;YAAM/B,WACJA;UADF,IAEIjf,EAASyG,QAATzG,GAAoBgf,UAFxB;UAAA,MAGMa,IAAY7f,EAASihB,YAATjhB,EAHlB;UAKA,QAAmB,CAAnB,KAAI6f,CAAJ,IAIkB,MAAdA,CAAc,IAIXZ,IAAYY,IAAY,CAR/B;QAQ+B,CA9G5B;QAgHLqB,cAAc,MACLlhB,EAAS2f,YAAT3f,CAAsBE,KAAOA,IAAM,CAAnCF,CAjHJ;QAmHLmhB,UAAU,MACDnhB,EAAS2f,YAAT3f,CAAsBE,KACpBA,IAAM,CADRF,CApHJ;QAwHLohB,0BAA0B,MAAMphB,EAASsT,mBAATtT,EAxH3B;QAyHLqhB,uBAAuB,QAChBrhB,EAASshB,sBADO,IACmBthB,EAASoE,OAATpE,CAAiBqhB,qBADpC,KAEnBrhB,EAASshB,sBAATthB,GAAkCA,EAASoE,OAATpE,CAAiBqhB,qBAAjBrhB,CAAuCA,CAAvCA,CAFf,GAKjBA,EAASoE,OAATpE,CAAiBuf,gBAAjBvf,IAAiBuf,CAAqBvf,EAASshB,sBAA/CthB,GACKA,EAASohB,wBAATphB,EADLA,GAIGA,EAASshB,sBAATthB,EATc,CAzHlB;QAoILihB,cAAc;UACZ;YAAMpB,WACJA;UADF,IAEI7f,EAASyG,QAATzG,GAAoBgf,UAFxB;UAIA,YAAyB,CAAzB,KAAWa,CAAX,GACSA,CADT,GAIO3d,KAAKqf,IAALrf,CAAUlC,EAASohB,wBAATphB,GAAoCwhB,IAApCxhB,CAAyCgB,MAAzChB,GAAkDA,EAASyG,QAATzG,GAAoBgf,UAApBhf,CAA+Bkf,QAA3Fhd,CAJP;QAIkGgd;MA7I/F,CAAP;IA6IsGA;EA7JvF,CAhEd;EAAA,MAyOCuC,IAAU;IACd1V,iBAAiBC,MACR;MACLtF,eARgC;QACpCC,MAAM,EAD8B;QAEpCC,OAAO;MAF6B,CAO3B;MALF,GAOAoF;IAFE,CADQA,CADH;IAOdS,mBAAmBzM,MACV;MACL0hB,uBAAuB5hB,EAAiB,eAAjBA,EAAkCE,CAAlCF;IADlB,CADUE,CAPL;IAYd8C,cAAc,CAACe,CAAD,EAAS7D,CAAT,MACL;MACL2hB,KAAKzU;QACH,MAAM0U,IAAY/d,EAAOU,cAAPV,GAAwBkC,GAAxBlC,CAA4BzD,KAAKA,EAAEmD,EAAnCM,EAAuCsD,MAAvCtD,CAA8CuD,OAA9CvD,CAAlB;QACA7D,EAAS6hB,gBAAT7hB,CAA0BE;UACxB,IAAI4hB,CAAJ,EAAgBC,CAAhB,EAGMC,CAHN,EAGiBC,CAHjB,EAYMC,CAZN,EAYkBC,CAZlB;UAEA,OAAiB,YAAbjV,CAAa,GAGR;YACLvG,OAAwD,SAAhDqb,IAAmB,QAAP9hB,CAAO,GAAPA,KAAc,CAAP,GAAgBA,EAAIyG,IAAS,IAAOqb,CAAP,GAAmB,EAA3Erb,EAA+EQ,MAA/ER,CAAsFvG,OAAoB,QAAbwhB,CAAa,IAAQA,EAAUra,QAAVqa,CAAmBxhB,CAAnBwhB,CAA5BxhB,CAAtFuG,CADK;YAELC,OAAO,KAAwD,SAAlDqb,IAAoB,QAAP/hB,CAAO,GAAPA,KAAc,CAAP,GAAgBA,EAAI0G,KAAU,IAAOqb,CAAP,GAAoB,EAA5E,EAAgF9a,MAAhF,CAAuF/G,OAAoB,QAAbwhB,CAAa,IAAQA,EAAUra,QAAVqa,CAAmBxhB,CAAnBwhB,CAA5BxhB,CAAvF,GAAsIA,GAASwhB,CAA/I;UAFF,CAHQ,GASA,WAAb1U,CAAa,GAGR;YACLvG,MAAM,KAAuD,SAAjDub,IAAoB,QAAPhiB,CAAO,GAAPA,KAAc,CAAP,GAAgBA,EAAIyG,IAAS,IAAOub,CAAP,GAAoB,EAA3E,EAA+E/a,MAA/E,CAAsF/G,OAAoB,QAAbwhB,CAAa,IAAQA,EAAUra,QAAVqa,CAAmBxhB,CAAnBwhB,CAA5BxhB,CAAtF,GAAqIA,GAASwhB,CAA9I,CADD;YAELhb,QAA4D,SAAnDub,IAAqB,QAAPjiB,CAAO,GAAPA,KAAc,CAAP,GAAgBA,EAAI0G,KAAU,IAAOub,CAAP,GAAqB,EAAjFvb,EAAqFO,MAArFP,CAA4FxG,OAAoB,QAAbwhB,CAAa,IAAQA,EAAUra,QAAVqa,CAAmBxhB,CAAnBwhB,CAA5BxhB,CAA5FwG;UAFK,CAHQ,GASV;YACLD,OAAyD,SAAjDmb,IAAoB,QAAP5hB,CAAO,GAAPA,KAAc,CAAP,GAAgBA,EAAIyG,IAAS,IAAOmb,CAAP,GAAoB,EAA7Enb,EAAiFQ,MAAjFR,CAAwFvG,OAAoB,QAAbwhB,CAAa,IAAQA,EAAUra,QAAVqa,CAAmBxhB,CAAnBwhB,CAA5BxhB,CAAxFuG,CADK;YAELC,QAA4D,SAAnDmb,IAAqB,QAAP7hB,CAAO,GAAPA,KAAc,CAAP,GAAgBA,EAAI0G,KAAU,IAAOmb,CAAP,GAAqB,EAAjFnb,EAAqFO,MAArFP,CAA4FxG,OAAoB,QAAbwhB,CAAa,IAAQA,EAAUra,QAAVqa,CAAmBxhB,CAAnBwhB,CAA5BxhB,CAA5FwG;UAFK,CAlBP;QAoB6IxG,CAvB/IJ;MAuB+II,CA1B5I;MA8BLgiB,WAAW,MACWve,EAAOU,cAAPV,GACDjC,IADCiC,CACIzD;QACtB,IAAIiiB,CAAJ,EAA2BvU,CAA3B;QAEA,QAA+D,SAAtDuU,IAAwBjiB,EAAE2C,SAAF3C,CAAYkiB,aAAkB,KAAOD,CAAtE,MAAoK,SAA3DvU,IAAwB9N,EAASoE,OAATpE,CAAiBsiB,aAAkB,KAAOxU,CAA3K;MAA2KA,CAJzJjK,CA/BjB;MAsCL0e,aAAa;QACX,MAAMC,IAAgB3e,EAAOU,cAAPV,GAAwBkC,GAAxBlC,CAA4BzD,KAAKA,EAAEmD,EAAnCM,CAAtB;QAAA,MAAyDN;UACnDoD,MACJA,CAFuDpD;UAEnDqD,OACJA;QAHuDrD,IAIrDvD,EAASyG,QAATzG,GAAoB0G,aAJxB;QAAA,MAKM+b,IAASD,EAAc5gB,IAAd4gB,CAAmBpiB,KAAa,QAARuG,CAAQ,GAARA,KAAe,CAAP,GAAgBA,EAAKY,QAALZ,CAAcvG,CAAduG,CAAhD6b,CALf;QAAA,MAMME,IAAUF,EAAc5gB,IAAd4gB,CAAmBpiB,KAAc,QAATwG,CAAS,GAATA,KAAgB,CAAP,GAAgBA,EAAMW,QAANX,CAAexG,CAAfwG,CAAjD4b,CANhB;QAOA,OAAOC,IAAS,MAATA,GAAS,EAASC,CAAT,IAAmB,OAAnC;MAAmC,CA9ChC;MAgDLC,gBAAgB;QACd,IAAIvK,CAAJ,EAA2BC,CAA3B,EAAmDC,CAAnD;QAEA,MAAMpL,IAAWrJ,EAAO0e,WAAP1e,EAAjB;QACA,OAAOqJ,IAAiP,SAArOkL,IAAwF,SAA/DC,IAAyBrY,EAASyG,QAATzG,GAAoB0G,aAAkB,KAA+E,SAA9D4R,IAAyBD,EAAuBnL,CAAvBmL,CAAqC,CAA/E,GAAiEnL,KAA1D,CAAP,GAA+FoL,EAAuBmE,OAAvBnE,CAA+BzU,EAAON,EAAtC+U,CAA8C,IAAOF,CAAP,GAAOA,CAAyB,CAAjRlL,GAAqR,CAA5R;MAA4R;IApDzR,CADK,CAZA;IAqEduG,WAAW,CAAChB,CAAD,EAAMzS,CAAN,MACF;MACL4iB,uBAAuB3hB,EAAK,MAAM,CAACwR,EAAIoQ,mBAAJpQ,EAAD,EAA4BzS,EAASyG,QAATzG,GAAoB0G,aAApB1G,CAAkC2G,IAA9D,EAAoE3G,EAASyG,QAATzG,GAAoB0G,aAApB1G,CAAkC4G,KAAtG,CAAX3F,EAAyH,CAAC6hB,CAAD,EAAWnc,CAAX,EAAiBC,CAAjB,KAAiBA;QAC/J,MAAMmc,IAAe,KAAa,QAARpc,CAAQ,GAAOA,CAAP,GAAc,EAA3B,GAA2B,IAAkB,QAATC,CAAS,GAAOA,CAAP,GAAe,EAAjC,CAA3B,CAArB;QACA,OAAOkc,EAAS3b,MAAT2b,CAAgB1iB,MAAM2iB,EAAaxb,QAAbwb,CAAsB3iB,EAAEyD,MAAFzD,CAASmD,EAA/Bwf,CAAtBD,CAAP;MAA4Dvf,CAFvCtC,EAGpB;QACDlB,KAA8C,2BAD7C;QAEDyB,OAAO;UACL,IAAI2C,CAAJ;UAEA,OAA8D,SAAtDA,IAAwBnE,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOF,CAAP,GAA+BnE,EAASoE,OAATpE,CAAiBgjB,SAA9G;QAA8GA;MAL/G,CAHoB/hB,CADlB;MAYLgiB,qBAAqBhiB,EAAK,MAAM,CAACwR,EAAIoQ,mBAAJpQ,EAAD,EAA4BzS,EAASyG,QAATzG,GAAoB0G,aAApB1G,CAAkC2G,IAA9D,GAAX1F,EAAkF,CAAC6hB,CAAD,EAAWnc,CAAX,KAAWA,CACzF,QAARA,CAAQ,GAAOA,CAAP,GAAc,EAD2EA,EACvEZ,GADuEY,CACnEM,KAAY6b,EAAS5b,IAAT4b,CAAcpF,KAAQA,EAAK7Z,MAAL6Z,CAAYna,EAAZma,KAAmBzW,CAAzC6b,CADuDnc,EACHQ,MADGR,CACIS,OADJT,EACaZ,GADbY,CACiBvG,MAAM,KAAKA,CAAL;QACrI8M,UAAU;MAD2H,CAAN9M,CADjBuG,CAA7F1F,EAKlB;QACDlB,KAA8C,yBAD7C;QAEDyB,OAAO;UACL,IAAIoD,CAAJ;UAEA,OAA+D,SAAvDA,IAAyB5E,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOO,CAAP,GAAgC5E,EAASoE,OAATpE,CAAiBgjB,SAAhH;QAAgHA;MALjH,CALkB/hB,CAZhB;MAyBLiiB,sBAAsBjiB,EAAK,MAAM,CAACwR,EAAIoQ,mBAAJpQ,EAAD,EAA4BzS,EAASyG,QAATzG,GAAoB0G,aAApB1G,CAAkC4G,KAA9D,CAAX3F,EAAiF,CAAC6hB,CAAD,EAAWlc,CAAX,KAAWA,CACxF,QAATA,CAAS,GAAOA,CAAP,GAAe,EADyEA,EACrEb,GADqEa,CACjEK,KAAY6b,EAAS5b,IAAT4b,CAAcpF,KAAQA,EAAK7Z,MAAL6Z,CAAYna,EAAZma,KAAmBzW,CAAzC6b,CADqDlc,EACDO,MADCP,CACMQ,OADNR,EACeb,GADfa,CACmBxG,MAAM,KAAKA,CAAL;QACvI8M,UAAU;MAD6H,CAAN9M,CADnBwG,CAA5F3F,EAKnB;QACDlB,KAA8C,0BAD7C;QAEDyB,OAAO;UACL,IAAIoG,CAAJ;UAEA,OAA+D,SAAvDA,IAAyB5H,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOuD,CAAP,GAAgC5H,EAASoE,OAATpE,CAAiBgjB,SAAhH;QAAgHA;MALjH,CALmB/hB;IAzBjB,CADE,CArEG;IA8GdoF,gBAAgBrG,MACP;MACL6hB,kBAAkBjiB,KAAqD,QAA1CI,EAASoE,OAATpE,CAAiB0hB,qBAAyB,GAAzBA,KAAgC,CAAP,GAAgB1hB,EAASoE,OAATpE,CAAiB0hB,qBAAjB1hB,CAAuCJ,CAAvCI,CADlF;MAELmjB,oBAAoBlT;QAClB,IAAIC,CAAJ,EAA2BG,CAA3B;QAEA,OAAOrQ,EAAS6hB,gBAAT7hB,CAA0BiQ,IAzHH;UACpCtJ,MAAM,EAD8B;UAEpCC,OAAO;QAF6B,CAyHGqJ,GAAgL,SAArIC,IAA4E,SAAnDG,IAAyBrQ,EAASmQ,YAAiB,IAAjBA,KAAwB,CAAP,GAAgBE,EAAuB3J,aAAkB,IAAOwJ,CAAP,GAzHnL;UACpCvJ,MAAM,EAD8B;UAEpCC,OAAO;QAF6B,CAyHvB5G,CAAP;MAvHC,CAkHE;MAOLojB,wBAAwBlW;QACtB,IAAImW,CAAJ;QAEA,MAAMC,IAAetjB,EAASyG,QAATzG,GAAoB0G,aAAzC;QAGE,IAAI6c,CAAJ,EAAwBC,CAAxB;QADF,OAAKtW,IAME9F,QAA4D,SAAnDic,IAAwBC,EAAapW,CAAboW,CAA2B,IAAdpW,KAAqB,CAAP,GAAgBmW,EAAsBriB,MAAlGoG,CANF8F,GAGI9F,SAAqD,SAA3Cmc,IAAqBD,EAAa3c,IAAS,IAATA,KAAgB,CAAP,GAAgB4c,EAAmBviB,MAAxFoG,MAAkJ,SAA7Coc,IAAsBF,EAAa1c,KAAU,IAAVA,KAAiB,CAAP,GAAgB4c,EAAoBxiB,MAAtLoG,EAHT;MAG+LpG,CAf5L;MAoBLyiB,oBAAoBxiB,EAAK,MAAM,CAACjB,EAAS2Z,iBAAT3Z,EAAD,EAA+BA,EAASyG,QAATzG,GAAoB0G,aAApB1G,CAAkC2G,IAAjE,CAAX1F,EAAmF,CAAC4F,CAAD,EAAaF,CAAb,KAAaA,CAClG,QAARA,CAAQ,GAAOA,CAAP,GAAc,EADoFA,EAChFZ,GADgFY,CAC5EM,KAAYJ,EAAWK,IAAXL,CAAgBhD,KAAUA,EAAON,EAAPM,KAAcoD,CAAxCJ,CADgEF,EACbQ,MADaR,CACNS,OADMT,CAAhG1F,EAEjB;QACDlB,MAAK,CADJ;QAEDyB,OAAO;UACL,IAAIuG,CAAJ;UAEA,OAA+D,SAAvDA,IAAyB/H,EAASoE,OAATpE,CAAiBqE,QAAa,IAAO0D,CAAP,GAAgC/H,EAASoE,OAATpE,CAAiBsE,YAAhH;QAAgHA;MALjH,CAFiBrD,CApBf;MA8BLyiB,qBAAqBziB,EAAK,MAAM,CAACjB,EAAS2Z,iBAAT3Z,EAAD,EAA+BA,EAASyG,QAATzG,GAAoB0G,aAApB1G,CAAkC4G,KAAjE,CAAX3F,EAAoF,CAAC4F,CAAD,EAAaD,CAAb,KAAaA,CACnG,QAATA,CAAS,GAAOA,CAAP,GAAe,EADoFA,EAChFb,GADgFa,CAC5EK,KAAYJ,EAAWK,IAAXL,CAAgBhD,KAAUA,EAAON,EAAPM,KAAcoD,CAAxCJ,CADgED,EACbO,MADaP,CACNQ,OADMR,CAAjG3F,EAElB;QACDlB,MAAK,CADJ;QAEDyB,OAAO;UACL,IAAI2G,CAAJ;UAEA,OAA+D,SAAvDA,IAAyBnI,EAASoE,OAATpE,CAAiBqE,QAAa,IAAO8D,CAAP,GAAgCnI,EAASoE,OAATpE,CAAiBsE,YAAhH;QAAgHA;MALjH,CAFkBrD,CA9BhB;MAwCL0iB,sBAAsB1iB,EAAK,MAAM,CAACjB,EAAS2Z,iBAAT3Z,EAAD,EAA+BA,EAASyG,QAATzG,GAAoB0G,aAApB1G,CAAkC2G,IAAjE,EAAuE3G,EAASyG,QAATzG,GAAoB0G,aAApB1G,CAAkC4G,KAAzG,CAAX3F,EAA4H,CAAC4F,CAAD,EAAaF,CAAb,EAAmBC,CAAnB,KAAmBA;QACnK,MAAMmc,IAAe,KAAa,QAARpc,CAAQ,GAAOA,CAAP,GAAc,EAA3B,GAA2B,IAAkB,QAATC,CAAS,GAAOA,CAAP,GAAe,EAAjC,CAA3B,CAArB;QACA,OAAOC,EAAWM,MAAXN,CAAkBzG,MAAM2iB,EAAaxb,QAAbwb,CAAsB3iB,EAAEmD,EAAxBwf,CAAxBlc,CAAP;MAAuDtD,CAFnCtC,EAGnB;QACDlB,MAAK,CADJ;QAEDyB,OAAO;UACL,IAAI6G,CAAJ;UAEA,OAA+D,SAAvDA,IAAyBrI,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOgE,CAAP,GAAgCrI,EAASoE,OAATpE,CAAiBsE,YAAhH;QAAgHA;MALjH,CAHmBrD;IAxCjB,CADOjB;EA9GF,CAzOX;EAAA,MAgZC4jB,IAAe;IACnB7X,iBAAiBC,MACR;MACL6X,cAAc,EADT;MACS,GACX7X;IAFE,CADQA,CADE;IAOnBS,mBAAmBzM,MACV;MACL8jB,sBAAsBhkB,EAAiB,cAAjBA,EAAiCE,CAAjCF,CADjB;MAELikB,qBAAoB,CAFf;MAGLC,0BAAyB,CAHpB;MAILC,wBAAuB;IAJlB,CADUjkB,CAPA;IAkBnBqG,gBAAgBrG,MACP;MACLkkB,iBAAiBtkB,KAAoD,QAAzCI,EAASoE,OAATpE,CAAiB8jB,oBAAwB,GAAxBA,KAA+B,CAAP,GAAgB9jB,EAASoE,OAATpE,CAAiB8jB,oBAAjB9jB,CAAsCJ,CAAtCI,CADhF;MAELmkB,mBAAmBlU;QACjB,IAAIC,CAAJ;QAEA,OAAOlQ,EAASkkB,eAATlkB,CAAyBiQ,IAAe,EAAfA,GAAoF,SAA/DC,IAAwBlQ,EAASmQ,YAATnQ,CAAsB6jB,YAAiB,IAAO3T,CAAP,GAA+B,EAA5IlQ,CAAP;MAAmJ,CALhJ;MAOLokB,uBAAuBlN;QACrBlX,EAASkkB,eAATlkB,CAAyBE;UACvBgX,SAAyB,CAAzBA,KAAeA,CAAfA,GAAuCA,CAAvCA,GAAuCA,CAASlX,EAASqkB,oBAATrkB,EAAhDkX;UACA,MAAM2M,IAAe,KAAK3jB;UAAL,CAArB;UAAA,MAEMokB,IAAqBtkB,EAASmd,qBAATnd,GAAiCwS,QAF5D;UAeA,OAVI0E,IACFoN,EAAmB1jB,OAAnB0jB,CAA2B7R;YACzBoR,EAAapR,EAAIlP,EAAjBsgB,IAAiBtgB,CAAM,CAAvBsgB;UAAuB,CADzBS,CADEpN,GAKFoN,EAAmB1jB,OAAnB0jB,CAA2B7R;YAAAA,OAClBoR,EAAapR,EAAIlP,EAAjBsgB,CADkBpR;UACDlP,CAD1B+gB,CALEpN,EAUG2M,CAAP;QAAOA,CAjBT7jB;MAiBS6jB,CAzBN;MA4BLU,2BAA2BrN,KAASlX,EAASkkB,eAATlkB,CAAyBE;QAAAA,KAC1C,CAD0CA,KACpDgX,CADoDhX,IACnBF,EAASwkB,wBAATxkB,EADmBE;QAE3D,MAAM2jB,IAAe,KAAK3jB;QAAL,CAArB;QAKA,OAHAF,EAASuS,WAATvS,GAAuBwhB,IAAvBxhB,CAA4BY,OAA5BZ,CAAoCyS;UAClCgS,EAAoBZ,CAApBY,EAAkChS,EAAIlP,EAAtCkhB,EAA0CvN,CAA1CuN,EAAiDzkB,CAAjDykB;QAAiDzkB,CADnDA,GAGO6jB,CAAP;MAAOA,CAP2B7jB,CA5B/B;MAuFL0kB,wBAAwB,MAAM1kB,EAAS8W,eAAT9W,EAvFzB;MAwFL2kB,qBAAqB1jB,EAAK,MAAM,CAACjB,EAASyG,QAATzG,GAAoB6jB,YAArB,EAAmC7jB,EAAS8W,eAAT9W,EAAnC,CAAXiB,EAA2E,CAAC4iB,CAAD,EAAee,CAAf,KACzF3f,OAAO6N,IAAP7N,CAAY4e,CAAZ5e,EAA0BjE,MAA1BiE,GAQE4f,EAAa7kB,CAAb6kB,EAAuBD,CAAvBC,CARF5f,GACI;QACLuc,MAAM,EADD;QAELhP,UAAU,EAFL;QAGLS,UAAU;MAHL,CAFUhS,EAUlB;QACDlB,MAAK,CADJ;QAEDyB,OAAO;UACL,IAAI2C,CAAJ;UAEA,OAA8D,SAAtDA,IAAwBnE,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOF,CAAP,GAA+BnE,EAASoE,OAATpE,CAAiB8gB,UAA9G;QAA8GA;MAL/G,CAVkB7f,CAxFhB;MA0GL6jB,6BAA6B7jB,EAAK,MAAM,CAACjB,EAASyG,QAATzG,GAAoB6jB,YAArB,EAAmC7jB,EAASia,mBAATja,EAAnC,CAAXiB,EAA+E,CAAC4iB,CAAD,EAAee,CAAf,KACrG3f,OAAO6N,IAAP7N,CAAY4e,CAAZ5e,EAA0BjE,MAA1BiE,GAQE4f,EAAa7kB,CAAb6kB,EAAuBD,CAAvBC,CARF5f,GACI;QACLuc,MAAM,EADD;QAELhP,UAAU,EAFL;QAGLS,UAAU;MAHL,CAFkBhS,EAU1B;QACDlB,KAA8C,6BAD7C;QAEDyB,OAAO;UACL,IAAIoD,CAAJ;UAEA,OAA+D,SAAvDA,IAAyB5E,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOO,CAAP,GAAgC5E,EAASoE,OAATpE,CAAiB8gB,UAAhH;QAAgHA;MALjH,CAV0B7f,CA1GxB;MA4HL8jB,4BAA4B9jB,EAAK,MAAM,CAACjB,EAASyG,QAATzG,GAAoB6jB,YAArB,EAAmC7jB,EAASqT,kBAATrT,EAAnC,CAAXiB,EAA8E,CAAC4iB,CAAD,EAAee,CAAf,KACnG3f,OAAO6N,IAAP7N,CAAY4e,CAAZ5e,EAA0BjE,MAA1BiE,GAQE4f,EAAa7kB,CAAb6kB,EAAuBD,CAAvBC,CARF5f,GACI;QACLuc,MAAM,EADD;QAELhP,UAAU,EAFL;QAGLS,UAAU;MAHL,CAFiBhS,EAUzB;QACDlB,KAA8C,4BAD7C;QAEDyB,OAAO;UACL,IAAIoG,CAAJ;UAEA,OAA+D,SAAvDA,IAAyB5H,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOuD,CAAP,GAAgC5H,EAASoE,OAATpE,CAAiB8gB,UAAhH;QAAgHA;MALjH,CAVyB7f,CA5HvB;MAyJLojB,sBAAsB;QACpB,MAAMW,IAAsBhlB,EAASkZ,sBAATlZ,GAAkCwS,QAA9D;QAAA,MAA8DA;UACxDqR,cACJA;QAF4DrR,IAG1DxS,EAASyG,QAATzG,EAHJ;QAIA,IAAIilB,IAAoB7d,QAAQ4d,EAAoBhkB,MAApBgkB,IAA8B/f,OAAO6N,IAAP7N,CAAY4e,CAAZ5e,EAA0BjE,MAAhEoG,CAAxB;QAQA,OANI6d,KACED,EAAoBpjB,IAApBojB,CAAyBvS,MAAQoR,EAAapR,EAAIlP,EAAjBsgB,CAAjCmB,CADFC,KAEAA,KAAoB,CAFpBA,GAMGA,CAAP;MAAOA,CAtKJ;MAwKLT,0BAA0B;QACxB,MAAMU,IAAqBllB,EAASqhB,qBAATrhB,GAAiCwS,QAA5D;QAAA,MAA4DA;UACtDqR,cACJA;QAF0DrR,IAGxDxS,EAASyG,QAATzG,EAHJ;QAIA,IAAImlB,MAA0BD,EAAmBlkB,MAAjD;QAMA,OAJImkB,KAAyBD,EAAmBtjB,IAAnBsjB,CAAwBzS,MAAQoR,EAAapR,EAAIlP,EAAjBsgB,CAAhCqB,CAAzBC,KACFA,KAAwB,CADtBA,GAIGA,CAAP;MAAOA,CAnLJ;MAqLLC,uBAAuB;QACrB,IAAIC,CAAJ;QAEA,QAAQrlB,EAASqkB,oBAATrkB,EAAR,IAAiBqkB,EAA4Bpf,OAAO6N,IAAP7N,CAA0E,SAA7DogB,IAAwBrlB,EAASyG,QAATzG,GAAoB6jB,YAAiB,IAAOwB,CAAP,GAA+B,EAAzGpgB,EAA6GjE,MAA1J;MAA0JA,CAxLvJ;MA0LLskB,2BAA2B;QACzB,MAAMJ,IAAqBllB,EAASqhB,qBAATrhB,GAAiCwS,QAA5D;QACA,QAAOxS,EAASwkB,wBAATxkB,EAAP,IAAgBwkB,EAA8D,QAAtBU,CAAsB,IAAtBA,CAA8BA,EAAmBlkB,MAAzFwjB,CAAhB;MAAyGxjB,CA5LtG;MA8LLukB,iCAAiC,MACxB/W;QACLxO,EAASokB,qBAATpkB,CAA+BwO,EAAEgX,MAAFhX,CAASiX,OAAxCzlB;MAAwCylB,CAhMvC;MAmMLC,qCAAqC,MAC5BlX;QACLxO,EAASukB,yBAATvkB,CAAmCwO,EAAEgX,MAAFhX,CAASiX,OAA5CzlB;MAA4CylB;IArM3C,CADOzlB,CAlBG;IA6NnByT,WAAW,CAAChB,CAAD,EAAMzS,CAAN,MACF;MACL2lB,gBAAgBzO;QACd,MAAM0O,IAAanT,EAAIoT,aAAJpT,EAAnB;QACAzS,EAASkkB,eAATlkB,CAAyBE;UAGvB,IAAI0lB,OAFJ1O,SAAyB,CAAzBA,KAAeA,CAAfA,GAAuCA,CAAvCA,GAAuCA,CAAS0O,CAE5CA,CAAJ,EACE,OAAO1lB,CAAP;UAGF,MAAM4lB,IAAiB,KAAK5lB;UAAL,CAAvB;UAGA,OADAukB,EAAoBqB,CAApBrB,EAAoChS,EAAIlP,EAAxCkhB,EAA4CvN,CAA5CuN,EAAmDzkB,CAAnDykB,GACOqB,CAAP;QAAOA,CAVT9lB;MAUS8lB,CAbN;MAgBLD,eAAe;QACb;UAAMhC,cACJA;QADF,IAEI7jB,EAASyG,QAATzG,EAFJ;QAGA,QAA4C,CAA5C,KAAO+lB,EAActT,CAAdsT,EAAmBlC,CAAnBkC,CAAP;MAA0BlC,CApBvB;MAsBLmC,mBAAmB;QACjB;UAAMnC,cACJA;QADF,IAEI7jB,EAASyG,QAATzG,EAFJ;QAGA,OAA4C,WAArC+lB,EAActT,CAAdsT,EAAmBlC,CAAnBkC,CAAP;MAA0BlC,CA1BvB;MA4BLoC,cAAc;QACZ,IAAInY,CAAJ;QAEA,OAAmD,qBAAxC9N,EAASoE,OAATpE,CAAiB+jB,kBAAuB,GAC1C/jB,EAASoE,OAATpE,CAAiB+jB,kBAAjB/jB,CAAoCyS,CAApCzS,CAD0C,GAIqB,SAAhE8N,IAAwB9N,EAASoE,OAATpE,CAAiB+jB,kBAAuB,KAAOjW,CAJ/E;MAI+EA,CAnC5E;MAqCLoY,qBAAqB;QACnB,IAAI1O,CAAJ;QAEA,OAAsD,qBAA3CxX,EAASoE,OAATpE,CAAiBikB,qBAA0B,GAC7CjkB,EAASoE,OAATpE,CAAiBikB,qBAAjBjkB,CAAuCyS,CAAvCzS,CAD6C,GAIsB,SAApEwX,IAAyBxX,EAASoE,OAATpE,CAAiBikB,qBAA0B,KAAOzM,CAJnF;MAImFA,CA5ChF;MA8CL2O,mBAAmB;QACjB,IAAIrO,CAAJ;QAEA,OAAwD,qBAA7C9X,EAASoE,OAATpE,CAAiBgkB,uBAA4B,GAC/ChkB,EAASoE,OAATpE,CAAiBgkB,uBAAjBhkB,CAAyCyS,CAAzCzS,CAD+C,GAIsB,SAAtE8X,IAAyB9X,EAASoE,OAATpE,CAAiBgkB,uBAA4B,KAAOlM,CAJrF;MAIqFA,CArDlF;MAuDLsO,0BAA0B;QACxB,MAAMC,IAAY5T,EAAIwT,YAAJxT,EAAlB;QACA,OAAOjE;UACL,IAAI8X,CAAJ;UAEKD,KACL5T,EAAIkT,cAAJlT,CAA2C,SAAvB6T,IAAU9X,EAAEgX,MAAW,IAAXA,KAAkB,CAAP,GAAgBc,EAAQb,OAAnEhT,CADK4T;QAC8DZ,CAJrE;MAIqEA;IA7DlE,CADE;EA7NQ,CAhZhB;EAAA,MAkrBChB,IAAsB,CAACqB,CAAD,EAAiBviB,CAAjB,EAAqB2T,CAArB,EAA4BlX,CAA5B,KAA4BA;IACtD,IAAIkU,CAAJ;IAEA,MAAMzB,IAAMzS,EAASumB,MAATvmB,CAAgBuD,CAAhBvD,CAAZ;IACAyS,EAAI4J,YAAJ5J,IAKIyE,IACF4O,EAAeviB,CAAfuiB,IAAeviB,CAAM,CADnB2T,GACmB,OAEd4O,EAAeviB,CAAfuiB,CARTrT,EAYoC,SAA/ByB,IAAezB,EAAI4B,OAAY,KAAQH,EAAalT,MAArB,IAA+ByR,EAAIyT,mBAAJzT,EAA/B,IAClCA,EAAI4B,OAAJ5B,CAAY7R,OAAZ6R,CAAoBA,KAAOgS,EAAoBqB,CAApBrB,EAAoChS,EAAIlP,EAAxCkhB,EAA4CvN,CAA5CuN,EAAmDzkB,CAAnDykB,CAA3BhS,CAbFA;EAagFzS,CAnsB7E;;EAusBL,SAAS6kB,CAAT,CAAsB7kB,CAAtB,EAAgC4kB,CAAhC,EAAgCA;IAC9B,MAAMf,IAAe7jB,EAASyG,QAATzG,GAAoB6jB,YAAzC;IAAA,MACM2C,IAAsB,EAD5B;IAAA,MAEMC,IAAsB,EAF5B;IAAA,MAIMC,IAAc,UAAUlF,CAAV,EAAgBxe,CAAhB,EAAgBA;MAKlC,YAJc,CAId,KAJIA,CAIJ,KAHEA,IAAQ,CAGV,GAAOwe,EAAKzb,GAALyb,CAAS/O;QACd,IAAIkU,CAAJ;QAEA,MAAMf,KAAkD,CAAlDA,KAAaG,EAActT,CAAdsT,EAAmBlC,CAAnBkC,CAAnB;QAaA,IAXIH,MACFY,EAAoB1lB,IAApB0lB,CAAyB/T,CAAzB+T,GACAC,EAAoBhU,EAAIlP,EAAxBkjB,IAA8BhU,CAF5BmT,GAKiC,SAAhCe,IAAgBlU,EAAI4B,OAAY,KAAQsS,EAAc3lB,MAAtB,KACnCyR,IAAM,KAAKA,CAAL;UACJ4B,SAASqS,EAAYjU,EAAI4B,OAAhBqS,EAAyB1jB,IAAQ,CAAjC0jB;QADL,CAD6B,CALjCd,EAWAA,CAAJ,EACE,OAAOnT,CAAP;MAAOA,CAjBJ+O,EAmBJra,MAnBIqa,CAmBGpa,OAnBHoa,CAAP;IAmBUpa,CA5BZ;;IA+BA,OAAO;MACLoa,MAAMkF,EAAY9B,EAASpD,IAArBkF,CADD;MAELlU,UAAUgU,CAFL;MAGLvT,UAAUwT;IAHL,CAAP;EAMF;;EAAA,SAASV,CAAT,CAAuBtT,CAAvB,EAA4BmU,CAA5B,EAAuC5mB,CAAvC,EAAuCA;IACrC,IAAI4mB,EAAUnU,EAAIlP,EAAdqjB,CAAJ,EACE,QAAO,CAAP;;IAGF,IAAInU,EAAI4B,OAAJ5B,IAAeA,EAAI4B,OAAJ5B,CAAYzR,MAA/B,EAAuC;MACrC,IAAI6lB,KAAsB,CAA1B;MAAA,IACIC,KAAe,CADnB;MAcA,OAZArU,EAAI4B,OAAJ5B,CAAY7R,OAAZ6R,CAAoBsU;QAEdD,MAAiBD,CAAjBC,KAIAf,EAAcgB,CAAdhB,EAAsBa,CAAtBb,IACFe,KAAe,CADbf,GAGFc,KAAsB,CAPpBC;MAOoB,CAT1BrU,GAS0B,EAGnBoU,CAHmB,IAGnBA,EAA6BC,CAA7BD,IAA4C,MAAnD;IAGF;;IAAA,QAAO,CAAP;EAGI;;EAAA,UAAsB,YAAtB;;EA+BN,SAASG,CAAT,CAAsBC,CAAtB,EAAyBC,CAAzB,EAAyBA;IACvB,OAAOD,MAAMC,CAAND,GAAU,CAAVA,GAAcA,IAAIC,CAAJD,GAAQ,CAARA,GAAQ,CAAK,CAAlC;EAGF;;EAAA,SAASrL,CAAT,CAAkBqL,CAAlB,EAAkBA;IAChB,OAAiB,mBAANA,CAAM,GACXlR,MAAMkR,CAANlR,KAAYkR,MAAMjR,KAAlBD,IAA8BkR,OAAOjR,CAAPiR,GAAOjR,CAArCD,GACK,EADLA,GAIGtT,OAAOwkB,CAAPxkB,CALQ,GAQA,mBAANwkB,CAAM,GACRA,CADQ,GAIV,EAZP;EAkBF;;EAAA,SAASE,CAAT,CAA6BC,CAA7B,EAAmCC,CAAnC,EAAmCA;IAGjC,MAAMJ,IAAIG,EAAKjU,KAALiU,CAAWE,CAAXF,EAAgCjgB,MAAhCigB,CAAuChgB,OAAvCggB,CAAV;IAAA,MACMF,IAAIG,EAAKlU,KAALkU,CAAWC,CAAXD,EAAgClgB,MAAhCkgB,CAAuCjgB,OAAvCigB,CADV;;IAGA,OAAOJ,EAAEjmB,MAAFimB,IAAYC,EAAElmB,MAArB,GAA6B;MAC3B,MAAMumB,IAAKN,EAAErI,KAAFqI,EAAX;MAAA,MACMO,IAAKN,EAAEtI,KAAFsI,EADX;MAAA,MAEMO,IAAKC,SAASH,CAATG,EAAa,EAAbA,CAFX;MAAA,MAGMC,IAAKD,SAASF,CAATE,EAAa,EAAbA,CAHX;MAAA,MAIME,IAAQ,CAACH,CAAD,EAAKE,CAAL,EAASE,IAAT,EAJd;;MAMA,IAAI9R,MAAM6R,EAAM,CAANA,CAAN7R,CAAJ;QACE,IAAIwR,IAAKC,CAAT,EACE,OAAO,CAAP;QAGF,IAAIA,IAAKD,CAAT,EACE,QAAQ,CAAR;MAAQ,CANZ;QAaA,IAAIxR,MAAM6R,EAAM,CAANA,CAAN7R,CAAJ,EACE,OAAOA,MAAM0R,CAAN1R,IAAM0R,CAAO,CAAb1R,GAAiB,CAAxB;QAIF,IAAI0R,IAAKE,CAAT,EACE,OAAO,CAAP;QAGF,IAAIA,IAAKF,CAAT,EACE,QAAQ,CAAR;MAAQ;IAIZ;;IAAA,OAAOR,EAAEjmB,MAAFimB,GAAWC,EAAElmB,MAApB;EAIG;;EAAA,MAAC8mB,IAAa;IACjBC,cAjGmB,CAACC,CAAD,EAAOC,CAAP,EAAahhB,CAAb,KACZkgB,EAAoBvL,EAASoM,EAAKpT,QAALoT,CAAc/gB,CAAd+gB,CAATpM,EAAkCjH,WAAlCiH,EAApBuL,EAAqEvL,EAASqM,EAAKrT,QAALqT,CAAchhB,CAAdghB,CAATrM,EAAkCjH,WAAlCiH,EAArEuL,CA+FU;IAEjBe,2BA9FgC,CAACF,CAAD,EAAOC,CAAP,EAAahhB,CAAb,KACzBkgB,EAAoBvL,EAASoM,EAAKpT,QAALoT,CAAc/gB,CAAd+gB,CAATpM,CAApBuL,EAAuDvL,EAASqM,EAAKrT,QAALqT,CAAchhB,CAAdghB,CAATrM,CAAvDuL,CA2FU;IAGjBgB,MAzFW,CAACH,CAAD,EAAOC,CAAP,EAAahhB,CAAb,KACJ+f,EAAapL,EAASoM,EAAKpT,QAALoT,CAAc/gB,CAAd+gB,CAATpM,EAAkCjH,WAAlCiH,EAAboL,EAA8DpL,EAASqM,EAAKrT,QAALqT,CAAchhB,CAAdghB,CAATrM,EAAkCjH,WAAlCiH,EAA9DoL,CAqFU;IAIjBoB,mBApFwB,CAACJ,CAAD,EAAOC,CAAP,EAAahhB,CAAb,KACjB+f,EAAapL,EAASoM,EAAKpT,QAALoT,CAAc/gB,CAAd+gB,CAATpM,CAAboL,EAAgDpL,EAASqM,EAAKrT,QAALqT,CAAchhB,CAAdghB,CAATrM,CAAhDoL,CA+EU;IAKjBqB,UAjFe,CAACL,CAAD,EAAOC,CAAP,EAAahhB,CAAb,KACR+f,EAAagB,EAAKpT,QAALoT,CAAc/gB,CAAd+gB,EAAwBM,OAAxBN,EAAbhB,EAAgDiB,EAAKrT,QAALqT,CAAchhB,CAAdghB,EAAwBK,OAAxBL,EAAhDjB,CA2EU;IAMjBuB,OA9EY,CAACP,CAAD,EAAOC,CAAP,EAAahhB,CAAb,KACL+f,EAAagB,EAAKpT,QAALoT,CAAc/gB,CAAd+gB,CAAbhB,EAAsCiB,EAAKrT,QAALqT,CAAchhB,CAAdghB,CAAtCjB;EAuEU,CAAd;EAAA,MAUCwB,IAAU;IACdzc,iBAAiBC,MACR;MACLyc,SAAS,EADJ;MACI,GACNzc;IAFE,CADQA,CADH;IAOdF,qBAAqB,OACZ;MACL4c,WAAW;IADN,CADY,CAPP;IAYdjc,mBAAmBzM,MACV;MACL2oB,iBAAiB7oB,EAAiB,SAAjBA,EAA4BE,CAA5BF,CADZ;MAEL8oB,kBAAkBpa,KACTA,EAAEqa;IAHN,CADU7oB,CAZL;IAoBd8C,cAAc,CAACe,CAAD,EAAS7D,CAAT,MACL;MACL8oB,kBAAkB;QAChB,MAAMC,IAAY/oB,EAASia,mBAATja,GAA+BwS,QAA/BxS,CAAwCgpB,KAAxChpB,CAA8C,EAA9CA,CAAlB;QACA,IAAIipB,KAAW,CAAf;;QAEA,KAAK,MAAMxW,CAAX,IAAkBsW,CAAlB,EAA6B;UAC3B,MAAM7R,IAAe,QAAPzE,CAAO,GAAPA,KAAc,CAAP,GAAgBA,EAAImC,QAAJnC,CAAa5O,EAAON,EAApBkP,CAArC;UAEA,IAA8C,oBAA1CxN,OAAO4X,SAAP5X,CAAiB2W,QAAjB3W,CAA0B6X,IAA1B7X,CAA+BiS,CAA/BjS,CAAJ,EACE,OAAO6iB,EAAWO,QAAlB;UAGF,IAAqB,mBAAVnR,CAAU,KACnB+R,KAAW,CAAXA,EAEI/R,EAAM/D,KAAN+D,CAAYoQ,CAAZpQ,EAAiClW,MAAjCkW,GAA0C,CAH3B,CAArB,EAII,OAAO4Q,EAAWC,YAAlB;QAKN;;QAAA,OAAIkB,IACKnB,EAAWK,IADhBc,GAIGnB,EAAWS,KAJlB;MAIkBA,CAzBf;MA2BLW,gBAAgB;QACd,MAAMjS,IAAWjX,EAASia,mBAATja,GAA+BwS,QAA/BxS,CAAwC,CAAxCA,CAAjB;QAGA,OAAqB,oBAFK,QAAZiX,CAAY,GAAZA,KAAmB,CAAP,GAAgBA,EAASrC,QAATqC,CAAkBpT,EAAON,EAAzB0T,CAErB,IACZ,KADY,GAId,MAJP;MAIO,CAnCJ;MAqCLkS,cAAc;QACZ,IAAIjmB,CAAJ;QAEA,MAAMkmB,IAAgBppB,EAASoE,OAATpE,CAAiB8nB,UAAvC;QAEA,KAAKjkB,CAAL,EACE,MAAM,IAAID,KAAJ,EAAN;QAGF,OAAOzD,EAAW0D,EAAOd,SAAPc,CAAiB6kB,SAA5BvoB,IAAyC0D,EAAOd,SAAPc,CAAiB6kB,SAA1DvoB,GAAqG,WAA/B0D,EAAOd,SAAPc,CAAiB6kB,SAAc,GAAS7kB,EAAOilB,gBAAPjlB,EAAT,GAA4H,SAAtFX,IAAwB,QAAjBkmB,CAAiB,GAAjBA,KAAwB,CAAP,GAAgBA,EAAcvlB,EAAOd,SAAPc,CAAiB6kB,SAA/BU,CAA8C,IAAOlmB,CAAP,GAAc4kB,EAAWjkB,EAAOd,SAAPc,CAAiB6kB,SAA5BZ,CAAtP;MAAkRY,CA9C/Q;MAgDLW,eAAe,CAACC,CAAD,EAAOC,CAAP,KAAOA;QASpBvpB,EAASwpB,UAATxpB,CAAoBE;UAClB,IAAIuN,CAAJ,EAAWgc,CAAX,EAAkC3b,CAAlC,EAAyD0J,CAAzD;UAGA,MAAMkS,IAAyB,QAAPxpB,CAAO,GAAPA,KAAc,CAAP,GAAgBA,EAAIgH,IAAJhH,CAASE,KAAKA,EAAEmD,EAAFnD,KAASyD,EAAON,EAA9BrD,CAA/C;UAAA,MACMypB,IAAuB,QAAPzpB,CAAO,GAAPA,KAAc,CAAP,GAAgBA,EAAImN,SAAJnN,CAAcE,KAAKA,EAAEmD,EAAFnD,KAASyD,EAAON,EAAnCrD,CAD7C;UAAA,MAEM0pB,IAAiB,QAAON,CAF9B;UAGA,IAEIO,CAFJ;UAAA,IAAIC,IAAa,EAAjB;UAMID,IAFAhmB,EAAOkmB,eAAPlmB,MAA4B0lB,CAA5B1lB,GACE6lB,IACW,QADXA,GAGW,KAJb7lB,GAQS,QAAP3D,CAAO,IAAQA,EAAIc,MAAZ,IAAsB2oB,MAAkBzpB,EAAIc,MAAJd,GAAa,CAArD,GACI,SADJ,GAEAwpB,IACI,QADJA,GAGI,SAXbG;UAeJ,MAAMG,IAAuJ,SAAtIvc,IAAoE,SAA3Dgc,IAAwB5lB,EAAOd,SAAPc,CAAiBmmB,aAAkB,IAAOP,CAAP,GAA+BzpB,EAASoE,OAATpE,CAAiBgqB,aAAkB,IAAOvc,CAAP,GAA2C,WAA5B5J,EAAOqlB,cAAPrlB,EAA5K;UAWA,IATmB,aAAfgmB,CAAe,IACgD,SAAlE/b,IAAwB9N,EAASoE,OAATpE,CAAiBiqB,oBAAyB,KAAzBA,CAAgCnc,CADvD,IAElB8b,CAFkB,IAGnBL,KAAyE,SAAhE/R,IAAyBxX,EAASoE,OAATpE,CAAiBkqB,iBAAsB,CAAzEX,IAAmDW,CAA6B1S,CAH7D,KAIA,QAAnBkS,CAAmB,IAAQA,EAAgBJ,IAAxB,GAChBU,CADgB,GAChBA,CAAgBA,CALA,MAMjBH,IAAa,QANI,GASA,cAAfA,CAAJ,EACEC,IAAa,CAAC;YACZvmB,IAAIM,EAAON,EADC;YAEZ+lB,MAAMM,IAAiBN,CAAjBM,GAAiBN,EAASU;UAFpB,CAAD,CAAbF,CADF,KAKO,IAAmB,UAAfD,CAAe,IAAgB,QAAP3pB,CAAT,IAAwBA,EAAIc,MAA/C,EAAuD;YAC5D,IAAImpB,CAAJ;YAEAL,IAAa,IAAI5pB,CAAJ,EAAS;cACpBqD,IAAIM,EAAON,EADS;cAEpB+lB,MAAMM,IAAiBN,CAAjBM,GAAiBN,EAASU;YAFZ,CAAT,CAAbF,EAKAA,EAAWhL,MAAXgL,CAAkB,CAAlBA,EAAqBA,EAAW9oB,MAAX8oB,IAAwF,SAAlEK,IAAwBnqB,EAASoE,OAATpE,CAAiBoqB,oBAAyB,IAAOD,CAAP,GAA+Bxe,OAAOC,gBAA9Hke,CAArBA,CALAA;UAKmJle,CAR9I,MASmB,aAAfie,CAAe,IAAmB,QAAP3pB,CAAZ,IAA2BA,EAAIc,MAA/B,GAExB8oB,IAAa5pB,EAAI6F,GAAJ7F,CAAQE,KACfA,EAAEmD,EAAFnD,KAASyD,EAAON,EAAhBnD,GACK,KAAKA,CAAL;YACLkpB,MAAMM,IAAiBN,CAAjBM,GAAiBN,EAA4B,QAAnBI,CAAmB,IAAQA,EAAgBJ,IAApDA;UADlB,CADLlpB,GAMGA,CAPIF,CAFW,GAWA,aAAf2pB,CAAe,IAAmB,QAAP3pB,CAAZ,IAA2BA,EAAIc,MAA/B,KACxB8oB,IAAa5pB,EAAIiH,MAAJjH,CAAWE,KAAKA,EAAEmD,EAAFnD,KAASyD,EAAON,EAAhCrD,CADW,CAXA;UAe1B,OAAO4pB,CAAP;QAAOA,CApET9pB;MAoES8pB,CA7HN;MAgILO,YAAY;QACV,IAAIxc,CAAJ,EAA2BiK,CAA3B;QAEA,QAAoE,SAA3DjK,IAAwBhK,EAAOd,SAAPc,CAAiBymB,aAAkB,KAAOzc,CAA3E,MAA0K,SAA5DiK,IAAyB9X,EAASoE,OAATpE,CAAiBsqB,aAAkB,KAAOxS,CAAjL,KAAiLA,EAAoCjU,EAAOP,UAA5N;MAA4NA,CAnIzN;MAqILymB,iBAAiB;QACf,IAAI3a,CAAJ,EAAWyI,CAAX;QAEA,OAAoJ,SAA5IzI,IAAuE,SAA9DyI,IAAyBhU,EAAOd,SAAPc,CAAiB0mB,eAAoB,IAAO1S,CAAP,GAAgC7X,EAASoE,OAATpE,CAAiBuqB,eAAoB,IAAOnb,CAAP,GAAOA,EAAUvL,EAAOP,UAA5K;MAA4KA,CAxIzK;MA0ILknB,aAAa;QACX,IAAIC,CAAJ;QAEA,MAAMC,IAAsE,SAAxDD,IAAwBzqB,EAASyG,QAATzG,GAAoByoB,OAAY,IAAZA,KAAmB,CAAP,GAAgBgC,EAAsBvjB,IAAtBujB,CAA2BrqB,KAAKA,EAAEmD,EAAFnD,KAASyD,EAAON,EAAhDknB,CAA5F;QACA,SAAQC,CAAR,KAA6BA,EAAWpB,IAAXoB,GAAkB,MAAlBA,GAA2B,KAAxD;MAAwD,CA9IrD;MAgJLC,cAAc;QACZ,IAAIC,CAAJ,EAA4BC,CAA5B;QAEA,OAAyK,SAAjKD,IAAmF,SAAzDC,IAAyB7qB,EAASyG,QAATzG,GAAoByoB,OAAY,IAAZA,KAAmB,CAAP,GAAgBoC,EAAuBxd,SAAvBwd,CAAiCzqB,KAAKA,EAAEmD,EAAFnD,KAASyD,EAAON,EAAtDsnB,CAA8D,IAAOD,CAAP,GAAOA,CAA0B,CAA1M;MAA0M,CAnJvM;MAqJLE,cAAc;QAEZ9qB,EAASwpB,UAATxpB,CAAoBE,KAAc,QAAPA,CAAO,IAAQA,EAAIc,MAAZ,GAAqBd,EAAIiH,MAAJjH,CAAWE,KAAKA,EAAEmD,EAAFnD,KAASyD,EAAON,EAAhCrD,CAArB,GAA2D,EAA7FF;MAA6F,CAvJ1F;MAyJL+qB,yBAAyB;QACvB,MAAMC,IAAUnnB,EAAOwmB,UAAPxmB,EAAhB;QACA,OAAO2K;UACAwc,MACQ,QAAbxc,EAAEC,OAAW,IAAgBD,EAAEC,OAAFD,EAAhB,EACW,QAAxB3K,EAAOwlB,aAAiB,IAAgBxlB,EAAOwlB,aAAPxlB,CAAOwlB,KAAc3lB,CAArBG,EAAqBH,EAAWG,EAAOkmB,eAAPlmB,EAAXH,KAA2E,QAArC1D,EAASoE,OAATpE,CAAiB4oB,gBAAoB,GAApBA,KAA2B,CAAP,GAAgB5oB,EAASoE,OAATpE,CAAiB4oB,gBAAjB5oB,CAAkCwO,CAAlCxO,CAA3F0D,CAArBG,CAFnCmnB;QAEqLxc,CAH5L;MAG4LA;IA9JzL,CADK,CApBA;IAwLdnI,gBAAgBrG,MACP;MACLwpB,YAAY5pB,KAA+C,QAApCI,EAASoE,OAATpE,CAAiB2oB,eAAmB,GAAnBA,KAA0B,CAAP,GAAgB3oB,EAASoE,OAATpE,CAAiB2oB,eAAjB3oB,CAAiCJ,CAAjCI,CADtE;MAELirB,cAAchb;QACZ,IAAIC,CAAJ,EAA2BG,CAA3B;QAEArQ,EAASwpB,UAATxpB,CAAoBiQ,IAAe,EAAfA,GAAoJ,SAA/HC,IAA4E,SAAnDG,IAAyBrQ,EAASmQ,YAAiB,IAAjBA,KAAwB,CAAP,GAAgBE,EAAuBoY,OAAY,IAAOvY,CAAP,GAA+B,EAAvMlQ;MAAuM,CALpM;MAOLkrB,sBAAsB,MAAMlrB,EAASia,mBAATja,EAPvB;MAQLod,mBAAmB,QACZpd,EAASmrB,kBADG,IACmBnrB,EAASoE,OAATpE,CAAiBod,iBADpC,KAEfpd,EAASmrB,kBAATnrB,GAA8BA,EAASoE,OAATpE,CAAiBod,iBAAjBpd,CAAmCA,CAAnCA,CAFf,GAKbA,EAASoE,OAATpE,CAAiBorB,aAAjBprB,IAAiBorB,CAAkBprB,EAASmrB,kBAA5CnrB,GACKA,EAASkrB,oBAATlrB,EADLA,GAIGA,EAASmrB,kBAATnrB,EATU;IARd,CADOA;EAxLF,CAVX;EAAA,MA2NCqrB,IAAa;IACjBtf,iBAAiBC,MACR;MACLsf,kBAAkB,EADb;MACa,GACftf;IAFE,CADQA,CADA;IAOjBS,mBAAmBzM,MACV;MACLurB,0BAA0BzrB,EAAiB,kBAAjBA,EAAqCE,CAArCF;IADrB,CADUE,CAPF;IAYjB8C,cAAc,CAACe,CAAD,EAAS7D,CAAT,MACL;MACLwrB,kBAAkBtU;QACZrT,EAAO4nB,UAAP5nB,MACF7D,EAAS0rB,mBAAT1rB,CAA6BE,MAAQ,KAAKA,CAAL;UACnC,CAAC2D,EAAON,EAAR,GAAsB,QAAT2T,CAAS,GAAOA,CAAP,GAAOA,CAASrT,EAAO8G,YAAP9G;QADH,CAAR3D,CAA7BF,CADE6D;MAE6C8G,CAJ9C;MAQLA,cAAc;QACZ,IAAIyN,CAAJ,EAA2BC,CAA3B;QAEA,OAAyJ,SAAjJD,IAA2F,SAAlEC,IAAyBrY,EAASyG,QAATzG,GAAoBsrB,gBAAqB,IAArBA,KAA4B,CAAP,GAAgBjT,EAAuBxU,EAAON,EAA9B8U,CAAsC,KAAOD,CAAhK;MAAgKA,CAX7J;MAaLqT,YAAY;QACV,IAAI5d,CAAJ,EAA2BC,CAA3B;QAEA,QAAmE,SAA1DD,IAAwBhK,EAAOd,SAAPc,CAAiB8nB,YAAiB,KAAO9d,CAA1E,MAAuK,SAA1DC,IAAwB9N,EAASoE,OAATpE,CAAiB2rB,YAAiB,KAAO7d,CAA9K;MAA8KA,CAhB3K;MAkBL8d,4BAA4B,MACnBpd;QACsB,QAA3B3K,EAAO2nB,gBAAoB,IAAgB3nB,EAAO2nB,gBAAP3nB,CAAwB2K,EAAEgX,MAAFhX,CAASiX,OAAjC5hB,CAAhB;MAAiD4hB;IApB3E,CADK,CAZG;IAsCjBhS,WAAW,CAAChB,CAAD,EAAMzS,CAAN,MACF;MACL6iB,qBAAqB5hB,EAAK,MAAM,CAACwR,EAAIoZ,WAAJpZ,EAAD,EAAoBzS,EAASyG,QAATzG,GAAoBsrB,gBAAxC,CAAXrqB,EAAsE6qB,KAClFA,EAAM3kB,MAAN2kB,CAAapO,KAAQA,EAAK7Z,MAAL6Z,CAAY/S,YAAZ+S,EAArBoO,CADY7qB,EAElB;QACDlB,KAA8C,yBAD7C;QAEDyB,OAAO;UACL,IAAI2C,CAAJ;UAEA,OAA8D,SAAtDA,IAAwBnE,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOF,CAAP,GAA+BnE,EAASoE,OAATpE,CAAiBgjB,SAA9G;QAA8GA;MAL/G,CAFkB/hB,CADhB;MAWL8qB,iBAAiB9qB,EAAK,MAAM,CAACwR,EAAIwQ,mBAAJxQ,EAAD,EAA4BA,EAAImQ,qBAAJnQ,EAA5B,EAAyDA,EAAIyQ,oBAAJzQ,EAAzD,CAAXxR,EAAiG,CAAC0F,CAAD,EAAOkD,CAAP,EAAejD,CAAf,KAAyB,IAAID,CAAJ,EAAIA,GAASkD,CAAb,EAAaA,GAAWjD,CAAxB,CAA1H3F,EAA0J;QACzKlB,MAAK,CADoK;QAEzKyB,OAAO;UACL,IAAIoD,CAAJ;UAEA,OAA+D,SAAvDA,IAAyB5E,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOO,CAAP,GAAgC5E,EAASoE,OAATpE,CAAiBgjB,SAAhH;QAAgHA;MALuD,CAA1J/hB;IAXZ,CADE,CAtCM;IA4DjBoF,gBAAgBrG;MACd,MAAMgsB,IAA2B,CAACjsB,CAAD,EAAMksB,CAAN,KACxBhrB,EAAK,MAAM,CAACgrB,GAAD,EAAeA,IAAa9kB,MAAb8kB,CAAoB7rB,KAAKA,EAAEuK,YAAFvK,EAAzB6rB,EAA2ClmB,GAA3CkmB,CAA+C7rB,KAAKA,EAAEmD,EAAtD0oB,EAA0DnhB,IAA1DmhB,CAA+D,GAA/DA,CAAf,CAAXhrB,EAAgG8C,KAC9FA,EAAQoD,MAARpD,CAAe3D,KAAuB,QAAlBA,EAAEuK,YAAgB,GAAhBA,KAAuB,CAAP,GAAgBvK,EAAEuK,YAAFvK,EAAtD2D,CADF9C,EAEJ;QACDlB,MADC;QAEDyB,OAAO;UACL,IAAIoG,CAAJ;UAEA,OAA+D,SAAvDA,IAAyB5H,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOuD,CAAP,GAAgC5H,EAASoE,OAATpE,CAAiBsE,YAAhH;QAAgHA;MALjH,CAFIrD,CADT;;MAaA,OAAO;QACLirB,uBAAuBF,EAAyB,uBAAzBA,EAAkD,MAAMhsB,EAASmsB,iBAATnsB,EAAxDgsB,CADlB;QAELxlB,uBAAuBwlB,EAAyB,uBAAzBA,EAAkD,MAAMhsB,EAAS2Z,iBAAT3Z,EAAxDgsB,CAFlB;QAGL7e,2BAA2B6e,EAAyB,2BAAzBA,EAAsD,MAAMhsB,EAASyjB,kBAATzjB,EAA5DgsB,CAHtB;QAIL5e,4BAA4B4e,EAAyB,4BAAzBA,EAAuD,MAAMhsB,EAAS0jB,mBAAT1jB,EAA7DgsB,CAJvB;QAKLI,6BAA6BJ,EAAyB,6BAAzBA,EAAwD,MAAMhsB,EAAS2jB,oBAAT3jB,EAA9DgsB,CALxB;QAMLN,qBAAqB9rB,KAAwD,QAA7CI,EAASoE,OAATpE,CAAiBurB,wBAA4B,GAA5BA,KAAmC,CAAP,GAAgBvrB,EAASoE,OAATpE,CAAiBurB,wBAAjBvrB,CAA0CJ,CAA1CI,CANxF;QAOLqsB,uBAAuBpc;UACrB,IAAIC,CAAJ;UAEAlQ,EAAS0rB,mBAAT1rB,CAA6BiQ,IAAe,EAAfA,GAAwF,SAAnEC,IAAwBlQ,EAASmQ,YAATnQ,CAAsBsrB,gBAAqB,IAAOpb,CAAP,GAA+B,EAApJlQ;QAAoJ,CAVjJ;QAYLssB,yBAAyBpV;UACvB,IAAIqV,CAAJ;UAEArV,IAA4B,SAAnBqV,IAASrV,CAAU,IAAOqV,CAAP,GAAOA,CAAUvsB,EAASwsB,sBAATxsB,EAA7CkX,EACAlX,EAAS0rB,mBAAT1rB,CAA6BA,EAAS2Z,iBAAT3Z,GAA6B8E,MAA7B9E,CAAoC,CAAC+E,CAAD,EAAMlB,CAAN,MAAkB,KAAKkB,CAAL;YACjF,CAAClB,EAAON,EAAR,GAAc2T,OAA+B,QAArBrT,EAAO4nB,UAAc,IAAQ5nB,EAAO4nB,UAAP5nB,EAAvCqT;UADmE,CAAlB,CAApClX,EAEzB,EAFyBA,CAA7BA,CADAkX;QAGI,CAlBD;QAoBLsV,wBAAwB,OAAOxsB,EAAS2Z,iBAAT3Z,GAA6B4B,IAA7B5B,CAAkC6D,OAAmC,QAAvBA,EAAO8G,YAAgB,IAAQ9G,EAAO8G,YAAP9G,EAA3CA,CAAlC7D,CApB1B;QAqBLysB,yBAAyB,MAAMzsB,EAAS2Z,iBAAT3Z,GAA6B4B,IAA7B5B,CAAkC6D,KAAiC,QAAvBA,EAAO8G,YAAgB,GAAhBA,KAAuB,CAAP,GAAgB9G,EAAO8G,YAAP9G,EAAnF7D,CArB1B;QAsBL0sB,sCAAsC,MAC7Ble;UACL,IAAI8X,CAAJ;UAEAtmB,EAASssB,uBAATtsB,CAAyD,SAAvBsmB,IAAU9X,EAAEgX,MAAW,IAAXA,KAAkB,CAAP,GAAgBc,EAAQb,OAAjFzlB;QAAiFylB;MA1BhF,CAAP;IA0BuFA;EApGxE,CA3Nd;EAAA,MAsUCkH,IAAW,CAACvmB,CAAD,EAAUilB,CAAV,EAAsBlN,CAAtB,EAAgCsD,CAAhC,EAAyCtL,CAAzC,EAAkDqS,CAAlD,EAA2DjN,CAA3D,EAAqE/J,CAArE,EAAgFuN,CAAhF,EAA4F6E,CAA5F,EAA0G/X,CAA1G,CAtUZ;;EAwUL,SAAS+gB,CAAT,CAA6BxoB,CAA7B,EAA6BA;IAC3B,IAAIyoB,CAAJ;IAAIA,CAEAzoB,EAAQC,QAARD,IAAoBA,EAAQ0c,UAF5B+L,KAGFnqB,QAAQC,IAARD,CAAa,4BAAbA,CAHEmqB;IAMJ,IAAI7sB,IAAW;MACb6E,WAAW8nB;IADE,CAAf;;IAIA,MAAMG,IAAiB9sB,EAAS6E,SAAT7E,CAAmB8E,MAAnB9E,CAA0B,CAAC+E,CAAD,EAAMC,CAAN,KACxCC,OAAOC,MAAPD,CAAcF,CAAdE,EAAgD,QAA7BD,EAAQyH,iBAAqB,GAArBA,KAA4B,CAAP,GAAgBzH,EAAQyH,iBAARzH,CAA0BhF,CAA1BgF,CAAhEC,CADcjF,EAEpB,EAFoBA,CAAvB;;IAeA,IAAImQ,IAAe,MACqC,SAAjD0c,IAAwBzoB,EAAQ+L,YAAiB,IAAO0c,CAAP,GAA+B,EADpE;IAAA,CAAnB;;IAIA7sB,EAAS6E,SAAT7E,CAAmBY,OAAnBZ,CAA2BgF;MACzB,IAAI+nB,CAAJ;MAEA5c,IAA6H,SAA7G4c,IAAmD,QAA3B/nB,EAAQ+G,eAAmB,GAAnBA,KAA0B,CAAP,GAAgB/G,EAAQ+G,eAAR/G,CAAwBmL,CAAxBnL,CAA0C,IAAO+nB,CAAP,GAA+B5c,CAA5JA;IAA4JA,CAH9JnQ;;IAMA,MAAM8R,IAAS,EAAf;IACA,IAAIkb,KAAgB,CAApB;IACA,MAAMC,IAAe;MACnBpoB,WAAW8nB,CADQ;MAEnBvoB,SAAS,KAAK0oB,CAAL;QAAKA,GACT1oB;MADI,CAFU;MAKnB+L,eALmB;MAMnB8B,QAAQib;QACNpb,EAAOhR,IAAPgR,CAAYob,CAAZpb,GAEKkb,MACHA,KAAgB,CAAhBA,EAGAG,QAAQC,OAARD,GAAkBE,IAAlBF,CAAuB;UACrB,OAAOrb,EAAO9Q,MAAd,GACE8Q,EAAO8M,KAAP9M;;UAGFkb,KAAgB,CAAhBA;QAAgB,CALlBG,EAMGG,KANHH,CAMSI,KAASC,WAAW;UAC3B,MAAMD,CAAN;QAAMA,CADUC,CANlBL,CAJGH,CAFLlb;MAaUyb,CApBO;MAwBnBE,OAAO;QACLztB,EAASC,QAATD,CAAkBA,EAASmQ,YAA3BnQ;MAA2BmQ,CAzBV;MA2BnBud,YAAY9tB;QACV,MAAM+tB,IAAahuB,EAAiBC,CAAjBD,EAA0BK,EAASoE,OAAnCzE,CAAnB;;QACAK,EAASoE,OAATpE,GApDiBoE,MACfpE,EAASoE,OAATpE,CAAiB4tB,YAAjB5tB,GACKA,EAASoE,OAATpE,CAAiB4tB,YAAjB5tB,CAA8B8sB,CAA9B9sB,EAA8CoE,CAA9CpE,CADLA,GAIG,KAAK8sB,CAAL;UAAKA,GACP1oB;QADE,CALYA,EAoDeupB,CApDfvpB,CAoDjBpE;MAAgC2tB,CA7Bf;MA+BnB1nB,SAAS,CAAC8X,CAAD,EAAWtC,CAAX,KACgC,qBAA5Bzb,EAASoE,OAATpE,CAAiB6tB,MAAW,GAC9B7tB,EAASoE,OAATpE,CAAiB6tB,MAAjB7tB,CAAwB+d,CAAxB/d,EAAkCyb,CAAlCzb,CAD8B,GAIf,qBAAb+d,CAAa,GACfA,EAAStC,CAATsC,CADe,GAIjBA,CAxCU;MA0CnBtX,UAAU,MACDzG,EAASoE,OAATpE,CAAiBgM,KA3CP;MA6CnB/L,UAAUL;QAC0B,QAAlCI,EAASoE,OAATpE,CAAiB8tB,aAAiB,IAAgB9tB,EAASoE,OAATpE,CAAiB8tB,aAAjB9tB,CAA+BJ,CAA/BI,CAAhB;MAA+CJ,CA9ChE;MAgDnBmuB,WAAW,CAACtb,CAAD,EAAM3Q,CAAN,EAAamB,CAAb,KAAaA;QACtB,IAAI8Q,CAAJ;QAEA,OAA+H,SAAvHA,IAAqD,QAA7B/T,EAASoE,OAATpE,CAAiBguB,QAAY,GAAZA,KAAmB,CAAP,GAAgBhuB,EAASoE,OAATpE,CAAiBguB,QAAjBhuB,CAA0ByS,CAA1BzS,EAA+B8B,CAA/B9B,EAAsCiD,CAAtCjD,CAAkD,IAAO+T,CAAP,GAA+B,MAAM9Q,IAAS,CAACA,EAAOM,EAAR,EAAYzB,CAAZ,EAAmBgJ,IAAnB,CAAwB,GAAxB,CAAT7H,GAAwCnB,CAA9C,CAA9J;MAA4MA,CAnD3L;MAqDnBgV,iBAAiB,OACV9W,EAASiuB,gBAATjuB,KACHA,EAASiuB,gBAATjuB,GAA4BA,EAASoE,OAATpE,CAAiB8W,eAAjB9W,CAAiCA,CAAjCA,CADzBA,GAIEA,EAASiuB,gBAATjuB,EALQ,CArDE;MA8DnBuS,aAAa,MACJvS,EAASqhB,qBAATrhB,EA/DU;MAiEnBumB,QAAQhjB;QACN,MAAMkP,IAAMzS,EAASuS,WAATvS,GAAuBiT,QAAvBjT,CAAgCuD,CAAhCvD,CAAZ;QAEA,KAAKyS,CAAL,EAKE,MAAM,IAAI7O,KAAJ,EAAN;QAGF,OAAO6O,CAAP;MAAOA,CA5EU;MA8EnBpP,sBAAsBpC,EAAK,MAAM,CAACjB,EAASoE,OAATpE,CAAiBoD,aAAlB,CAAXnC,EAA6CmC;QACjE,IAAI8qB,CAAJ;QAGA,OADA9qB,IAAoD,SAAnC8qB,IAAiB9qB,CAAkB,IAAO8qB,CAAP,GAAwB,EAA5E9qB,EACO;UACLK,QAAQgY,KAASA,EAAMhY,MAANgY,CAAa5X,MAAb4X,CAAoBlY,EADhC;UAEL4C,QAAQsV,KAASA,EAAMhY,MAANgY,CAAa5X,MAAb4X,CAAoBlY,EAFhC;UAGLma,MAAMjC;YACJ,IAAIC,CAAJ,EAA2BC,CAA3B;YAEA,OAAmK,SAA3JD,IAAgE,SAAvCC,IAAkBF,EAAM7G,QAAN6G,EAAqB,KAA4C,QAA5BE,EAAgBC,QAAhC,GAAgCA,KAAzB,CAAP,GAA4DD,EAAgBC,QAAhBD,EAA+B,IAAOD,CAAP,GAA+B,IAAlM;UAAkM,CAN/L;UAM+L,GAEjM1b,EAAS6E,SAAT7E,CAAmB8E,MAAnB9E,CAA0B,CAAC+E,CAAD,EAAMC,CAAN,KACpBC,OAAOC,MAAPD,CAAcF,CAAdE,EAAkD,QAA/BD,EAAQ8G,mBAAuB,GAAvBA,KAA8B,CAAP,GAAgB9G,EAAQ8G,mBAAR9G,EAAlEC,CADNjF,EAEA,EAFAA,CARE;UAUF,GACAoD;QAXE,CAAP;MAWKA,CAfenC,EAiBnB;QACDO,OAAO;UACL,IAAI2C,CAAJ;UAEA,OAA8D,SAAtDA,IAAwBnE,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOF,CAAP,GAA+BnE,EAASoE,OAATpE,CAAiBsE,YAA9G;QAA8GA,CAJ/G;QAMDvE,MAAK;MANJ,CAjBmBkB,CA9EH;MAuGnBktB,gBAAgB,MAAMnuB,EAASoE,OAATpE,CAAiB+D,OAvGpB;MAwGnBwC,eAAetF,EAAK,MAAM,CAACjB,EAASmuB,cAATnuB,EAAD,CAAXiB,EAAwCmtB;QACrD,MAAMC,IAAiB,UAAUD,CAAV,EAAsBnrB,CAAtB,EAA8BD,CAA9B,EAA8BA;UAKnD,YAJc,CAId,KAJIA,CAIJ,KAHEA,IAAQ,CAGV,GAAOorB,EAAWroB,GAAXqoB,CAAerrB;YACpB,MAAMc,IAASf,EAAa9C,CAAb8C,EAAuBC,CAAvBD,EAAkCE,CAAlCF,EAAyCG,CAAzCH,CAAf;YAEA,OADAe,EAAOE,OAAPF,GAAiBd,EAAUgB,OAAVhB,GAAoBsrB,EAAetrB,EAAUgB,OAAzBsqB,EAAkCxqB,CAAlCwqB,EAA0CrrB,IAAQ,CAAlDqrB,CAApBtrB,GAA2E,EAA5Fc,EACOA,CAAP;UAAOA,CAHFuqB,CAAP;QAGSvqB,CARX;;QAYA,OAAOwqB,EAAeD,CAAfC,CAAP;MAAsBD,CAbTntB,EAcZ;QACDlB,MAAK,CADJ;QAEDyB,OAAO;UACL,IAAIoD,CAAJ;UAEA,OAA+D,SAAvDA,IAAyB5E,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOO,CAAP,GAAgC5E,EAASoE,OAATpE,CAAiBsE,YAAhH;QAAgHA;MALjH,CAdYrD,CAxGI;MA8HnBkrB,mBAAmBlrB,EAAK,MAAM,CAACjB,EAASuG,aAATvG,EAAD,CAAXiB,EAAuC4F,KACjDA,EAAW3C,OAAX2C,CAAmBhD,KACjBA,EAAOG,cAAPH,EADFgD,CADU5F,EAIhB;QACDlB,MAAK,CADJ;QAEDyB,OAAO;UACL,IAAIoG,CAAJ;UAEA,OAA+D,SAAvDA,IAAyB5H,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOuD,CAAP,GAAgC5H,EAASoE,OAATpE,CAAiBsE,YAAhH;QAAgHA;MALjH,CAJgBrD,CA9HA;MA0InBqtB,wBAAwBrtB,EAAK,MAAM,CAACjB,EAASmsB,iBAATnsB,EAAD,CAAXiB,EAA2CstB,KAC1DA,EAAYzpB,MAAZypB,CAAmB,CAACC,CAAD,EAAM3qB,CAAN,MACxB2qB,EAAI3qB,EAAON,EAAXirB,IAAiB3qB,CAAjB2qB,EACOA,CAFiB,CAAnBD,EAGJ,EAHIA,CADettB,EAKrB;QACDlB,MAAK,CADJ;QAEDyB,OAAO;UACL,IAAIuG,CAAJ;UAEA,OAA+D,SAAvDA,IAAyB/H,EAASoE,OAATpE,CAAiBqE,QAAa,IAAO0D,CAAP,GAAgC/H,EAASoE,OAATpE,CAAiBsE,YAAhH;QAAgHA;MALjH,CALqBrD,CA1IL;MAuJnB0Y,mBAAmB1Y,EAAK,MAAM,CAACjB,EAASuG,aAATvG,EAAD,EAA2BA,EAASwE,kBAATxE,EAA3B,CAAXiB,EAAsE,CAAC4F,CAAD,EAAapC,CAAb,KAEhFA,EADWoC,EAAW3C,OAAX2C,CAAmBhD,KAAUA,EAAOU,cAAPV,EAA7BgD,CACXpC,CAFUxD,EAGhB;QACDlB,MAAK,CADJ;QAEDyB,OAAO;UACL,IAAI2G,CAAJ;UAEA,OAA+D,SAAvDA,IAAyBnI,EAASoE,OAATpE,CAAiBqE,QAAa,IAAO8D,CAAP,GAAgCnI,EAASoE,OAATpE,CAAiBsE,YAAhH;QAAgHA;MALjH,CAHgBrD,CAvJA;MAkKnBqN,WAAWrH;QACT,MAAMpD,IAAS7D,EAASsuB,sBAATtuB,GAAkCiH,CAAlCjH,CAAf;;QAEA,KAAK6D,CAAL,EAKE,MAAM,IAAID,KAAJ,EAAN;QAGF,OAAOC,CAAP;MAAOA;IA7KU,CAArB;IAsLA,OANAoB,OAAOC,MAAPD,CAAcjF,CAAdiF,EAAwBgoB,CAAxBhoB,GAEAjF,EAAS6E,SAAT7E,CAAmBY,OAAnBZ,CAA2BgF,KAClBC,OAAOC,MAAPD,CAAcjF,CAAdiF,EAAkD,QAA1BD,EAAQqB,cAAkB,GAAlBA,KAAyB,CAAP,GAAgBrB,EAAQqB,cAARrB,CAAuBhF,CAAvBgF,CAAlEC,CADTjF,CAFAiF,EAMOjF,CAAP;EAIF;;EAAA,SAASyuB,CAAT,CAA4BrtB,CAA5B,EAA4BA;IAC1B,OAAO,MAAMstB,OAAYhrB,CAAZgrB,EAAYhrB,KAAWA,CAAvBgrB,EAAkCttB,CAAlCstB,CAAb;EAIF;;EAAA,SAASA,CAAT,CAAqBhhB,CAArB,EAAwBihB,CAAxB,EAA4BvqB,CAA5B,EAA4BA;IAC1B,MAAMwqB,IAAQ;MACZC,eAAUnrB,CADE;MAEZU,SAAoB,QAAXA,CAAW,GAAOA,CAAP,GAAiB;QACnCypB,QAAQ;UACN,MAAM,IAAIjqB,KAAJ,CAAU,EAAV,CAAN;QAAgB,CADV;MAD2B,CAFzB;MAQZkrB,YAAY,MAAMF,CARN;MASZG,kBAAkB,MAAMH,CATZ;MAUZI,mBAAmB,MAAMJ,CAVb;MAWZK,mBAAmB,MAAML,CAXb;MAYZlB,YAAYC,KAAce,EAAYhhB,CAAZghB,EAAeC,CAAfD,EAAmB,KAAKtqB,CAAL;QAAKA,GAC7CupB;MADwC,CAAnBe,CAZd;MAeZQ,qBAAqBrrB,MAAW,KAAKA,CAAL;QAC9BC,eAAe;MADe,CAAXD,CAfT;MAkBZsrB,aAAatrB,MAAW,KAAKA,CAAL;QACtBC,eAAe;MADO,CAAXD,CAlBD;MAqBZurB,kBAAkB,CAACC,CAAD,EAAWxrB,CAAX,KAAWA;QAOzB,IAAIyrB,CAAJ;QADF,IALAzrB,IAAS,KAAKA,CAAL;UACPC,eAAe,MADR;UAEPP,IAAIM,EAAON;QAFJ,CAATM,EAKwB,mBAAbwrB,CAAX,EAGE,OAAO,KAAKxrB,CAAL;UACLN,IAAgC,SAA3B+rB,IAAazrB,EAAON,EAAO,IAAO+rB,CAAP,GAAoBD,CAD/C;UAEL7rB,aAAa6rB;QAFR,CAAP;QAMF,IAAwB,qBAAbA,CAAX,EACE,OAAO,KAAKxrB,CAAL;UACLP,YAAY+rB;QADP,CAAP;QAKF,MAAM,IAAIzrB,KAAJ,CAAU,kBAAV,CAAN;MAAgB,CA1CN;MA4CZ2rB,eAAenrB,KAAWA;IA5Cd,CAAd;IA8CA,OAAOwqB,CAAP;EA2BG;;EAAA,MAACnb,IAAY,CAACzT,CAAD,EAAWuD,CAAX,EAAeisB,CAAf,EAAyBC,CAAzB,EAAmCzsB,CAAnC,EAA0CqR,CAA1C,KAA0CA;IAC1D,IAAI5B,IAAM;MACRlP,KADQ;MAERzB,OAAO2tB,CAFC;MAGRD,WAHQ;MAIRxsB,QAJQ;MAKR0sB,cAAc,EALN;MAMR9a,UAAU3N;QACR,IAAIwL,EAAIid,YAAJjd,CAAiBkd,cAAjBld,CAAgCxL,CAAhCwL,CAAJ,EACE,OAAOA,EAAIid,YAAJjd,CAAiBxL,CAAjBwL,CAAP;QAGF,MAAM5O,IAAS7D,EAASsO,SAATtO,CAAmBiH,CAAnBjH,CAAf;QAEA,OAAK6D,EAAOP,UAAPO,IAIL4O,EAAIid,YAAJjd,CAAiBxL,CAAjBwL,IAA6B5O,EAAOP,UAAPO,CAAkB4O,EAAI+c,QAAtB3rB,EAAgC4rB,CAAhC5rB,CAA7B4O,EACOA,EAAIid,YAAJjd,CAAiBxL,CAAjBwL,CALF5O,IAKmBoD,KALxB;MAAA,CAbM;MAoBRoN,SAAoB,QAAXA,CAAW,GAAOA,CAAP,GAAiB,EApB7B;MAqBRub,aAAa,MAAMtvB,EAAUmS,EAAI4B,OAAd/T,EAAuBF,KAAKA,EAAEiU,OAA9B/T,CArBX;MAsBRurB,aAAa5qB,EAAK,MAAM,CAACjB,EAAS2Z,iBAAT3Z,EAAD,CAAXiB,EAA2C0D,KAC/CA,EAAYoB,GAAZpB,CAAgBd,KAhD7B,UAAoB7D,CAApB,EAA8ByS,CAA9B,EAAmC5O,CAAnC,EAA2CoD,CAA3C,EAA2CA;QACzC,MAAMyW,IAAO;UACXna,IAAIkP,EAAIlP,EAAJkP,GAAS,GAATA,GAAe5O,EAAON,EADf;UAEXkP,MAFW;UAGX5O,SAHW;UAIX+Q,UAAU,MAAMnC,EAAImC,QAAJnC,CAAaxL,CAAbwL,CAJL;UAKXod,YAAY,MACHhsB,EAAOd,SAAPc,CAAiB6Z,IAAjB7Z,GAAwB7D,EAASiG,OAATjG,CAAiB6D,EAAOd,SAAPc,CAAiB6Z,IAAlC1d,EAAwC;YACrEA,WADqE;YAErE6D,SAFqE;YAGrE4O,MAHqE;YAIrEiL,MAAMA,CAJ+D;YAKrE9I,UAAU8I,EAAK9I;UALsD,CAAxC5U,CAAxB6D,GAMF;QAZI,CAAb;QAoBA,OAJA7D,EAAS6E,SAAT7E,CAAmBY,OAAnBZ,CAA2BgF;UACzBC,OAAOC,MAAPD,CAAcyY,CAAdzY,EAA0C,QAAtBD,EAAQyY,UAAc,GAAdA,KAAqB,CAAP,GAAgBzY,EAAQyY,UAARzY,CAAmB0Y,CAAnB1Y,EAAyBnB,CAAzBmB,EAAiCyN,CAAjCzN,EAAsChF,CAAtCgF,CAA1DC;QAAgGjF,CADlGA,EAEG,EAFHA,GAIO0d,CAAP;MA4BaD,CAjDf,CAiD0Bzd,CAjD1B,EAiDoCyS,CAjDpC,EAiDyC5O,CAjDzC,EAiDiDA,EAAON,EAjDxD,CAgDaoB,CADI1D,EAIV;QACDlB,MAAK,CADJ;QAEDyB,OAAO;UACL,IAAI2C,CAAJ;UAEA,OAA8D,SAAtDA,IAAwBnE,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOF,CAAP,GAA+BnE,EAASoE,OAATpE,CAAiBgjB,SAA9G;QAA8GA;MAL/G,CAJU/hB,CAtBL;MAkCR8V,wBAAwB9V,EAAK,MAAM,CAACwR,EAAIoZ,WAAJpZ,EAAD,CAAXxR,EAAgC6hB,KAC/CA,EAAShe,MAATge,CAAgB,CAAC0L,CAAD,EAAM9Q,CAAN,MACrB8Q,EAAI9Q,EAAK7Z,MAAL6Z,CAAYna,EAAhBirB,IAAsB9Q,CAAtB8Q,EACOA,CAFc,CAAhB1L,EAGJ,EAHIA,CADe7hB,EAKrB;QACDlB,KAA8C,2BAD7C;QAEDyB,OAAO;UACL,IAAIoD,CAAJ;UAEA,OAA+D,SAAvDA,IAAyB5E,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOO,CAAP,GAAgC5E,EAASoE,OAATpE,CAAiBgjB,SAAhH;QAAgHA;MALjH,CALqB/hB;IAlChB,CAAV;;IAiDA,KAAK,IAAI4f,IAAI,CAAb,EAAgBA,IAAI7gB,EAAS6E,SAAT7E,CAAmBgB,MAAvC,EAA+C6f,GAA/C,EAAoD;MAClD,MAAM7b,IAAUhF,EAAS6E,SAAT7E,CAAmB6gB,CAAnB7gB,CAAhB;MACAiF,OAAOC,MAAPD,CAAcwN,CAAdxN,EAA8B,QAAXD,CAAW,IAAqC,QAArBA,EAAQyO,SAAxB,GAAwBA,KAAjB,CAAP,GAAqDzO,EAAQyO,SAARzO,CAAkByN,CAAlBzN,EAAuBhF,CAAvBgF,CAAnFC;IAGF;;IAAA,OAAOwN,CAAP;EAAOA,CAvDJ;;EAsHL,SAASqd,EAAT,CAAoBtO,CAApB,EAA0BuO,CAA1B,EAAyC/vB,CAAzC,EAAyCA;IACvC,OAAIA,EAASoE,OAATpE,CAAiByW,kBAAjBzW,GAMN,UAAiCgwB,CAAjC,EAA+CC,CAA/C,EAA0DjwB,CAA1D,EAA0DA;MACxD,MAAMkwB,IAAsB,EAA5B;MAAA,MACMC,IAAsB,EAD5B;MAEA,IAAI1d,CAAJ,EACI2d,CADJ;;MAGA,MAAMC,IAAoB,UAAUL,CAAV,EAAwBhtB,CAAxB,EAAwBA;QAAAA,KAClC,CADkCA,KAC5CA,CAD4CA,KAE9CA,IAAQ,CAFsCA;QAKhD,MAAMwe,IAAO,EAAb;;QAEA,KAAK,IAAIX,IAAI,CAAb,EAAgBA,IAAImP,EAAahvB,MAAjC,EAAyC6f,GAAzC,EAA8C;UAC5C,IAAI3M,CAAJ;;UAIA,IAFAzB,IAAMud,EAAanP,CAAbmP,CAANvd,EAEoC,SAA/ByB,IAAezB,EAAI4B,OAAY,KAAQH,EAAalT,MAAzD,EAAiE;YAK/D,IAJAovB,IAAS3c,EAAUzT,CAAVyT,EAAoBhB,EAAIlP,EAAxBkQ,EAA4BhB,EAAI+c,QAAhC/b,EAA0ChB,EAAI3Q,KAA9C2R,EAAqDhB,EAAIzP,KAAzDyQ,CAAT2c,EACAA,EAAO/Z,aAAP+Z,GAAuB3d,EAAI4D,aAD3B+Z,EAEAA,EAAO/b,OAAP+b,GAAiBC,EAAkB5d,EAAI4B,OAAtBgc,EAA+BrtB,IAAQ,CAAvCqtB,CAFjBD,EAEwD,CAEnDA,EAAO/b,OAAP+b,CAAepvB,MAApB,EACE;YAGFyR,IAAM2d,CAAN3d;UAGEwd;;UAAAA,EAAUxd,CAAVwd,MACFzO,EAAK1gB,IAAL0gB,CAAU/O,CAAV+O,GACA2O,EAAoB1d,EAAIlP,EAAxB4sB,IAA8B1d,CAD9B+O,EAEA2O,EAAoBtP,CAApBsP,IAAyB1d,CAHvBwd;QAON;;QAAA,OAAOzO,CAAP;MAAOA,CA/BT;;MAkCA,OAAO;QACLA,MAAM6O,EAAkBL,CAAlBK,CADD;QAEL7d,UAAU0d,CAFL;QAGLjd,UAAUkd;MAHL,CAAP;IA7CSG,CAKX,CALmC9O,CAKnC,EALyCuO,CAKzC,EALwD/vB,CAKxD,CANMA,GAoDN,UAAgCgwB,CAAhC,EAA8CC,CAA9C,EAAyDjwB,CAAzD,EAAyDA;MACvD,MAAMkwB,IAAsB,EAA5B;MAAA,MACMC,IAAsB,EAD5B;MAEA,IAAI3O,CAAJ,EACI/O,CADJ,EAEI2d,CAFJ;;MAIA,MAAMC,IAAoB,UAAUL,CAAV,EAAwBhtB,CAAxB,EAAwBA;QAAAA,KAClC,CADkCA,KAC5CA,CAD4CA,KAE9CA,IAAQ,CAFsCA,GAMhDwe,IAAO,EANyCxe;;QAQhD,KAAK,IAAI6d,IAAI,CAAb,EAAgBA,IAAImP,EAAahvB,MAAjC,EAAyC6f,GAAzC,EAA8C;UAC5CpO,IAAMud,EAAanP,CAAbmP,CAANvd;UAIE,IAAIkU,CAAJ;UADF,IAFasJ,EAAUxd,CAAVwd,CAEb,EAGuC,SAAhCtJ,IAAgBlU,EAAI4B,OAAY,KAAQsS,EAAc3lB,MAAtB,KACnCovB,IAAS3c,EAAUzT,CAAVyT,EAAoBhB,EAAIlP,EAAxBkQ,EAA4BhB,EAAI+c,QAAhC/b,EAA0ChB,EAAI3Q,KAA9C2R,EAAqDhB,EAAIzP,KAAzDyQ,CAAT2c,EACAA,EAAO/b,OAAP+b,GAAiBC,EAAkB5d,EAAI4B,OAAtBgc,EAA+BrtB,IAAQ,CAAvCqtB,CADjBD,EAEA3d,IAAM2d,CAH6B,GAMrC5O,EAAK1gB,IAAL0gB,CAAU/O,CAAV+O,CANqC,EAOrC0O,EAAoBpvB,IAApBovB,CAAyBzd,CAAzByd,CAPqC,EAQrCC,EAAoB1d,EAAIlP,EAAxB4sB,IAA8B1d,CARO;QAYzC;;QAAA,OAAO+O,CAAP;MAAOA,CA3BT;;MA8BA,OAAO;QACLA,MAAM6O,EAAkBL,CAAlBK,CADD;QAEL7d,UAAU0d,CAFL;QAGLjd,UAAUkd;MAHL,CAAP;IArFOI,CAgDT,CAhDgC/O,CAgDhC,EAhDsCuO,CAgDtC,EAhDqD/vB,CAgDrD,CApDE;EA+iBF;;EAAA,SAASwwB,EAAT,CAAoB5L,CAApB,EAA8B5kB,CAA9B,EAA8BA;IAC5B,MAAMywB,IAAe,EAArB;IAAA,MAEMC,IAAYje;MAChB,IAAIyB,CAAJ;MAEAuc,EAAa3vB,IAAb2vB,CAAkBhe,CAAlBge,GAEoC,SAA/Bvc,IAAezB,EAAI4B,OAAY,KAAQH,EAAalT,MAArB,IAA+ByR,EAAIM,aAAJN,EAA/B,IAClCA,EAAI4B,OAAJ5B,CAAY7R,OAAZ6R,CAAoBie,CAApBje,CAHFge;IAGsBC,CARxB;;IAaA,OADA9L,EAASpD,IAAToD,CAAchkB,OAAdgkB,CAAsB8L,CAAtB9L,GACO;MACLpD,MAAMiP,CADD;MAELje,UAAUoS,EAASpS,QAFd;MAGLS,UAAU2R,EAAS3R;IAHd,CAAP;EC9oHW4a;;EAAAA,WAAiB,CAAC8C,CAAD,EAAOlV,CAAP,KAAOA;IACnC,OAACkV,IAUH,UAA0BC,CAA1B,EAA0BA;MACxB,OACuB,qBAAdA,CAAc,IACrB;QACE,MAAMC,IAAQ5rB,OAAO6rB,cAAP7rB,CAAsB2rB,CAAtB3rB,CAAd;QACO4rB,SAAMhU,SAANgU,IAAmBA,EAAMhU,SAANgU,CAAgBE,gBAAnCF;MAAmCE,CAF5C,GAFF;IAPEC,CAMJ,CAR0BJ,IAFQD,CAUlC,KALyB,qBAAdC,CAKX,IAUA,UAA2BA,CAA3B,EAA2BA;MAEvB,OAAqB,mBAAdA,CAAc,IACS,mBAAvBA,EAAUK,QADI,IAErB,CAAC,YAAD,EAAe,mBAAf,EAAoC1pB,QAApC,CAA6CqpB,EAAUK,QAAVL,CAAmBM,WAAhE,CAFA;IAhBAC,CAcJ,CAdsBP,CActB,CAVA,GAV0CQ,gBAACT,CAADS,EAAU3V,CAAV2V,CAU1C,GAVgET,CAA7DA,GAAO,IAAR;IAEF,IAA0BC,CAA1B;EAA0BA,CAHb/C;;EA6BAa,WAAcD,EAAmB;IAAEZ;EAAF,CAAnBY,CAAdC;EAAmCb,kdDu/FhD;IACE,OAAO7tB,KAAYiB,EAAK,MAAM,CAACjB,EAASoE,OAATpE,CAAiBqxB,IAAlB,CAAXpwB,EAAoCowB;MACrD,MAAMzM,IAAW;QACfpD,MAAM,EADS;QAEfhP,UAAU,EAFK;QAGfS,UAAU;MAHK,CAAjB;MAAA,MAMMqe,IAAa,UAAUC,CAAV,EAAwBvuB,CAAxB,EAA+BC,CAA/B,EAA+BA;QAAAA,KAClC,CADkCA,KAC5CD,CAD4CC,KAE9CD,IAAQ,CAFsCC;QAKhD,MAAMue,IAAO,EAAb;;QAEA,KAAK,IAAIX,IAAI,CAAb,EAAgBA,IAAI0Q,EAAavwB,MAAjC,EAAyC6f,GAAzC,EAA8C;UAQ5C,MAAMpO,IAAMgB,EAAUzT,CAAVyT,EAAoBzT,EAAS+tB,SAAT/tB,CAAmBuxB,EAAa1Q,CAAb0Q,CAAnBvxB,EAAoC6gB,CAApC7gB,EAAuCiD,CAAvCjD,CAApByT,EAAoE8d,EAAa1Q,CAAb0Q,CAApE9d,EAAqFoN,CAArFpN,EAAwFzQ,CAAxFyQ,CAAZ;UASE,IAAI+d,CAAJ;UADF,IANA5M,EAASpS,QAAToS,CAAkB9jB,IAAlB8jB,CAAuBnS,CAAvBmS,GAEAA,EAAS3R,QAAT2R,CAAkBnS,EAAIlP,EAAtBqhB,IAA4BnS,CAF5BmS,EAIApD,EAAK1gB,IAAL0gB,CAAU/O,CAAV+O,CAJAoD,EAMI5kB,EAASoE,OAATpE,CAAiByxB,UAArB,EAGEhf,EAAIif,eAAJjf,GAAsBzS,EAASoE,OAATpE,CAAiByxB,UAAjBzxB,CAA4BuxB,EAAa1Q,CAAb0Q,CAA5BvxB,EAA6C6gB,CAA7C7gB,CAAtByS,EAEoD,SAA/C+e,IAAuB/e,EAAIif,eAAoB,KAAQF,EAAqBxwB,MAA7B,KAClDyR,EAAI4B,OAAJ5B,GAAc6e,EAAW7e,EAAIif,eAAfJ,EAAgCtuB,IAAQ,CAAxCsuB,EAA2C7e,CAA3C6e,CADoC,CAFpD7e;QAQJ;;QAAA,OAAO+O,CAAP;MAAOA,CAxCT;;MA4CA,OADAoD,EAASpD,IAAToD,GAAgB0M,EAAWD,CAAXC,CAAhB1M,EACOA,CAAP;IAAOA,CA7CU3jB,EA8ChB;MACDlB,MAAK,CADJ;MAEDyB,OAAO;QACL,IAAI2C,CAAJ;QAEA,OAA8D,SAAtDA,IAAwBnE,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOF,CAAP,GAA+BnE,EAASoE,OAATpE,CAAiB8gB,UAA9G;MAA8GA,CAL/G;MAOD9e,UAAU;QACRhC,EAASof,mBAATpf;MAASof;IARV,CA9CgBne,CAAnB;EAsDame,CC9iGiCyO,ED8iGjCzO,wBAoiBf;IACE,OAAOpf,KAAYiB,EAAK,MAAM,CAACjB,EAASyG,QAATzG,GAAoByR,QAArB,EAA+BzR,EAASoT,sBAATpT,EAA/B,EAAkEA,EAASoE,OAATpE,CAAiB4R,oBAAnF,CAAX3Q,EAAqH,CAACwQ,CAAD,EAAWmT,CAAX,EAAqBhT,CAArB,KACjIgT,EAASpD,IAAToD,CAAc5jB,MAAd4jB,IACJhT,CADIgT,KACJhT,CAAqC,CAArCA,KAAwBH,CAAxBG,IAA8C3M,OAAO6N,IAAP7N,CAAwB,QAAZwM,CAAY,GAAOA,CAAP,GAAkB,EAA1CxM,EAA8CjE,MADxF4jB,IAKE4L,GAAW5L,CAAX4L,CALF5L,GAEIA,CAHQ3jB,EAOhB;MACDlB,MAAK,CADJ;MAEDyB,OAAO;QACL,IAAI2C,CAAJ;QAEA,OAA8D,SAAtDA,IAAwBnE,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOF,CAAP,GAA+BnE,EAASoE,OAATpE,CAAiB8gB,UAA9G;MAA8GA;IAL/G,CAPgB7f,CAAnB;EAYkH6f,CC/lHpE+M,ED+lHoE/M,2BAtRpH;IACE,OAAO,CAAC9gB,CAAD,EAAWiH,CAAX,KAAwBhG,EAAK,MAAM,CAACjB,EAASsO,SAATtO,CAAmBiH,CAAnBjH,EAA6BiZ,kBAA7BjZ,EAAD,CAAXiB,EAAgE0wB;MAC7F,IAAIC,CAAJ;MAEA,MAAMC,IAAsE,SAAxDD,IAAwBD,EAAgBnf,QAAhBmf,CAAyB,CAAzBA,CAAgC,IAAP,KAAc,CAAP,GAAgBC,EAAsBhd,QAAtBgd,CAA+B3qB,CAA/B2qB,CAA5F;MAEA,SAA0B,CAA1B,KAAWC,CAAX,EACE;MAGF,IAAIC,IAAsB,CAACD,CAAD,EAAaA,CAAb,CAA1B;;MAEA,KAAK,IAAIhR,IAAI,CAAb,EAAgBA,IAAI8Q,EAAgBnf,QAAhBmf,CAAyB3wB,MAA7C,EAAqD6f,GAArD,EAA0D;QACxD,IAAIkR,CAAJ;QAEA,MAAM7a,IAAkE,SAAzD6a,IAAyBJ,EAAgBnf,QAAhBmf,CAAyB9Q,CAAzB8Q,CAAgC,IAAP9Q,KAAc,CAAP,GAAgBkR,EAAuBnd,QAAvBmd,CAAgC9qB,CAAhC8qB,CAAxF;QAEI7a,IAAQ4a,EAAoB,CAApBA,CAAR5a,GACF4a,EAAoB,CAApBA,IAAyB5a,CADvBA,GAEOA,IAAQ4a,EAAoB,CAApBA,CAAR5a,KACT4a,EAAoB,CAApBA,IAAyB5a,CADhBA,CAFPA;MAON;;MAAA,OAAO4a,CAAP;IAAOA,CAvBsB7wB,EAwB5B;MACDlB,MAAK,CADJ;MAEDyB,OAAO;QACL,IAAI2C,CAAJ;QAEA,OAA8D,SAAtDA,IAAwBnE,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOF,CAAP,GAA+BnE,EAASoE,OAATpE,CAAiB8gB,UAA9G;MAA8GA,CAL/G;MAOD9e,UAAU;IAPT,CAxB4Bf,CAA/B;EA+BY,CCz2GkC4sB,EDy2GlCrf,uBA7Fd;IACE,OAAO,CAACxO,CAAD,EAAWiH,CAAX,KAAwBhG,EAAK,MAAM,CAACjB,EAASkZ,sBAATlZ,EAAD,EAAoCA,EAASyG,QAATzG,GAAoBqW,aAAxD,EAAuErW,EAASyG,QAATzG,GAAoBsW,YAA3F,EAAyGtW,EAASia,mBAATja,EAAzG,CAAXiB,EAAqJ,CAAC+wB,CAAD,EAAc3b,CAAd,EAA6BC,CAA7B,KAA6BA;MAC/M,KAAK0b,EAAYxQ,IAAZwQ,CAAiBhxB,MAAtB,IAAsBA,CAA6B,QAAjBqV,CAAiB,IAAjBA,CAAyBA,EAAcrV,MAAnDA,KAAmDA,CAAYsV,CAArF,EACE,OAAO0b,CAAP;MAGF,MAAMC,IAAgB,IAAI5b,EAActQ,GAAdsQ,CAAkBjW,KAAKA,EAAEmD,EAAzB8S,EAA6BlP,MAA7BkP,CAAoCjW,KAAKA,MAAM6G,CAA/CoP,CAAJ,EAA8DC,IAAe,YAAfA,GAAe,KAAe5S,CAA5F,EAAuGyD,MAAvG,CAA8GC,OAA9G,CAAtB;MAaA,OAAO0oB,GAAWkC,EAAYxQ,IAAvBsO,EAXgBrd;QAErB,KAAK,IAAIoO,IAAI,CAAb,EAAgBA,IAAIoR,EAAcjxB,MAAlC,EAA0C6f,GAA1C,EACE,KAA4C,CAA5C,KAAIpO,EAAI4D,aAAJ5D,CAAkBwf,EAAcpR,CAAdoR,CAAlBxf,CAAJ,EACE,QAAO,CAAP;;QAIJ,QAAO,CAAP;MAAO,CAGFqd,EAA6C9vB,CAA7C8vB,CAAP;IAAoD9vB,CAlBvBiB,EAmB5B;MACDlB,MAAK,CADJ;MAEDyB,OAAO;QACL,IAAI2C,CAAJ;QAEA,OAA8D,SAAtDA,IAAwBnE,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOF,CAAP,GAA+BnE,EAASoE,OAATpE,CAAiB8gB,UAA9G;MAA8GA,CAL/G;MAOD9e,UAAU;IAPT,CAnB4Bf,CAA/B;EA0BY,CCvyGkC4sB,EDuyGlCrf,2BAId;IACE,OAAO,CAACxO,CAAD,EAAWiH,CAAX,KAAwBhG,EAAK,MAAM,CAACjB,EAASsO,SAATtO,CAAmBiH,CAAnBjH,EAA6BiZ,kBAA7BjZ,EAAD,CAAXiB,EAAgE0wB;MAC7F,IAAIO,IAAsB,IAAI7Y,GAAJ,EAA1B;;MAEA,KAAK,IAAIwH,IAAI,CAAb,EAAgBA,IAAI8Q,EAAgBnf,QAAhBmf,CAAyB3wB,MAA7C,EAAqD6f,GAArD,EAA0D;QACxD,IAAI+Q,CAAJ;QAEA,MAAM1a,IAAiE,SAAxD0a,IAAwBD,EAAgBnf,QAAhBmf,CAAyB9Q,CAAzB8Q,CAAgC,IAAP9Q,KAAc,CAAP,GAAgB+Q,EAAsBhd,QAAtBgd,CAA+B3qB,CAA/B2qB,CAAvF;QAGE,IAAIO,CAAJ;QADF,IAAID,EAAoBE,GAApBF,CAAwBhb,CAAxBgb,CAAJ,EAGEA,EAAoBG,GAApBH,CAAwBhb,CAAxBgb,EAAwBhb,CAAoE,SAA3Dib,IAAwBD,EAAoBI,GAApBJ,CAAwBhb,CAAxBgb,CAAmC,IAAOC,CAAP,GAA+B,CAAnGjb,IAAwG,CAAhIgb,EAHF,KAKEA,EAAoBG,GAApBH,CAAwBhb,CAAxBgb,EAA+B,CAA/BA;MAIJ;;MAAA,OAAOA,CAAP;IAAOA,CAjBsBjxB,EAkB5B;MACDlB,MAAK,CADJ;MAEDyB,OAAO;QACL,IAAI2C,CAAJ;QAEA,OAA8D,SAAtDA,IAAwBnE,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOF,CAAP,GAA+BnE,EAASoE,OAATpE,CAAiB8gB,UAA9G;MAA8GA,CAL/G;MAOD9e,UAAU;IAPT,CAlB4Bf,CAA/B;EAyBY,CCr0GkC4sB,EDq0GlCrf,wBAjLd;IACE,OAAOxO,KAAYiB,EAAK,MAAM,CAACjB,EAASkZ,sBAATlZ,EAAD,EAAoCA,EAASyG,QAATzG,GAAoBqW,aAAxD,EAAuErW,EAASyG,QAATzG,GAAoBsW,YAA3F,CAAXrV,EAAqH,CAAC2jB,CAAD,EAAWvO,CAAX,EAA0BC,CAA1B,KAA0BA;MAChK,KAAKsO,EAASpD,IAAToD,CAAc5jB,MAAnB,IAAmBA,CAA6B,QAAjBqV,CAAiB,IAAjBA,CAAyBA,EAAcrV,MAAnDA,KAAmDA,CAAYsV,CAAlF,EAAgG;QAC9F,KAAK,IAAIuK,IAAI,CAAb,EAAgBA,IAAI+D,EAASpS,QAAToS,CAAkB5jB,MAAtC,EAA8C6f,GAA9C,EACE+D,EAASpS,QAAToS,CAAkB/D,CAAlB+D,EAAqBvO,aAArBuO,GAAqC,EAArCA,EACAA,EAASpS,QAAToS,CAAkB/D,CAAlB+D,EAAqBpL,iBAArBoL,GAAyC,EADzCA;;QAIF,OAAOA,CAAP;MAGF;;MAAA,MAAM2N,IAAwB,EAA9B;MAAA,MACMC,IAAwB,EAD9B;MAC8B,CACZ,QAAjBnc,CAAiB,GAAOA,CAAP,GAAuB,EADX,EACezV,OADf,CACuBR;QACnD,IAAIqyB,CAAJ;QAEA,MAQMrc,IARSpW,EAASsO,SAATtO,CAAmBI,EAAEmD,EAArBvD,EAQSqX,WARTrX,EAAf;QAUKoW,KAQLmc,EAAsBzxB,IAAtByxB,CAA2B;UACzBhvB,IAAInD,EAAEmD,EADmB;UAEzB6S,WAFyB;UAGzBsc,eAAgI,SAAhHD,IAAuD,QAA/Brc,EAASX,kBAAsB,GAAtBA,KAA6B,CAAP,GAAgBW,EAASX,kBAATW,CAA4BhW,EAAE8W,KAA9Bd,CAAyC,IAAOqc,CAAP,GAA+BryB,EAAE8W;QAHxI,CAA3Bqb,CARKnc;MAW8Jc,CAzBvI;MA4B9B,MAAM+a,IAAgB5b,EAActQ,GAAdsQ,CAAkBjW,KAAKA,EAAEmD,EAAzB8S,CAAtB;MAAA,MACMK,IAAiB1W,EAAS0Z,iBAAT1Z,EADvB;MAAA,MAEM2yB,IAA4B3yB,EAAS2Z,iBAAT3Z,GAA6BmH,MAA7BnH,CAAoC6D,KAAUA,EAAO+T,kBAAP/T,EAA9C7D,CAFlC;MAiBA,IAAI4yB,CAAJ,EACIC,CADJ;MAbIvc,KAAgBI,CAAhBJ,IAAkCqc,EAA0B3xB,MAA5DsV,KACF2b,EAAcnxB,IAAdmxB,CAAmB,YAAnBA,GACAU,EAA0B/xB,OAA1B+xB,CAAkC9uB;QAChC,IAAIivB,CAAJ;QAEAN,EAAsB1xB,IAAtB0xB,CAA2B;UACzBjvB,IAAIM,EAAON,EADc;UAEzB6S,UAAUM,CAFe;UAGzBgc,eAAiJ,SAAjII,IAA6D,QAArCpc,EAAejB,kBAAsB,GAAtBA,KAA6B,CAAP,GAAgBiB,EAAejB,kBAAfiB,CAAkCJ,CAAlCI,CAAoD,IAAOoc,CAAP,GAA+Bxc;QAHvJ,CAA3Bkc;MAGkLlc,CANpLqc,CAFErc;;MAgBJ,KAAK,IAAIyc,IAAI,CAAb,EAAgBA,IAAInO,EAASpS,QAAToS,CAAkB5jB,MAAtC,EAA8C+xB,GAA9C,EAAmD;QACjD,MAAMtgB,IAAMmS,EAASpS,QAAToS,CAAkBmO,CAAlBnO,CAAZ;QAGA,IAFAnS,EAAI4D,aAAJ5D,GAAoB,EAApBA,EAEI8f,EAAsBvxB,MAA1B,EACE,KAAK,IAAI6f,IAAI,CAAb,EAAgBA,IAAI0R,EAAsBvxB,MAA1C,EAAkD6f,GAAlD,EAAuD;UACrD+R,IAAsBL,EAAsB1R,CAAtB0R,CAAtBK;UACA,MAAMrvB,IAAKqvB,EAAoBrvB,EAA/B;UAEAkP,EAAI4D,aAAJ5D,CAAkBlP,CAAlBkP,IAAwBmgB,EAAoBxc,QAApBwc,CAA6BngB,CAA7BmgB,EAAkCrvB,CAAlCqvB,EAAsCA,EAAoBF,aAA1DE,EAAyEI;YAC/FvgB,EAAI+G,iBAAJ/G,CAAsBlP,CAAtBkP,IAA4BugB,CAA5BvgB;UAA4BugB,CADNJ,CAAxBngB;QAMJ;;QAAA,IAAI+f,EAAsBxxB,MAA1B,EAAkC;UAChC,KAAK,IAAI6f,IAAI,CAAb,EAAgBA,IAAI2R,EAAsBxxB,MAA1C,EAAkD6f,GAAlD,EAAuD;YACrDgS,IAAsBL,EAAsB3R,CAAtB2R,CAAtBK;YACA,MAAMtvB,IAAKsvB,EAAoBtvB,EAA/B;;YAEA,IAAIsvB,EAAoBzc,QAApByc,CAA6BpgB,CAA7BogB,EAAkCtvB,CAAlCsvB,EAAsCA,EAAoBH,aAA1DG,EAAyEG;cAC3EvgB,EAAI+G,iBAAJ/G,CAAsBlP,CAAtBkP,IAA4BugB,CAA5BvgB;YAA4BugB,CAD1BH,CAAJ,EAEI;cACFpgB,EAAI4D,aAAJ5D,CAAkBwgB,UAAlBxgB,GAAkBwgB,CAAa,CAA/BxgB;cACA;YAAA;UAAA;;UAAA,CAIiC,CAJjC,KAIAA,EAAI4D,aAAJ5D,CAAkBwgB,UAJlB,KAKFxgB,EAAI4D,aAAJ5D,CAAkBwgB,UAAlBxgB,GAAkBwgB,CAAa,CAL7B;QAK6B;MAiBrC;;MAAA,OAAOnD,GAAWlL,EAASpD,IAApBsO,EAZgBrd;QAErB,KAAK,IAAIoO,IAAI,CAAb,EAAgBA,IAAIoR,EAAcjxB,MAAlC,EAA0C6f,GAA1C,EACE,KAA4C,CAA5C,KAAIpO,EAAI4D,aAAJ5D,CAAkBwf,EAAcpR,CAAdoR,CAAlBxf,CAAJ,EACE,QAAO,CAAP;;QAIJ,QAAO,CAAP;MAAO,CAIFqd,EAA0C9vB,CAA1C8vB,CAAP;IAAiD9vB,CAzGhCiB,EA0GhB;MACDlB,MAAK,CADJ;MAEDyB,OAAO;QACL,IAAI2C,CAAJ;QAEA,OAA8D,SAAtDA,IAAwBnE,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOF,CAAP,GAA+BnE,EAASoE,OAATpE,CAAiB8gB,UAA9G;MAA8GA,CAL/G;MAOD9e,UAAU;QACRhC,EAASof,mBAATpf;MAASof;IARV,CA1GgBne,CAAnB;EAkHame,CCvwGiCyO,EDuwGjCzO,uBAkMf;IACE,OAAOpf,KAAYiB,EAAK,MAAM,CAACjB,EAASyG,QAATzG,GAAoB8b,QAArB,EAA+B9b,EAASmd,qBAATnd,EAA/B,CAAXiB,EAA6E,CAAC6a,CAAD,EAAW8I,CAAX,KAAWA;MACzG,KAAKA,EAASpD,IAAToD,CAAc5jB,MAAnB,IAAmBA,CAAW8a,EAAS9a,MAAvC,EACE,OAAO4jB,CAAP;;MAIF,MAAMsO,IAAmBpX,EAAS3U,MAAT2U,CAAgB7U,KAAYjH,EAASsO,SAATtO,CAAmBiH,CAAnBjH,CAA5B8b,CAAzB;MAAA,MACMqX,IAAkB,EADxB;MAAA,MAEMC,IAAkB,EAFxB;MAAA,MAQMC,IAAqB,UAAU7R,CAAV,EAAgBxe,CAAhB,EAAuBswB,CAAvB,EAAuBA;QAMhD,SALc,CAKd,KALItwB,CAKJ,KAJEA,IAAQ,CAIV,GAAIA,MAAUkwB,EAAiBlyB,MAA/B,EACE,OAAOwgB,CAAP;;QAGF,MAAMva,IAAWisB,EAAiBlwB,CAAjBkwB,CAAjB;QAAA,MAEMK,IA8FZ,UAAiB/R,CAAjB,EAAuBva,CAAvB,EAAuBA;UACrB,MAAMusB,IAAW,IAAIna,GAAJ,EAAjB;UACA,OAAOmI,EAAK1c,MAAL0c,CAAY,CAACzb,CAAD,EAAM0M,CAAN,KAAMA;YACvB,MAAMghB,IAAS,KAAKhhB,EAAImC,QAAJnC,CAAaxL,CAAbwL,CAApB;YAAA,MACMihB,IAAW3tB,EAAIusB,GAAJvsB,CAAQ0tB,CAAR1tB,CADjB;YASA,OANK2tB,IAGH3tB,EAAIssB,GAAJtsB,CAAQ0tB,CAAR1tB,EAAgB,IAAI2tB,CAAJ,EAAcjhB,CAAd,CAAhB1M,CAHG2tB,GACH3tB,EAAIssB,GAAJtsB,CAAQ0tB,CAAR1tB,EAAgB,CAAC0M,CAAD,CAAhB1M,CADG2tB,EAME3tB,CAAP;UAAOA,CAVFyb,EAWJgS,CAXIhS,CAAP;QAhGyBmS,CA8F3B,CA9FmCnS,CA8FnC,EA9FyCva,CA8FzC,CAhGM;QAAA,MAIM2sB,IAAwBzc,MAAMgE,IAANhE,CAAWoc,EAAaM,OAAbN,EAAXpc,EAAmCpR,GAAnCoR,CAAuC,CAACjU,CAAD,EAAOpB,CAAP,KAAOA;UAC1E,KAAKgyB,CAAL,EAAoBC,CAApB,IAAmC7wB,CAAnC;UAAA,IACIK,IAAK0D,IAAW,GAAXA,GAAiB6sB,CAD1B;UAEAvwB,IAAK+vB,IAAWA,IAAW,GAAXA,GAAiB/vB,CAA5B+vB,GAAiC/vB,CAAtCA;UAEA,MAAM8Q,IAAUgf,EAAmBU,CAAnBV,EAAgCrwB,IAAQ,CAAxCqwB,EAA2C9vB,CAA3C8vB,CAAhB;UAAA,MAEMtY,IAAW/X,IAAQ1C,EAAUyzB,CAAVzzB,EAAuBmS,KAAOA,EAAI4B,OAAlC/T,CAAR0C,GAAqD+wB,CAFtE;UAAA,MAGMthB,IAAMgB,EAAUzT,CAAVyT,EAAoBlQ,CAApBkQ,EAAoBlQ,KAAIG,CAAxB+P,EAAmC3R,CAAnC2R,EAA0CzQ,CAA1CyQ,CAHZ;UAiDA,OA7CAxO,OAAOC,MAAPD,CAAcwN,CAAdxN,EAAmB;YACjBsY,kBAAkBtW,CADD;YAEjB6sB,gBAFiB;YAGjBzf,UAHiB;YAIjB0G,WAJiB;YAKjBnG,UAAU3N;cAER,IAAIisB,EAAiB3rB,QAAjB2rB,CAA0BjsB,CAA1BisB,CAAJ,EAAyC;gBACvC,IAAIzgB,EAAIid,YAAJjd,CAAiBkd,cAAjBld,CAAgCxL,CAAhCwL,CAAJ,EACE,OAAOA,EAAIid,YAAJjd,CAAiBxL,CAAjBwL,CAAP;gBAIA,IAAIuhB,CAAJ;gBADF,IAAID,EAAY,CAAZA,CAAJ,EAGEthB,EAAIid,YAAJjd,CAAiBxL,CAAjBwL,IAA4F,SAA9DuhB,IAAwBD,EAAY,CAAZA,EAAenf,QAAfmf,CAAwB9sB,CAAxB8sB,CAAsC,IAAOC,CAAP,GAAOA,KAAwBtwB,CAA3H+O;gBAGF,OAAOA,EAAIid,YAAJjd,CAAiBxL,CAAjBwL,CAAP;cAGF;;cAAA,IAAIA,EAAI+K,oBAAJ/K,CAAyBkd,cAAzBld,CAAwCxL,CAAxCwL,CAAJ,EACE,OAAOA,EAAI+K,oBAAJ/K,CAAyBxL,CAAzBwL,CAAP;cAIF,MACMwhB,IADSj0B,EAASsO,SAATtO,CAAmBiH,CAAnBjH,EACY+c,gBADZ/c,EAAf;cAGA,OAAIi0B,KACFxhB,EAAI+K,oBAAJ/K,CAAyBxL,CAAzBwL,IAAqCwhB,EAAYhtB,CAAZgtB,EAAsBlZ,CAAtBkZ,EAAgCF,CAAhCE,CAArCxhB,EACOA,EAAI+K,oBAAJ/K,CAAyBxL,CAAzBwL,CAFLwhB,IAE8BhtB,KAFlC;YAAA;UA7Be,CAAnBhC,GAmCAoP,EAAQzT,OAARyT,CAAgB0S;YACdoM,EAAgBryB,IAAhBqyB,CAAqBpM,CAArBoM,GACAC,EAAgBrM,EAAOxjB,EAAvB6vB,IAA6BrM,CAD7BoM;UAC6BpM,CAF/B1S,CAnCApP,EA6COwN,CAAP;QAAOA,CAtDqB0E,CAJ9B;;QA4DA,OAAOyc,CAAP;MAAOA,CA9ET;MAAA,MAiFMG,IAAcV,EAAmBzO,EAASpD,IAA5B6R,EAAkC,CAAlCA,EAAqC,EAArCA,CAjFpB;;MA4FA,OAVAU,EAAYnzB,OAAZmzB,CAAoBhN;QAClBoM,EAAgBryB,IAAhBqyB,CAAqBpM,CAArBoM,GACAC,EAAgBrM,EAAOxjB,EAAvB6vB,IAA6BrM,CAD7BoM;MAC6BpM,CAF/BgN,GAUO;QACLvS,MAAMuS,CADD;QAELvhB,UAAU2gB,CAFL;QAGLlgB,UAAUmgB;MAHL,CAAP;IAGYA,CArGKnyB,EAuGhB;MACDlB,MAAK,CADJ;MAEDyB,OAAO;QACL,IAAI2C,CAAJ;QAEA,OAA8D,SAAtDA,IAAwBnE,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOF,CAAP,GAA+BnE,EAASoE,OAATpE,CAAiB8gB,UAA9G;MAA8GA,CAL/G;MAOD9e,UAAU;QACRhC,EAASiS,MAATjS,CAAgB;UACdA,EAAS+R,kBAAT/R,IAEAA,EAASof,mBAATpf,EAFAA;QAESof,CAHXpf;MAGWof;IAXZ,CAvGgBne,CAAnB;EAkHeme,CC5jH+ByO,ED4jH/BzO,0BA4DjB,UAA+Bhe,CAA/B,EAA+BA;IAC7B,OAAOpB,KAAYiB,EAAK,MAAM,CAACjB,EAASyG,QAATzG,GAAoBgf,UAArB,EAAiChf,EAASohB,wBAATphB,EAAjC,CAAXiB,EAAkF,CAAC+d,CAAD,EAAa4F,CAAb,KAAaA;MAChH,KAAKA,EAASpD,IAAToD,CAAc5jB,MAAnB,EACE,OAAO4jB,CAAP;MAGF;QAAM1F,UACJA,CADF;QACUD,WACRA;MAFF,IAGID,CAHJ;MAIA;QAAIwC,MACFA,CADF;QACMhP,UACJA,CAFF;QAEUS,UACRA;MAHF,IAII2R,CAJJ;MAKA,MAAMsP,IAAYhV,IAAWD,CAA7B;MAAA,MACMkV,IAAUD,IAAYhV,CAD5B;MAIA,OAFAsC,IAAOA,EAAKwH,KAALxH,CAAW0S,CAAX1S,EAAsB2S,CAAtB3S,CAAPA,EAEKxhB,EAASoE,OAATpE,CAAiB4R,oBAAjB5R,GAQE;QACLwhB,OADK;QAELhP,WAFK;QAGLS;MAHK,CARFjT,GACIwwB,GAAW;QAChBhP,OADgB;QAEhBhP,WAFgB;QAGhBS;MAHgB,CAAXud,CADT;IAIIvd,CAtBahS,EA+BhB;MACDlB,MAAK,CADJ;MAEDyB,OAAO;QACL,IAAI2C,CAAJ;QAEA,OAA8D,SAAtDA,IAAwBnE,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOF,CAAP,GAA+BnE,EAASoE,OAATpE,CAAiB8gB,UAA9G;MAA8GA;IAL/G,CA/BgB7f,CAAnB;EAoCkH6f,CC7pHpE+M,ED6pHoE/M,sBAhTpH;IACE,OAAO9gB,KAAYiB,EAAK,MAAM,CAACjB,EAASyG,QAATzG,GAAoByoB,OAArB,EAA8BzoB,EAASkrB,oBAATlrB,EAA9B,CAAXiB,EAA2E,CAACwnB,CAAD,EAAU7D,CAAV,KAAUA;MACtG,KAAKA,EAASpD,IAAToD,CAAc5jB,MAAnB,IAA0C,QAAXynB,CAA/B,IAA+BA,CAAmBA,EAAQznB,MAA1D,EACE,OAAO4jB,CAAP;MAGF,MAAMwP,IAAep0B,EAASyG,QAATzG,GAAoByoB,OAAzC;MAAA,MACM4L,IAAiB,EADvB;MAAA,MAGMC,IAAmBF,EAAajtB,MAAbitB,CAAoBvM,KAAQ7nB,EAASsO,SAATtO,CAAmB6nB,EAAKtkB,EAAxBvD,EAA4BqqB,UAA5BrqB,EAA5Bo0B,CAHzB;MAAA,MAIMG,IAAiB,EAJvB;MAKAD,EAAiB1zB,OAAjB0zB,CAAyBE;QACvB,MAAM3wB,IAAS7D,EAASsO,SAATtO,CAAmBw0B,EAAUjxB,EAA7BvD,CAAf;QACAu0B,EAAeC,EAAUjxB,EAAzBgxB,IAA+B;UAC7BE,eAAe5wB,EAAOd,SAAPc,CAAiB4wB,aADH;UAE7BC,eAAe7wB,EAAOd,SAAPc,CAAiB6wB,aAFH;UAG7BhM,WAAW7kB,EAAOslB,YAAPtlB;QAHkB,CAA/B0wB;MAGoBpL,CALtBmL;;MASA,MAAMK,IAAWnT;QAGf,MAAMoT,IAAapT,EAAKwH,KAALxH,EAAnB;QAgDA,OA/CAoT,EAAW/M,IAAX+M,CAAgB,CAAC5M,CAAD,EAAOC,CAAP,KAAOA;UACrB,KAAK,IAAIpH,IAAI,CAAb,EAAgBA,IAAIyT,EAAiBtzB,MAArC,EAA6C6f,KAAK,CAAlD,EAAqD;YACnD,IAAIgU,CAAJ;YAEA,MAAML,IAAYF,EAAiBzT,CAAjByT,CAAlB;YAAA,MACMQ,IAAaP,EAAeC,EAAUjxB,EAAzBgxB,CADnB;YAAA,MAEMQ,IAA4E,SAAlEF,IAA+B,QAAbL,CAAa,GAAbA,KAAoB,CAAP,GAAgBA,EAAUlL,IAAS,KAAOuL,CAFzF;;YAIA,IAAIC,EAAWL,aAAf,EAA8B;cAC5B,MAEMO,SAA+B,CAA/BA,KAFShN,EAAKpT,QAALoT,CAAcwM,EAAUjxB,EAAxBykB,CAAf;cAAA,MAGMiN,SAA+B,CAA/BA,KAFShN,EAAKrT,QAALqT,CAAcuM,EAAUjxB,EAAxB0kB,CADf;cAKA,IAAI+M,KAAcC,CAAlB,EACE,OAAOD,KAAcC,CAAdD,GAA2B,CAA3BA,GAA+BA,IAAaF,EAAWL,aAAxBO,GAAwBP,CAAiBK,EAAWL,aAA1F;YAKJ;;YAAA,IAAIS,IAAUJ,EAAWpM,SAAXoM,CAAqB9M,CAArB8M,EAA2B7M,CAA3B6M,EAAiCN,EAAUjxB,EAA3CuxB,CAAd;YAEA,IAAgB,MAAZI,CAAJ,EASE,OARIH,MACFG,MAAY,CADVH,GAIAD,EAAWJ,aAAXI,KACFI,MAAY,CADVJ,CAJAC,EAQGG,CAAP;UAIJ;;UAAA,OAAOlN,EAAKlmB,KAALkmB,GAAaC,EAAKnmB,KAAzB;QAAyBA,CAnC3B8yB,GAsCAA,EAAWh0B,OAAXg0B,CAAmBniB;UACjB4hB,EAAevzB,IAAfuzB,CAAoB5hB,CAApB4hB,GAAoB5hB,CAEfA,EAAI4B,OAFW5B,IAEAA,EAAI4B,OAAJ5B,CAAYzR,MAAZyR,IAAsB,CAFtBA,KAMpBA,EAAI4B,OAAJ5B,GAAckiB,EAASliB,EAAI4B,OAAbsgB,CANMliB,CAApB4hB;QAM2BhgB,CAP7BugB,CAtCAA,EA+COA,CAAP;MAAOA,CAnDT;;MAsDA,OAAO;QACLpT,MAAMmT,EAAS/P,EAASpD,IAAlBmT,CADD;QAELniB,UAAU6hB,CAFL;QAGLphB,UAAU2R,EAAS3R;MAHd,CAAP;IAGqBA,CA5EJhS,EA8EhB;MACDlB,MAAK,CADJ;MAEDyB,OAAO;QACL,IAAI2C,CAAJ;QAEA,OAA8D,SAAtDA,IAAwBnE,EAASoE,OAATpE,CAAiBqE,QAAa,IAAOF,CAAP,GAA+BnE,EAASoE,OAATpE,CAAiB8gB,UAA9G;MAA8GA,CAL/G;MAOD9e,UAAU;QACRhC,EAASof,mBAATpf;MAASof;IARV,CA9EgBne,CAAnB;EAsFame,CCp8GiCyO,EDo8GjCzO,gBCp8GiCyO,EDo8GjCzO,mBCp8GiCyO,EDo8GjCzO,sBCp8GiCyO,EDo8GjCzO,UCp8GiCyO,EDo8GjCzO,SAp/Gf,cCgDgDyO,EDhDhDrf,kBCgDgDqf,EDhDhDrf,2BCgDgDqf,EDhDhDrf,yBCgDgDqf,EDhDhDrf,aCgDgDqf,EDhDhDrf,kBCgDgDqf,EDhDhDrf,4BCgDgDqf,EDhDhDrf,gBCgDgDqf,EDhDhDrf,qBCwDO,UACLogB,CADK,EAELxqB,CAFK,EAELA;IAGA,MAAM+wB,IAAmD,KACpDvG,EAAMxqB,OAD8C;MAEvD4H,OAAO,EAFgD;MAGvD8hB,eAAe,QAHwC;MAIvDD,UAJuD;MAIvDA,GACGzpB;IALoD,CAAzD;IAAA,MAKKA,CAIEgxB,CAJFhxB,IAIiBgtB,EAAMiE,QAANjE,CAAe,OAAO;MAC1CkE,SAAS1I,EAA+BuI,CAA/BvI;IADiC,CAAP,CAAfwE,CATtB;IAAA,MAU0C+D,CAInCnpB,CAJmCmpB,EAI5Bl1B,CAJ4Bk1B,IAIhB/D,EAAMiE,QAANjE,CACxB,MAAMgE,EAAYE,OAAZF,CAAoBjlB,YADFihB,CAd1B;IAmCOgE,OAfPA,EAAYE,OAAZF,CAAoB1H,UAApB0H,CAA+BG,MAAI,KAC9BA,CAD8B;MAC9BA,GACAnxB,CAF8B;MAGjC4H,OAAO,KACFA,CADE;QACFA,GACA5H,EAAQ4H;MAFN,CAH0B;MASjC8hB,eAAeluB;QACbK,EAASL,CAATK,GACA,UAAQ6tB,aAAR,MAAQA,aAAR1pB,CAAwBxE,CAAxBwE,CADAnE;MACwBL;IAXO,CAAJ21B,CAA/BH,GAeOA,EAAYE,OAAZF;EAAYE,CAhD2BzH,EAgD3ByH;IAAAA;EAAAA,EAhD2BzH;AAgD3ByH","names":["functionalUpdate","updater","input","makeStateUpdater","key","instance","setState","old","isFunction","d","Function","flattenBy","arr","getChildren","flat","recurse","subArr","forEach","item","push","children","length","memo","getDeps","fn","opts","result","deps","depTime","debug","Date","now","newDeps","some","dep","index","resultTime","onChange","depEndTime","Math","round","resultEndTime","resultFpsPercentage","pad","str","num","String","console","info","max","min","createColumn","columnDef","depth","parent","_ref","_columnDef$id","defaultColumn","_getDefaultColumnDef","accessorFn","id","accessorKey","header","undefined","originalRow","Error","column","columnDefType","columns","getFlatColumns","_column$columns","flatMap","_instance$options$deb","options","debugAll","debugColumns","getLeafColumns","_getOrderColumnsFn","orderColumns","_column$columns2","leafColumns","_instance$options$deb2","_features","reduce","obj","feature","Object","assign","createHeader","_options$id","isPlaceholder","placeholderId","subHeaders","colSpan","rowSpan","headerGroup","getLeafHeaders","leafHeaders","recurseHeader","h","map","renderHeader","_render","renderFooter","footer","Headers","createInstance","getHeaderGroups","getAllColumns","getVisibleLeafColumns","getState","columnPinning","left","right","allColumns","_left$map$filter","_right$map$filter","leftColumns","columnId","find","filter","Boolean","rightColumns","buildHeaderGroups","includes","debugHeaders","getCenterHeaderGroups","getLeftHeaderGroups","_left$map$filter2","_instance$options$deb3","getRightHeaderGroups","_right$map$filter2","_instance$options$deb4","getFooterGroups","headerGroups","reverse","_instance$options$deb5","getLeftFooterGroups","_instance$options$deb6","getCenterFooterGroups","_instance$options$deb7","getRightFooterGroups","_instance$options$deb8","getFlatHeaders","headers","_instance$options$deb9","getLeftFlatHeaders","_instance$options$deb10","getCenterFlatHeaders","_instance$options$deb11","getRightFlatHeaders","_instance$options$deb12","getCenterLeafHeaders","flatHeaders","_header$subHeaders","_instance$options$deb13","getLeftLeafHeaders","_header$subHeaders2","_instance$options$deb14","getRightLeafHeaders","_header$subHeaders3","_instance$options$deb15","center","_left$0$headers","_left$","_center$0$headers","_center$","_right$0$headers","_right$","_instance$options$deb16","columnsToGroup","headerFamily","_headerGroups$0$heade","_headerGroups$","maxDepth","findMaxDepth","getIsVisible","createHeaderGroup","headersToGroup","join","pendingParentHeaders","headerToGroup","latestPendingParentHeader","bottomHeaders","recurseHeadersForSpans","childRowSpans","childColSpan","childRowSpan","defaultColumnSizing","size","minSize","maxSize","Number","MAX_SAFE_INTEGER","ColumnSizing","getDefaultColumnDef","getInitialState","state","columnSizing","columnSizingInfo","startOffset","startSize","deltaOffset","deltaPercentage","isResizingColumn","columnSizingStart","getDefaultOptions","columnResizeMode","onColumnSizingChange","onColumnSizingInfoChange","getSize","_column$columnDef$min","_column$columnDef$max","columnSize","getStart","position","getLeftVisibleLeafColumns","getRightVisibleLeafColumns","findIndex","prevSiblingColumn","resetSize","setColumnSizing","_ref2","_","rest","getCanResize","_column$columnDef$ena","_instance$options$ena","enableResizing","enableColumnResizing","getIsResizing","sum","_header$column$getSiz","prevSiblingHeader","getResizeHandler","getColumn","canResize","e","persist","isTouchStartEvent","touches","clientX","updateOffset","eventType","clientXPos","newColumnSizing","setColumnSizingInfo","_old$startOffset","_old$startSize","_ref3","headerSize","mouseEvents","moveHandler","onMove","upHandler","document","removeEventListener","passiveIfSupported","passiveEventSupported","passive","addEventListener","resetColumnSizing","defaultState","_instance$initialStat","initialState","resetHeaderSizeInfo","_instance$initialStat2","getTotalSize","_instance$getHeaderGr","_instance$getHeaderGr2","getLeftTotalSize","_instance$getLeftHead","_instance$getLeftHead2","getCenterTotalSize","_instance$getCenterHe","_instance$getCenterHe2","getRightTotalSize","_instance$getRightHea","_instance$getRightHea2","passiveSupported","supported","noop","window","err","type","Expanding","expanded","onExpandedChange","autoResetExpanded","paginateExpandedRows","registered","queued","_autoResetExpanded","autoResetAll","_queue","resetExpanded","setExpanded","toggleAllRowsExpanded","getIsAllRowsExpanded","getCanSomeRowsExpand","getRowModel","flatRows","row","getCanExpand","getToggleAllRowsExpandedHandler","getIsSomeRowsExpanded","values","keys","getIsExpanded","getExpandedDepth","rowsById","splitId","split","getPreExpandedRowModel","getGroupedRowModel","getExpandedRowModel","_getExpandedRowModel","manualExpanding","createRow","toggleExpanded","_expanded","exists","oldExpanded","rowId","_instance$options$get","getIsRowExpanded","_instance$options$get2","_row$subRows","getRowCanExpand","enableExpanding","subRows","getToggleExpandedHandler","canExpand","includesString","filterValue","search","toLowerCase","getValue","autoRemove","val","testFalsey","includesStringSensitive","equalsString","arrIncludes","arrIncludesAll","arrIncludesSome","equals","weakEquals","inNumberRange","rowValue","resolveFilterValue","unsafeMin","unsafeMax","parsedMin","parseFloat","parsedMax","isNaN","Infinity","temp","filterFns","Filters","filterFn","columnFilters","globalFilter","onColumnFiltersChange","onGlobalFilterChange","filterFromLeafRows","globalFilterFn","getColumnCanGlobalFilter","_instance$getCoreRowM","_instance$getCoreRowM2","getCoreRowModel","_getAllCellsByColumnId","getAutoFilterFn","firstRow","value","Array","isArray","getFilterFn","userFilterFns","getCanFilter","_instance$options$ena2","enableColumnFilter","enableColumnFilters","enableFilters","getCanGlobalFilter","_column$columnDef$ena2","_instance$options$ena3","_instance$options$ena4","enableGlobalFilter","getIsFiltered","getFilterIndex","getFilterValue","_instance$getState$co","_instance$getState$co2","_instance$getState$co3","_instance$getState$co4","setFilterValue","setColumnFilters","previousfilter","newFilter","_old$filter","shouldAutoRemoveFilter","newFilterObj","_old$map","_getFacetedRowModel","getFacetedRowModel","getPreFilteredRowModel","_getFacetedUniqueValues","getFacetedUniqueValues","Map","_getFacetedMinMaxValues","getFacetedMinMaxValues","columnFiltersMeta","getGlobalAutoFilterFn","getGlobalFilterFn","getAllLeafColumns","_functionalUpdate","setGlobalFilter","resetGlobalFilter","resetColumnFilters","_getFilteredRowModel","getFilteredRowModel","manualFiltering","_getGlobalFacetedRowModel","getGlobalFacetedRowModel","_getGlobalFacetedUniqueValues","getGlobalFacetedUniqueValues","_getGlobalFacetedMinMaxValues","getGlobalFacetedMinMaxValues","aggregationFns","_leafRows","childRows","next","extent","mean","leafRows","count","median","unique","from","Set","uniqueCount","_columnId","Grouping","aggregatedCell","props","_props$getValue$toStr","_props$getValue","toString","aggregationFn","grouping","onGroupingChange","groupedColumnMode","toggleGrouping","setGrouping","getCanGroup","enableGrouping","getIsGrouped","_instance$getState$gr","getGroupedIndex","_instance$getState$gr2","indexOf","getToggleGroupingHandler","canGroup","getAutoAggregationFn","prototype","call","getAggregationFn","_ref4","userAggregationFns","resetGrouping","getPreGroupedRowModel","getSortedRowModel","_getGroupedRowModel","manualGrouping","groupingColumnId","_groupingValuesCache","createCell","cell","getIsPlaceholder","getIsAggregated","renderAggregatedCell","_column$columnDef$agg","template","nonGroupingColumns","col","g","Ordering","columnOrder","onColumnOrderChange","setColumnOrder","resetColumnOrder","orderedColumns","columnOrderCopy","columnsCopy","targetColumnId","shift","foundIndex","splice","Pagination","pagination","pageIndex","pageSize","onPaginationChange","_autoResetPageIndex","_instance$options$aut","autoResetPageIndex","manualPagination","resetPageIndex","setPagination","resetPagination","setPageIndex","maxPageIndex","pageCount","_instance$initialStat3","_instance$initialStat4","resetPageSize","_instance$initialStat5","_instance$initialStat6","_instance$initialStat7","setPageSize","topRowIndex","floor","setPageCount","_old$pageCount","newPageCount","getPageOptions","pageOptions","fill","i","debugTable","getCanPreviousPage","getCanNextPage","getPageCount","previousPage","nextPage","getPrePaginationRowModel","getPaginationRowModel","_getPaginationRowModel","ceil","rows","Pinning","onColumnPinningChange","pin","columnIds","setColumnPinning","_old$left3","_old$right3","_old$left","_old$right","_old$left2","_old$right2","getCanPin","_d$columnDef$enablePi","enablePinning","getIsPinned","leafColumnIds","isLeft","isRight","getPinnedIndex","getCenterVisibleCells","_getAllVisibleCells","allCells","leftAndRight","debugRows","getLeftVisibleCells","getRightVisibleCells","resetColumnPinning","getIsSomeColumnsPinned","_pinningState$positio","pinningState","_pinningState$left","_pinningState$right","getLeftLeafColumns","getRightLeafColumns","getCenterLeafColumns","RowSelection","rowSelection","onRowSelectionChange","enableRowSelection","enableMultiRowSelection","enableSubRowSelection","setRowSelection","resetRowSelection","toggleAllRowsSelected","getIsAllRowsSelected","preGroupedFlatRows","toggleAllPageRowsSelected","getIsAllPageRowsSelected","mutateRowIsSelected","getPreSelectedRowModel","getSelectedRowModel","rowModel","selectRowsFn","getFilteredSelectedRowModel","getGroupedSelectedRowModel","preFilteredFlatRows","isAllRowsSelected","paginationFlatRows","isAllPageRowsSelected","getIsSomeRowsSelected","_instance$getState$ro","getIsSomePageRowsSelected","getToggleAllRowsSelectedHandler","target","checked","getToggleAllPageRowsSelectedHandler","toggleSelected","isSelected","getIsSelected","selectedRowIds","isRowSelected","getIsSomeSelected","getCanSelect","getCanSelectSubRows","getCanMultiSelect","getToggleSelectedHandler","canSelect","_target","getRow","newSelectedFlatRows","newSelectedRowsById","recurseRows","_row$subRows2","selection","allChildrenSelected","someSelected","subRow","compareBasic","a","b","compareAlphanumeric","aStr","bStr","reSplitAlphaNumeric","aa","bb","an","parseInt","bn","combo","sort","sortingFns","alphanumeric","rowA","rowB","alphanumericCaseSensitive","text","textCaseSensitive","datetime","getTime","basic","Sorting","sorting","sortingFn","onSortingChange","isMultiSortEvent","shiftKey","getAutoSortingFn","firstRows","slice","isString","getAutoSortDir","getSortingFn","userSortingFn","toggleSorting","desc","multi","setSorting","_column$columnDef$sor","existingSorting","existingIndex","hasDescDefined","sortAction","newSorting","getCanMultiSort","sortDescFirst","enableSortingRemoval","enableMultiRemove","_instance$options$max","maxMultiSortColCount","getCanSort","enableSorting","enableMultiSort","getIsSorted","_instance$getState$so","columnSort","getSortIndex","_instance$getState$so2","_instance$getState$so3","clearSorting","getToggleSortingHandler","canSort","resetSorting","getPreSortedRowModel","_getSortedRowModel","manualSorting","Visibility","columnVisibility","onColumnVisibilityChange","toggleVisibility","getCanHide","setColumnVisibility","enableHiding","getToggleVisibilityHandler","getAllCells","cells","getVisibleCells","makeVisibleColumnsMethod","getColumns","getVisibleFlatColumns","getAllFlatColumns","getCenterVisibleLeafColumns","resetColumnVisibility","toggleAllColumnsVisible","_value","getIsAllColumnsVisible","getIsSomeColumnsVisible","getToggleAllColumnsVisibilityHandler","features","createTableInstance","_options$initialState","defaultOptions","_feature$getInitialSt","queuedTimeout","coreInstance","cb","Promise","resolve","then","catch","error","setTimeout","reset","setOptions","newOptions","mergeOptions","render","onStateChange","_getRowId","getRowId","_getCoreRowModel","_defaultColumn","_getColumnDefs","columnDefs","recurseColumns","_getAllFlatColumnsById","flatColumns","acc","createTableFactory","createTable","__","table","generics","setRowType","setTableMetaType","setColumnMetaType","setFilterMetaType","createDisplayColumn","createGroup","createDataColumn","accessor","_column$id","createOptions","original","rowIndex","_valuesCache","hasOwnProperty","getLeafRows","renderCell","filterRows","filterRowImpl","rowsToFilter","filterRow","newFilteredFlatRows","newFilteredRowsById","newRow","recurseFilterRows","filterRowModelFromLeafs","filterRowModelFromRoot","expandRows","expandedRows","handleRow","Comp","component","proto","getPrototypeOf","isReactComponent","isClassComponent","$$typeof","description","isExoticComponent","React","data","accessRows","originalRows","_row$originalSubRows","getSubRows","originalSubRows","facetedRowModel","_facetedRowModel$flat","firstValue","facetedMinMaxValues","_facetedRowModel$flat2","preRowModel","filterableIds","facetedUniqueValues","_facetedUniqueValues$","has","set","get","resolvedColumnFilters","resolvedGlobalFilters","_filterFn$resolveFilt","resolvedValue","globallyFilterableColumns","currentColumnFilter","currentGlobalFilter","_globalFilterFn$resol","j","filterMeta","__global__","existingGrouping","groupedFlatRows","groupedRowsById","groupUpRecursively","parentId","rowGroupsMap","groupMap","resKey","previous","groupBy","aggregatedGroupedRows","entries","groupingValue","groupedRows","_groupedRows$0$getVal","aggregateFn","pageStart","pageEnd","sortingState","sortedFlatRows","availableSorting","columnInfoById","sortEntry","sortUndefined","invertSorting","sortData","sortedData","_sortEntry$desc","columnInfo","isDesc","aUndefined","bUndefined","sortInt","resolvedOptions","instanceRef","useState","current","prev"],"sources":["/Users/angrandy/Desktop/csc3007/node_modules/@tanstack/table-core/build/esm/index.js","/Users/angrandy/Desktop/csc3007/node_modules/@tanstack/react-table/src/index.tsx"],"sourcesContent":["/**\n * table-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\nfunction noop() {//\n}\nfunction makeStateUpdater(key, instance) {\n  return updater => {\n    instance.setState(old => {\n      return { ...old,\n        [key]: functionalUpdate(updater, old[key])\n      };\n    });\n  };\n}\nfunction isFunction(d) {\n  return d instanceof Function;\n}\nfunction flattenBy(arr, getChildren) {\n  const flat = [];\n\n  const recurse = subArr => {\n    subArr.forEach(item => {\n      flat.push(item);\n      const children = getChildren(item);\n\n      if (children != null && children.length) {\n        recurse(children);\n      }\n    });\n  };\n\n  recurse(arr);\n  return flat;\n}\nfunction memo(getDeps, fn, opts) {\n  let deps = [];\n  let result;\n  return () => {\n    let depTime;\n    if (opts.key && opts.debug) depTime = Date.now();\n    const newDeps = getDeps();\n    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);\n\n    if (!depsChanged) {\n      return result;\n    }\n\n    deps = newDeps;\n    let resultTime;\n    if (opts.key && opts.debug) resultTime = Date.now();\n    result = fn(...newDeps);\n    opts == null ? void 0 : opts.onChange == null ? void 0 : opts.onChange(result);\n\n    if (opts.key && opts.debug) {\n      if (opts != null && opts.debug()) {\n        const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n        const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n        const resultFpsPercentage = resultEndTime / 16;\n\n        const pad = (str, num) => {\n          str = String(str);\n\n          while (str.length < num) {\n            str = ' ' + str;\n          }\n\n          return str;\n        };\n\n        console.info(\"%c\\u23F1 \" + pad(resultEndTime, 5) + \" /\" + pad(depEndTime, 5) + \" ms\", \"\\n            font-size: .6rem;\\n            font-weight: bold;\\n            color: hsl(\" + Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120)) + \"deg 100% 31%);\", opts == null ? void 0 : opts.key);\n      }\n    }\n\n    return result;\n  };\n}\n\nfunction createColumn(instance, columnDef, depth, parent) {\n  var _ref, _columnDef$id;\n\n  const defaultColumn = instance._getDefaultColumnDef();\n\n  columnDef = { ...defaultColumn,\n    ...columnDef\n  };\n  let id = (_ref = (_columnDef$id = columnDef.id) != null ? _columnDef$id : columnDef.accessorKey) != null ? _ref : typeof columnDef.header === 'string' ? columnDef.header : undefined;\n  let accessorFn;\n\n  if (columnDef.accessorFn) {\n    accessorFn = columnDef.accessorFn;\n  } else if (columnDef.accessorKey) {\n    accessorFn = originalRow => originalRow[columnDef.accessorKey];\n  }\n\n  if (!id) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(columnDef.accessorFn ? \"Columns require an id when using an accessorFn\" : \"Columns require an id when using a non-string header\");\n    }\n\n    throw new Error();\n  }\n\n  let column = {\n    id: \"\" + id,\n    accessorFn,\n    parent: parent,\n    depth,\n    columnDef,\n    columnDefType: columnDef.columnDefType,\n    columns: [],\n    getFlatColumns: memo(() => [true], () => {\n      var _column$columns;\n\n      return [column, ...((_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap(d => d.getFlatColumns()))];\n    }, {\n      key: process.env.NODE_ENV === 'production' && 'column.getFlatColumns',\n      debug: () => {\n        var _instance$options$deb;\n\n        return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugColumns;\n      }\n    }),\n    getLeafColumns: memo(() => [instance._getOrderColumnsFn()], orderColumns => {\n      var _column$columns2;\n\n      if ((_column$columns2 = column.columns) != null && _column$columns2.length) {\n        let leafColumns = column.columns.flatMap(column => column.getLeafColumns());\n        return orderColumns(leafColumns);\n      }\n\n      return [column];\n    }, {\n      key: process.env.NODE_ENV === 'production' && 'column.getLeafColumns',\n      debug: () => {\n        var _instance$options$deb2;\n\n        return (_instance$options$deb2 = instance.options.debugAll) != null ? _instance$options$deb2 : instance.options.debugColumns;\n      }\n    })\n  };\n  column = instance._features.reduce((obj, feature) => {\n    return Object.assign(obj, feature.createColumn == null ? void 0 : feature.createColumn(column, instance));\n  }, column); // Yes, we have to convert instance to uknown, because we know more than the compiler here.\n\n  return column;\n}\n\n//\nfunction createHeader(instance, column, options) {\n  var _options$id;\n\n  const id = (_options$id = options.id) != null ? _options$id : column.id;\n  let header = {\n    id,\n    column,\n    index: options.index,\n    isPlaceholder: !!options.isPlaceholder,\n    placeholderId: options.placeholderId,\n    depth: options.depth,\n    subHeaders: [],\n    colSpan: 0,\n    rowSpan: 0,\n    headerGroup: null,\n    getLeafHeaders: () => {\n      const leafHeaders = [];\n\n      const recurseHeader = h => {\n        if (h.subHeaders && h.subHeaders.length) {\n          h.subHeaders.map(recurseHeader);\n        }\n\n        leafHeaders.push(h);\n      };\n\n      recurseHeader(header);\n      return leafHeaders;\n    },\n    renderHeader: () => column.columnDef.header ? instance._render(column.columnDef.header, {\n      instance,\n      header: header,\n      column\n    }) : null,\n    renderFooter: () => column.columnDef.footer ? instance._render(column.columnDef.footer, {\n      instance,\n      header: header,\n      column\n    }) : null\n  };\n\n  instance._features.forEach(feature => {\n    Object.assign(header, feature.createHeader == null ? void 0 : feature.createHeader(header, instance));\n  });\n\n  return header;\n}\n\nconst Headers = {\n  createInstance: instance => {\n    return {\n      // Header Groups\n      getHeaderGroups: memo(() => [instance.getAllColumns(), instance.getVisibleLeafColumns(), instance.getState().columnPinning.left, instance.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {\n        var _left$map$filter, _right$map$filter;\n\n        const leftColumns = (_left$map$filter = left == null ? void 0 : left.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _left$map$filter : [];\n        const rightColumns = (_right$map$filter = right == null ? void 0 : right.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _right$map$filter : [];\n        const centerColumns = leafColumns.filter(column => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\n        const headerGroups = buildHeaderGroups(allColumns, [...leftColumns, ...centerColumns, ...rightColumns], instance);\n        return headerGroups;\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getHeaderGroups',\n        debug: () => {\n          var _instance$options$deb;\n\n          return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugHeaders;\n        }\n      }),\n      getCenterHeaderGroups: memo(() => [instance.getAllColumns(), instance.getVisibleLeafColumns(), instance.getState().columnPinning.left, instance.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {\n        leafColumns = leafColumns.filter(column => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\n        return buildHeaderGroups(allColumns, leafColumns, instance, 'center');\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getCenterHeaderGroups',\n        debug: () => {\n          var _instance$options$deb2;\n\n          return (_instance$options$deb2 = instance.options.debugAll) != null ? _instance$options$deb2 : instance.options.debugHeaders;\n        }\n      }),\n      getLeftHeaderGroups: memo(() => [instance.getAllColumns(), instance.getVisibleLeafColumns(), instance.getState().columnPinning.left], (allColumns, leafColumns, left) => {\n        var _left$map$filter2;\n\n        const orderedLeafColumns = (_left$map$filter2 = left == null ? void 0 : left.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _left$map$filter2 : [];\n        return buildHeaderGroups(allColumns, orderedLeafColumns, instance, 'left');\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getLeftHeaderGroups',\n        debug: () => {\n          var _instance$options$deb3;\n\n          return (_instance$options$deb3 = instance.options.debugAll) != null ? _instance$options$deb3 : instance.options.debugHeaders;\n        }\n      }),\n      getRightHeaderGroups: memo(() => [instance.getAllColumns(), instance.getVisibleLeafColumns(), instance.getState().columnPinning.right], (allColumns, leafColumns, right) => {\n        var _right$map$filter2;\n\n        const orderedLeafColumns = (_right$map$filter2 = right == null ? void 0 : right.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _right$map$filter2 : [];\n        return buildHeaderGroups(allColumns, orderedLeafColumns, instance, 'right');\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getRightHeaderGroups',\n        debug: () => {\n          var _instance$options$deb4;\n\n          return (_instance$options$deb4 = instance.options.debugAll) != null ? _instance$options$deb4 : instance.options.debugHeaders;\n        }\n      }),\n      // Footer Groups\n      getFooterGroups: memo(() => [instance.getHeaderGroups()], headerGroups => {\n        return [...headerGroups].reverse();\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getFooterGroups',\n        debug: () => {\n          var _instance$options$deb5;\n\n          return (_instance$options$deb5 = instance.options.debugAll) != null ? _instance$options$deb5 : instance.options.debugHeaders;\n        }\n      }),\n      getLeftFooterGroups: memo(() => [instance.getLeftHeaderGroups()], headerGroups => {\n        return [...headerGroups].reverse();\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getLeftFooterGroups',\n        debug: () => {\n          var _instance$options$deb6;\n\n          return (_instance$options$deb6 = instance.options.debugAll) != null ? _instance$options$deb6 : instance.options.debugHeaders;\n        }\n      }),\n      getCenterFooterGroups: memo(() => [instance.getCenterHeaderGroups()], headerGroups => {\n        return [...headerGroups].reverse();\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getCenterFooterGroups',\n        debug: () => {\n          var _instance$options$deb7;\n\n          return (_instance$options$deb7 = instance.options.debugAll) != null ? _instance$options$deb7 : instance.options.debugHeaders;\n        }\n      }),\n      getRightFooterGroups: memo(() => [instance.getRightHeaderGroups()], headerGroups => {\n        return [...headerGroups].reverse();\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getRightFooterGroups',\n        debug: () => {\n          var _instance$options$deb8;\n\n          return (_instance$options$deb8 = instance.options.debugAll) != null ? _instance$options$deb8 : instance.options.debugHeaders;\n        }\n      }),\n      // Flat Headers\n      getFlatHeaders: memo(() => [instance.getHeaderGroups()], headerGroups => {\n        return headerGroups.map(headerGroup => {\n          return headerGroup.headers;\n        }).flat();\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getFlatHeaders',\n        debug: () => {\n          var _instance$options$deb9;\n\n          return (_instance$options$deb9 = instance.options.debugAll) != null ? _instance$options$deb9 : instance.options.debugHeaders;\n        }\n      }),\n      getLeftFlatHeaders: memo(() => [instance.getLeftHeaderGroups()], left => {\n        return left.map(headerGroup => {\n          return headerGroup.headers;\n        }).flat();\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getLeftFlatHeaders',\n        debug: () => {\n          var _instance$options$deb10;\n\n          return (_instance$options$deb10 = instance.options.debugAll) != null ? _instance$options$deb10 : instance.options.debugHeaders;\n        }\n      }),\n      getCenterFlatHeaders: memo(() => [instance.getCenterHeaderGroups()], left => {\n        return left.map(headerGroup => {\n          return headerGroup.headers;\n        }).flat();\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getCenterFlatHeaders',\n        debug: () => {\n          var _instance$options$deb11;\n\n          return (_instance$options$deb11 = instance.options.debugAll) != null ? _instance$options$deb11 : instance.options.debugHeaders;\n        }\n      }),\n      getRightFlatHeaders: memo(() => [instance.getRightHeaderGroups()], left => {\n        return left.map(headerGroup => {\n          return headerGroup.headers;\n        }).flat();\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getRightFlatHeaders',\n        debug: () => {\n          var _instance$options$deb12;\n\n          return (_instance$options$deb12 = instance.options.debugAll) != null ? _instance$options$deb12 : instance.options.debugHeaders;\n        }\n      }),\n      // Leaf Headers\n      getCenterLeafHeaders: memo(() => [instance.getCenterFlatHeaders()], flatHeaders => {\n        return flatHeaders.filter(header => {\n          var _header$subHeaders;\n\n          return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);\n        });\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getCenterLeafHeaders',\n        debug: () => {\n          var _instance$options$deb13;\n\n          return (_instance$options$deb13 = instance.options.debugAll) != null ? _instance$options$deb13 : instance.options.debugHeaders;\n        }\n      }),\n      getLeftLeafHeaders: memo(() => [instance.getLeftFlatHeaders()], flatHeaders => {\n        return flatHeaders.filter(header => {\n          var _header$subHeaders2;\n\n          return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);\n        });\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getLeftLeafHeaders',\n        debug: () => {\n          var _instance$options$deb14;\n\n          return (_instance$options$deb14 = instance.options.debugAll) != null ? _instance$options$deb14 : instance.options.debugHeaders;\n        }\n      }),\n      getRightLeafHeaders: memo(() => [instance.getRightFlatHeaders()], flatHeaders => {\n        return flatHeaders.filter(header => {\n          var _header$subHeaders3;\n\n          return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);\n        });\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getRightLeafHeaders',\n        debug: () => {\n          var _instance$options$deb15;\n\n          return (_instance$options$deb15 = instance.options.debugAll) != null ? _instance$options$deb15 : instance.options.debugHeaders;\n        }\n      }),\n      getLeafHeaders: memo(() => [instance.getLeftHeaderGroups(), instance.getCenterHeaderGroups(), instance.getRightHeaderGroups()], (left, center, right) => {\n        var _left$0$headers, _left$, _center$0$headers, _center$, _right$0$headers, _right$;\n\n        return [...((_left$0$headers = (_left$ = left[0]) == null ? void 0 : _left$.headers) != null ? _left$0$headers : []), ...((_center$0$headers = (_center$ = center[0]) == null ? void 0 : _center$.headers) != null ? _center$0$headers : []), ...((_right$0$headers = (_right$ = right[0]) == null ? void 0 : _right$.headers) != null ? _right$0$headers : [])].map(header => {\n          return header.getLeafHeaders();\n        }).flat();\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getLeafHeaders',\n        debug: () => {\n          var _instance$options$deb16;\n\n          return (_instance$options$deb16 = instance.options.debugAll) != null ? _instance$options$deb16 : instance.options.debugHeaders;\n        }\n      })\n    };\n  }\n};\nfunction buildHeaderGroups(allColumns, columnsToGroup, instance, headerFamily) {\n  var _headerGroups$0$heade, _headerGroups$;\n\n  // Find the max depth of the columns:\n  // build the leaf column row\n  // build each buffer row going up\n  //    placeholder for non-existent level\n  //    real column for existing level\n  let maxDepth = 0;\n\n  const findMaxDepth = function (columns, depth) {\n    if (depth === void 0) {\n      depth = 1;\n    }\n\n    maxDepth = Math.max(maxDepth, depth);\n    columns.filter(column => column.getIsVisible()).forEach(column => {\n      var _column$columns;\n\n      if ((_column$columns = column.columns) != null && _column$columns.length) {\n        findMaxDepth(column.columns, depth + 1);\n      }\n    }, 0);\n  };\n\n  findMaxDepth(allColumns);\n  let headerGroups = [];\n\n  const createHeaderGroup = (headersToGroup, depth) => {\n    // The header group we are creating\n    const headerGroup = {\n      depth,\n      id: [headerFamily, \"\" + depth].filter(Boolean).join('_'),\n      headers: []\n    }; // The parent columns we're going to scan next\n\n    const pendingParentHeaders = []; // Scan each column for parents\n\n    headersToGroup.forEach(headerToGroup => {\n      // What is the latest (last) parent column?\n      const latestPendingParentHeader = [...pendingParentHeaders].reverse()[0];\n      const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;\n      let column;\n      let isPlaceholder = false;\n\n      if (isLeafHeader && headerToGroup.column.parent) {\n        // The parent header is new\n        column = headerToGroup.column.parent;\n      } else {\n        // The parent header is repeated\n        column = headerToGroup.column;\n        isPlaceholder = true;\n      }\n\n      if ((latestPendingParentHeader == null ? void 0 : latestPendingParentHeader.column) === column) {\n        // This column is repeated. Add it as a sub header to the next batch\n        latestPendingParentHeader.subHeaders.push(headerToGroup);\n      } else {\n        // This is a new header. Let's create it\n        const header = createHeader(instance, column, {\n          id: [headerFamily, depth, column.id, headerToGroup == null ? void 0 : headerToGroup.id].filter(Boolean).join('_'),\n          isPlaceholder,\n          placeholderId: isPlaceholder ? \"\" + pendingParentHeaders.filter(d => d.column === column).length : undefined,\n          depth,\n          index: pendingParentHeaders.length\n        }); // Add the headerToGroup as a subHeader of the new header\n\n        header.subHeaders.push(headerToGroup); // Add the new header to the pendingParentHeaders to get grouped\n        // in the next batch\n\n        pendingParentHeaders.push(header);\n      }\n\n      headerGroup.headers.push(headerToGroup);\n      headerToGroup.headerGroup = headerGroup;\n    });\n    headerGroups.push(headerGroup);\n\n    if (depth > 0) {\n      createHeaderGroup(pendingParentHeaders, depth - 1);\n    }\n  };\n\n  const bottomHeaders = columnsToGroup.map((column, index) => createHeader(instance, column, {\n    depth: maxDepth,\n    index\n  }));\n  createHeaderGroup(bottomHeaders, maxDepth - 1);\n  headerGroups.reverse(); // headerGroups = headerGroups.filter(headerGroup => {\n  //   return !headerGroup.headers.every(header => header.isPlaceholder)\n  // })\n\n  const recurseHeadersForSpans = headers => {\n    const filteredHeaders = headers.filter(header => header.column.getIsVisible());\n    return filteredHeaders.map(header => {\n      let colSpan = 0;\n      let rowSpan = 0;\n      let childRowSpans = [0];\n\n      if (header.subHeaders && header.subHeaders.length) {\n        childRowSpans = [];\n        recurseHeadersForSpans(header.subHeaders).forEach(_ref => {\n          let {\n            colSpan: childColSpan,\n            rowSpan: childRowSpan\n          } = _ref;\n          colSpan += childColSpan;\n          childRowSpans.push(childRowSpan);\n        });\n      } else {\n        colSpan = 1;\n      }\n\n      const minChildRowSpan = Math.min(...childRowSpans);\n      rowSpan = rowSpan + minChildRowSpan;\n      header.colSpan = colSpan;\n      header.rowSpan = rowSpan;\n      return {\n        colSpan,\n        rowSpan\n      };\n    });\n  };\n\n  recurseHeadersForSpans((_headerGroups$0$heade = (_headerGroups$ = headerGroups[0]) == null ? void 0 : _headerGroups$.headers) != null ? _headerGroups$0$heade : []);\n  return headerGroups;\n}\n\n//\nconst defaultColumnSizing = {\n  size: 150,\n  minSize: 20,\n  maxSize: Number.MAX_SAFE_INTEGER\n};\n\nconst getDefaultColumnSizingInfoState = () => ({\n  startOffset: null,\n  startSize: null,\n  deltaOffset: null,\n  deltaPercentage: null,\n  isResizingColumn: false,\n  columnSizingStart: []\n});\n\nconst ColumnSizing = {\n  getDefaultColumnDef: () => {\n    return defaultColumnSizing;\n  },\n  getInitialState: state => {\n    return {\n      columnSizing: {},\n      columnSizingInfo: getDefaultColumnSizingInfoState(),\n      ...state\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      columnResizeMode: 'onEnd',\n      onColumnSizingChange: makeStateUpdater('columnSizing', instance),\n      onColumnSizingInfoChange: makeStateUpdater('columnSizingInfo', instance)\n    };\n  },\n  createColumn: (column, instance) => {\n    return {\n      getSize: () => {\n        var _column$columnDef$min, _ref, _column$columnDef$max;\n\n        const columnSize = instance.getState().columnSizing[column.id];\n        return Math.min(Math.max((_column$columnDef$min = column.columnDef.minSize) != null ? _column$columnDef$min : defaultColumnSizing.minSize, (_ref = columnSize != null ? columnSize : column.columnDef.size) != null ? _ref : defaultColumnSizing.size), (_column$columnDef$max = column.columnDef.maxSize) != null ? _column$columnDef$max : defaultColumnSizing.maxSize);\n      },\n      getStart: position => {\n        const columns = !position ? instance.getVisibleLeafColumns() : position === 'left' ? instance.getLeftVisibleLeafColumns() : instance.getRightVisibleLeafColumns();\n        const index = columns.findIndex(d => d.id === column.id);\n\n        if (index > 0) {\n          const prevSiblingColumn = columns[index - 1];\n          return prevSiblingColumn.getStart(position) + prevSiblingColumn.getSize();\n        }\n\n        return 0;\n      },\n      resetSize: () => {\n        instance.setColumnSizing(_ref2 => {\n          let {\n            [column.id]: _,\n            ...rest\n          } = _ref2;\n          return rest;\n        });\n      },\n      getCanResize: () => {\n        var _column$columnDef$ena, _instance$options$ena;\n\n        return ((_column$columnDef$ena = column.columnDef.enableResizing) != null ? _column$columnDef$ena : true) && ((_instance$options$ena = instance.options.enableColumnResizing) != null ? _instance$options$ena : true);\n      },\n      getIsResizing: () => {\n        return instance.getState().columnSizingInfo.isResizingColumn === column.id;\n      }\n    };\n  },\n  createHeader: (header, instance) => {\n    return {\n      getSize: () => {\n        let sum = 0;\n\n        const recurse = header => {\n          if (header.subHeaders.length) {\n            header.subHeaders.forEach(recurse);\n          } else {\n            var _header$column$getSiz;\n\n            sum += (_header$column$getSiz = header.column.getSize()) != null ? _header$column$getSiz : 0;\n          }\n        };\n\n        recurse(header);\n        return sum;\n      },\n      getStart: () => {\n        if (header.index > 0) {\n          const prevSiblingHeader = header.headerGroup.headers[header.index - 1];\n          return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();\n        }\n\n        return 0;\n      },\n      getResizeHandler: () => {\n        const column = instance.getColumn(header.column.id);\n        const canResize = column.getCanResize();\n        return e => {\n          if (!canResize) {\n            return;\n          }\n          e.persist == null ? void 0 : e.persist();\n\n          if (isTouchStartEvent(e)) {\n            // lets not respond to multiple touches (e.g. 2 or 3 fingers)\n            if (e.touches && e.touches.length > 1) {\n              return;\n            }\n          }\n\n          const startSize = header.getSize();\n          const columnSizingStart = header ? header.getLeafHeaders().map(d => [d.column.id, d.column.getSize()]) : [[column.id, column.getSize()]];\n          const clientX = isTouchStartEvent(e) ? Math.round(e.touches[0].clientX) : e.clientX;\n\n          const updateOffset = (eventType, clientXPos) => {\n            if (typeof clientXPos !== 'number') {\n              return;\n            }\n\n            let newColumnSizing = {};\n            instance.setColumnSizingInfo(old => {\n              var _old$startOffset, _old$startSize;\n\n              const deltaOffset = clientXPos - ((_old$startOffset = old == null ? void 0 : old.startOffset) != null ? _old$startOffset : 0);\n              const deltaPercentage = Math.max(deltaOffset / ((_old$startSize = old == null ? void 0 : old.startSize) != null ? _old$startSize : 0), -0.999999);\n              old.columnSizingStart.forEach(_ref3 => {\n                let [columnId, headerSize] = _ref3;\n                newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;\n              });\n              return { ...old,\n                deltaOffset,\n                deltaPercentage\n              };\n            });\n\n            if (instance.options.columnResizeMode === 'onChange' || eventType === 'end') {\n              instance.setColumnSizing(old => ({ ...old,\n                ...newColumnSizing\n              }));\n            }\n          };\n\n          const onMove = clientXPos => updateOffset('move', clientXPos);\n\n          const onEnd = clientXPos => {\n            updateOffset('end', clientXPos);\n            instance.setColumnSizingInfo(old => ({ ...old,\n              isResizingColumn: false,\n              startOffset: null,\n              startSize: null,\n              deltaOffset: null,\n              deltaPercentage: null,\n              columnSizingStart: []\n            }));\n          };\n\n          const mouseEvents = {\n            moveHandler: e => onMove(e.clientX),\n            upHandler: e => {\n              document.removeEventListener('mousemove', mouseEvents.moveHandler);\n              document.removeEventListener('mouseup', mouseEvents.upHandler);\n              onEnd(e.clientX);\n            }\n          };\n          const passiveIfSupported = passiveEventSupported() ? {\n            passive: false\n          } : false;\n\n          if (isTouchStartEvent(e)) ; else {\n            document.addEventListener('mousemove', mouseEvents.moveHandler, passiveIfSupported);\n            document.addEventListener('mouseup', mouseEvents.upHandler, passiveIfSupported);\n          }\n\n          instance.setColumnSizingInfo(old => ({ ...old,\n            startOffset: clientX,\n            startSize,\n            deltaOffset: 0,\n            deltaPercentage: 0,\n            columnSizingStart,\n            isResizingColumn: column.id\n          }));\n        };\n      }\n    };\n  },\n  createInstance: instance => {\n    return {\n      setColumnSizing: updater => instance.options.onColumnSizingChange == null ? void 0 : instance.options.onColumnSizingChange(updater),\n      setColumnSizingInfo: updater => instance.options.onColumnSizingInfoChange == null ? void 0 : instance.options.onColumnSizingInfoChange(updater),\n      resetColumnSizing: defaultState => {\n        var _instance$initialStat;\n\n        instance.setColumnSizing(defaultState ? {} : (_instance$initialStat = instance.initialState.columnSizing) != null ? _instance$initialStat : {});\n      },\n      resetHeaderSizeInfo: defaultState => {\n        var _instance$initialStat2;\n\n        instance.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_instance$initialStat2 = instance.initialState.columnSizingInfo) != null ? _instance$initialStat2 : getDefaultColumnSizingInfoState());\n      },\n      getTotalSize: () => {\n        var _instance$getHeaderGr, _instance$getHeaderGr2;\n\n        return (_instance$getHeaderGr = (_instance$getHeaderGr2 = instance.getHeaderGroups()[0]) == null ? void 0 : _instance$getHeaderGr2.headers.reduce((sum, header) => {\n          return sum + header.getSize();\n        }, 0)) != null ? _instance$getHeaderGr : 0;\n      },\n      getLeftTotalSize: () => {\n        var _instance$getLeftHead, _instance$getLeftHead2;\n\n        return (_instance$getLeftHead = (_instance$getLeftHead2 = instance.getLeftHeaderGroups()[0]) == null ? void 0 : _instance$getLeftHead2.headers.reduce((sum, header) => {\n          return sum + header.getSize();\n        }, 0)) != null ? _instance$getLeftHead : 0;\n      },\n      getCenterTotalSize: () => {\n        var _instance$getCenterHe, _instance$getCenterHe2;\n\n        return (_instance$getCenterHe = (_instance$getCenterHe2 = instance.getCenterHeaderGroups()[0]) == null ? void 0 : _instance$getCenterHe2.headers.reduce((sum, header) => {\n          return sum + header.getSize();\n        }, 0)) != null ? _instance$getCenterHe : 0;\n      },\n      getRightTotalSize: () => {\n        var _instance$getRightHea, _instance$getRightHea2;\n\n        return (_instance$getRightHea = (_instance$getRightHea2 = instance.getRightHeaderGroups()[0]) == null ? void 0 : _instance$getRightHea2.headers.reduce((sum, header) => {\n          return sum + header.getSize();\n        }, 0)) != null ? _instance$getRightHea : 0;\n      }\n    };\n  }\n};\nlet passiveSupported = null;\nfunction passiveEventSupported() {\n  if (typeof passiveSupported === 'boolean') return passiveSupported;\n  let supported = false;\n\n  try {\n    const options = {\n      get passive() {\n        supported = true;\n        return false;\n      }\n\n    };\n\n    const noop = () => {};\n\n    window.addEventListener('test', noop, options);\n    window.removeEventListener('test', noop);\n  } catch (err) {\n    supported = false;\n  }\n\n  passiveSupported = supported;\n  return passiveSupported;\n}\n\nfunction isTouchStartEvent(e) {\n  return e.type === 'touchstart';\n}\n\n//\nconst Expanding = {\n  getInitialState: state => {\n    return {\n      expanded: {},\n      ...state\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      onExpandedChange: makeStateUpdater('expanded', instance),\n      autoResetExpanded: true,\n      paginateExpandedRows: true\n    };\n  },\n  createInstance: instance => {\n    let registered = false;\n    let queued = false;\n    return {\n      _autoResetExpanded: () => {\n        if (!registered) {\n          instance._queue(() => {\n            registered = true;\n          });\n\n          return;\n        }\n\n        if (instance.options.autoResetAll === false) {\n          return;\n        }\n\n        if (instance.options.autoResetAll === true || instance.options.autoResetExpanded) {\n          if (queued) return;\n          queued = true;\n\n          instance._queue(() => {\n            instance.resetExpanded();\n            queued = false;\n          });\n        }\n      },\n      setExpanded: updater => instance.options.onExpandedChange == null ? void 0 : instance.options.onExpandedChange(updater),\n      toggleAllRowsExpanded: expanded => {\n        if (expanded != null ? expanded : !instance.getIsAllRowsExpanded()) {\n          instance.setExpanded(true);\n        } else {\n          instance.setExpanded({});\n        }\n      },\n      resetExpanded: defaultState => {\n        var _instance$initialStat, _instance$initialStat2;\n\n        instance.setExpanded(defaultState ? {} : (_instance$initialStat = (_instance$initialStat2 = instance.initialState) == null ? void 0 : _instance$initialStat2.expanded) != null ? _instance$initialStat : {});\n      },\n      getCanSomeRowsExpand: () => {\n        return instance.getRowModel().flatRows.some(row => row.getCanExpand());\n      },\n      getToggleAllRowsExpandedHandler: () => {\n        return e => {\n          e.persist == null ? void 0 : e.persist();\n          instance.toggleAllRowsExpanded();\n        };\n      },\n      getIsSomeRowsExpanded: () => {\n        const expanded = instance.getState().expanded;\n        return expanded === true || Object.values(expanded).some(Boolean);\n      },\n      getIsAllRowsExpanded: () => {\n        const expanded = instance.getState().expanded; // If expanded is true, save some cycles and return true\n\n        if (typeof expanded === 'boolean') {\n          return expanded === true;\n        }\n\n        if (!Object.keys(expanded).length) {\n          return false;\n        } // If any row is not expanded, return false\n\n\n        if (instance.getRowModel().flatRows.some(row => row.getIsExpanded())) {\n          return false;\n        } // They must all be expanded :shrug:\n\n\n        return true;\n      },\n      getExpandedDepth: () => {\n        let maxDepth = 0;\n        const rowIds = instance.getState().expanded === true ? Object.keys(instance.getRowModel().rowsById) : Object.keys(instance.getState().expanded);\n        rowIds.forEach(id => {\n          const splitId = id.split('.');\n          maxDepth = Math.max(maxDepth, splitId.length);\n        });\n        return maxDepth;\n      },\n      getPreExpandedRowModel: () => instance.getGroupedRowModel(),\n      getExpandedRowModel: () => {\n        if (!instance._getExpandedRowModel && instance.options.getExpandedRowModel) {\n          instance._getExpandedRowModel = instance.options.getExpandedRowModel(instance);\n        }\n\n        if (instance.options.manualExpanding || !instance._getExpandedRowModel) {\n          return instance.getPreExpandedRowModel();\n        }\n\n        return instance._getExpandedRowModel();\n      }\n    };\n  },\n  createRow: (row, instance) => {\n    return {\n      toggleExpanded: expanded => {\n        instance.setExpanded(old => {\n          var _expanded;\n\n          const exists = old === true ? true : !!(old != null && old[row.id]);\n          let oldExpanded = {};\n\n          if (old === true) {\n            Object.keys(instance.getRowModel().rowsById).forEach(rowId => {\n              oldExpanded[rowId] = true;\n            });\n          } else {\n            oldExpanded = old;\n          }\n\n          expanded = (_expanded = expanded) != null ? _expanded : !exists;\n\n          if (!exists && expanded) {\n            return { ...oldExpanded,\n              [row.id]: true\n            };\n          }\n\n          if (exists && !expanded) {\n            const {\n              [row.id]: _,\n              ...rest\n            } = oldExpanded;\n            return rest;\n          }\n\n          return old;\n        });\n      },\n      getIsExpanded: () => {\n        var _instance$options$get;\n\n        const expanded = instance.getState().expanded;\n        return !!((_instance$options$get = instance.options.getIsRowExpanded == null ? void 0 : instance.options.getIsRowExpanded(row)) != null ? _instance$options$get : expanded === true || (expanded == null ? void 0 : expanded[row.id]));\n      },\n      getCanExpand: () => {\n        var _instance$options$get2, _instance$options$ena, _row$subRows;\n\n        return ((_instance$options$get2 = instance.options.getRowCanExpand == null ? void 0 : instance.options.getRowCanExpand(row)) != null ? _instance$options$get2 : true) && ((_instance$options$ena = instance.options.enableExpanding) != null ? _instance$options$ena : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);\n      },\n      getToggleExpandedHandler: () => {\n        const canExpand = row.getCanExpand();\n        return () => {\n          if (!canExpand) return;\n          row.toggleExpanded();\n        };\n      }\n    };\n  }\n};\n\nconst includesString = (row, columnId, filterValue) => {\n  const search = filterValue.toLowerCase();\n  return row.getValue(columnId).toLowerCase().includes(search);\n};\n\nincludesString.autoRemove = val => testFalsey(val);\n\nconst includesStringSensitive = (row, columnId, filterValue) => {\n  return row.getValue(columnId).includes(filterValue);\n};\n\nincludesStringSensitive.autoRemove = val => testFalsey(val);\n\nconst equalsString = (row, columnId, filterValue) => {\n  return row.getValue(columnId).toLowerCase() === filterValue.toLowerCase();\n};\n\nequalsString.autoRemove = val => testFalsey(val);\n\nconst arrIncludes = (row, columnId, filterValue) => {\n  return row.getValue(columnId).includes(filterValue);\n};\n\narrIncludes.autoRemove = val => testFalsey(val) || !(val != null && val.length);\n\nconst arrIncludesAll = (row, columnId, filterValue) => {\n  return !filterValue.some(val => !row.getValue(columnId).includes(val));\n};\n\narrIncludesAll.autoRemove = val => testFalsey(val) || !(val != null && val.length);\n\nconst arrIncludesSome = (row, columnId, filterValue) => {\n  return filterValue.some(val => row.getValue(columnId).includes(val));\n};\n\narrIncludesSome.autoRemove = val => testFalsey(val) || !(val != null && val.length);\n\nconst equals = (row, columnId, filterValue) => {\n  return row.getValue(columnId) === filterValue;\n};\n\nequals.autoRemove = val => testFalsey(val);\n\nconst weakEquals = (row, columnId, filterValue) => {\n  return row.getValue(columnId) == filterValue;\n};\n\nweakEquals.autoRemove = val => testFalsey(val);\n\nconst inNumberRange = (row, columnId, filterValue) => {\n  let [min, max] = filterValue;\n  const rowValue = row.getValue(columnId);\n  return rowValue >= min && rowValue <= max;\n};\n\ninNumberRange.resolveFilterValue = val => {\n  let [unsafeMin, unsafeMax] = val;\n  let parsedMin = typeof unsafeMin !== 'number' ? parseFloat(unsafeMin) : unsafeMin;\n  let parsedMax = typeof unsafeMax !== 'number' ? parseFloat(unsafeMax) : unsafeMax;\n  let min = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;\n  let max = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;\n\n  if (min > max) {\n    const temp = min;\n    min = max;\n    max = temp;\n  }\n\n  return [min, max];\n};\n\ninNumberRange.autoRemove = val => testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]); // Export\n\n\nconst filterFns = {\n  includesString,\n  includesStringSensitive,\n  equalsString,\n  arrIncludes,\n  arrIncludesAll,\n  arrIncludesSome,\n  equals,\n  weakEquals,\n  inNumberRange\n};\n\n// Utils\nfunction testFalsey(val) {\n  return val === undefined || val === null || val === '';\n}\n\n//\nconst Filters = {\n  getDefaultColumnDef: () => {\n    return {\n      filterFn: 'auto'\n    };\n  },\n  getInitialState: state => {\n    return {\n      columnFilters: [],\n      globalFilter: undefined,\n      // filtersProgress: 1,\n      // facetProgress: {},\n      ...state\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      onColumnFiltersChange: makeStateUpdater('columnFilters', instance),\n      onGlobalFilterChange: makeStateUpdater('globalFilter', instance),\n      filterFromLeafRows: false,\n      globalFilterFn: 'auto',\n      getColumnCanGlobalFilter: column => {\n        var _instance$getCoreRowM, _instance$getCoreRowM2;\n\n        const value = (_instance$getCoreRowM = instance.getCoreRowModel().flatRows[0]) == null ? void 0 : (_instance$getCoreRowM2 = _instance$getCoreRowM._getAllCellsByColumnId()[column.id]) == null ? void 0 : _instance$getCoreRowM2.getValue();\n        return typeof value === 'string';\n      }\n    };\n  },\n  createColumn: (column, instance) => {\n    return {\n      getAutoFilterFn: () => {\n        const firstRow = instance.getCoreRowModel().flatRows[0];\n        const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n\n        if (typeof value === 'string') {\n          return filterFns.includesString;\n        }\n\n        if (typeof value === 'number') {\n          return filterFns.inNumberRange;\n        }\n\n        if (typeof value === 'boolean') {\n          return filterFns.equals;\n        }\n\n        if (value !== null && typeof value === 'object') {\n          return filterFns.equals;\n        }\n\n        if (Array.isArray(value)) {\n          return filterFns.arrIncludes;\n        }\n\n        return filterFns.weakEquals;\n      },\n      getFilterFn: () => {\n        var _ref;\n\n        const userFilterFns = instance.options.filterFns;\n        return isFunction(column.columnDef.filterFn) ? column.columnDef.filterFn : column.columnDef.filterFn === 'auto' ? column.getAutoFilterFn() : (_ref = userFilterFns == null ? void 0 : userFilterFns[column.columnDef.filterFn]) != null ? _ref : filterFns[column.columnDef.filterFn];\n      },\n      getCanFilter: () => {\n        var _column$columnDef$ena, _instance$options$ena, _instance$options$ena2;\n\n        return ((_column$columnDef$ena = column.columnDef.enableColumnFilter) != null ? _column$columnDef$ena : true) && ((_instance$options$ena = instance.options.enableColumnFilters) != null ? _instance$options$ena : true) && ((_instance$options$ena2 = instance.options.enableFilters) != null ? _instance$options$ena2 : true) && !!column.accessorFn;\n      },\n      getCanGlobalFilter: () => {\n        var _column$columnDef$ena2, _instance$options$ena3, _instance$options$ena4, _instance$options$get;\n\n        return ((_column$columnDef$ena2 = column.columnDef.enableGlobalFilter) != null ? _column$columnDef$ena2 : true) && ((_instance$options$ena3 = instance.options.enableGlobalFilter) != null ? _instance$options$ena3 : true) && ((_instance$options$ena4 = instance.options.enableFilters) != null ? _instance$options$ena4 : true) && ((_instance$options$get = instance.options.getColumnCanGlobalFilter == null ? void 0 : instance.options.getColumnCanGlobalFilter(column)) != null ? _instance$options$get : true) && !!column.accessorFn;\n      },\n      getIsFiltered: () => column.getFilterIndex() > -1,\n      getFilterValue: () => {\n        var _instance$getState$co, _instance$getState$co2;\n\n        return (_instance$getState$co = instance.getState().columnFilters) == null ? void 0 : (_instance$getState$co2 = _instance$getState$co.find(d => d.id === column.id)) == null ? void 0 : _instance$getState$co2.value;\n      },\n      getFilterIndex: () => {\n        var _instance$getState$co3, _instance$getState$co4;\n\n        return (_instance$getState$co3 = (_instance$getState$co4 = instance.getState().columnFilters) == null ? void 0 : _instance$getState$co4.findIndex(d => d.id === column.id)) != null ? _instance$getState$co3 : -1;\n      },\n      setFilterValue: value => {\n        instance.setColumnFilters(old => {\n          const filterFn = column.getFilterFn();\n          const previousfilter = old == null ? void 0 : old.find(d => d.id === column.id);\n          const newFilter = functionalUpdate(value, previousfilter ? previousfilter.value : undefined); //\n\n          if (shouldAutoRemoveFilter(filterFn, newFilter, column)) {\n            var _old$filter;\n\n            return (_old$filter = old == null ? void 0 : old.filter(d => d.id !== column.id)) != null ? _old$filter : [];\n          }\n\n          const newFilterObj = {\n            id: column.id,\n            value: newFilter\n          };\n\n          if (previousfilter) {\n            var _old$map;\n\n            return (_old$map = old == null ? void 0 : old.map(d => {\n              if (d.id === column.id) {\n                return newFilterObj;\n              }\n\n              return d;\n            })) != null ? _old$map : [];\n          }\n\n          if (old != null && old.length) {\n            return [...old, newFilterObj];\n          }\n\n          return [newFilterObj];\n        });\n      },\n      _getFacetedRowModel: instance.options.getFacetedRowModel && instance.options.getFacetedRowModel(instance, column.id),\n      getFacetedRowModel: () => {\n        if (!column._getFacetedRowModel) {\n          return instance.getPreFilteredRowModel();\n        }\n\n        return column._getFacetedRowModel();\n      },\n      _getFacetedUniqueValues: instance.options.getFacetedUniqueValues && instance.options.getFacetedUniqueValues(instance, column.id),\n      getFacetedUniqueValues: () => {\n        if (!column._getFacetedUniqueValues) {\n          return new Map();\n        }\n\n        return column._getFacetedUniqueValues();\n      },\n      _getFacetedMinMaxValues: instance.options.getFacetedMinMaxValues && instance.options.getFacetedMinMaxValues(instance, column.id),\n      getFacetedMinMaxValues: () => {\n        if (!column._getFacetedMinMaxValues) {\n          return undefined;\n        }\n\n        return column._getFacetedMinMaxValues();\n      } // () => [column.getFacetedRowModel()],\n      // facetedRowModel => getRowModelMinMaxValues(facetedRowModel, column.id),\n\n    };\n  },\n  createRow: (row, instance) => {\n    return {\n      columnFilters: {},\n      columnFiltersMeta: {}\n    };\n  },\n  createInstance: instance => {\n    return {\n      getGlobalAutoFilterFn: () => {\n        return filterFns.includesString;\n      },\n      getGlobalFilterFn: () => {\n        var _ref2;\n\n        const {\n          filterFns: userFilterFns,\n          globalFilterFn: globalFilterFn\n        } = instance.options;\n        return isFunction(globalFilterFn) ? globalFilterFn : globalFilterFn === 'auto' ? instance.getGlobalAutoFilterFn() : (_ref2 = userFilterFns == null ? void 0 : userFilterFns[globalFilterFn]) != null ? _ref2 : filterFns[globalFilterFn];\n      },\n      setColumnFilters: updater => {\n        const leafColumns = instance.getAllLeafColumns();\n\n        const updateFn = old => {\n          var _functionalUpdate;\n\n          return (_functionalUpdate = functionalUpdate(updater, old)) == null ? void 0 : _functionalUpdate.filter(filter => {\n            const column = leafColumns.find(d => d.id === filter.id);\n\n            if (column) {\n              const filterFn = column.getFilterFn();\n\n              if (shouldAutoRemoveFilter(filterFn, filter.value, column)) {\n                return false;\n              }\n            }\n\n            return true;\n          });\n        };\n\n        instance.options.onColumnFiltersChange == null ? void 0 : instance.options.onColumnFiltersChange(updateFn);\n      },\n      setGlobalFilter: updater => {\n        instance.options.onGlobalFilterChange == null ? void 0 : instance.options.onGlobalFilterChange(updater);\n      },\n      resetGlobalFilter: defaultState => {\n        instance.setGlobalFilter(defaultState ? undefined : instance.initialState.globalFilter);\n      },\n      resetColumnFilters: defaultState => {\n        var _instance$initialStat, _instance$initialStat2;\n\n        instance.setColumnFilters(defaultState ? [] : (_instance$initialStat = (_instance$initialStat2 = instance.initialState) == null ? void 0 : _instance$initialStat2.columnFilters) != null ? _instance$initialStat : []);\n      },\n      getPreFilteredRowModel: () => instance.getCoreRowModel(),\n      _getFilteredRowModel: instance.options.getFilteredRowModel && instance.options.getFilteredRowModel(instance),\n      getFilteredRowModel: () => {\n        if (instance.options.manualFiltering || !instance._getFilteredRowModel) {\n          return instance.getPreFilteredRowModel();\n        }\n\n        return instance._getFilteredRowModel();\n      },\n      _getGlobalFacetedRowModel: instance.options.getFacetedRowModel && instance.options.getFacetedRowModel(instance, '__global__'),\n      getGlobalFacetedRowModel: () => {\n        if (instance.options.manualFiltering || !instance._getGlobalFacetedRowModel) {\n          return instance.getPreFilteredRowModel();\n        }\n\n        return instance._getGlobalFacetedRowModel();\n      },\n      _getGlobalFacetedUniqueValues: instance.options.getFacetedUniqueValues && instance.options.getFacetedUniqueValues(instance, '__global__'),\n      getGlobalFacetedUniqueValues: () => {\n        if (!instance._getGlobalFacetedUniqueValues) {\n          return new Map();\n        }\n\n        return instance._getGlobalFacetedUniqueValues();\n      },\n      _getGlobalFacetedMinMaxValues: instance.options.getFacetedMinMaxValues && instance.options.getFacetedMinMaxValues(instance, '__global__'),\n      getGlobalFacetedMinMaxValues: () => {\n        if (!instance._getGlobalFacetedMinMaxValues) {\n          return;\n        }\n\n        return instance._getGlobalFacetedMinMaxValues();\n      }\n    };\n  }\n};\nfunction shouldAutoRemoveFilter(filterFn, value, column) {\n  return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value, column) : false) || typeof value === 'undefined' || typeof value === 'string' && !value;\n}\n\nconst sum = (columnId, _leafRows, childRows) => {\n  // It's faster to just add the aggregations together instead of\n  // process leaf nodes individually\n  return childRows.reduce((sum, next) => sum + (typeof next === 'number' ? next : 0), 0);\n};\n\nconst min = (columnId, _leafRows, childRows) => {\n  let min;\n  childRows.forEach(row => {\n    const value = row.getValue(columnId);\n\n    if (value != null && (min > value || min === undefined && value >= value)) {\n      min = value;\n    }\n  });\n  return min;\n};\n\nconst max = (columnId, _leafRows, childRows) => {\n  let max;\n  childRows.forEach(row => {\n    const value = row.getValue(columnId);\n\n    if (value != null && (max < value || max === undefined && value >= value)) {\n      max = value;\n    }\n  });\n  return max;\n};\n\nconst extent = (columnId, _leafRows, childRows) => {\n  let min;\n  let max;\n  childRows.forEach(row => {\n    const value = row.getValue(columnId);\n\n    if (value != null) {\n      if (min === undefined) {\n        if (value >= value) min = max = value;\n      } else {\n        if (min > value) min = value;\n        if (max < value) max = value;\n      }\n    }\n  });\n  return [min, max];\n};\n\nconst mean = (columnId, leafRows) => {\n  let count = 0;\n  let sum = 0;\n  leafRows.forEach(row => {\n    let value = row.getValue(columnId);\n\n    if (value != null && (value = +value) >= value) {\n      ++count, sum += value;\n    }\n  });\n  if (count) return sum / count;\n  return;\n};\n\nconst median = (columnId, leafRows) => {\n  if (!leafRows.length) {\n    return;\n  }\n\n  let min = 0;\n  let max = 0;\n  leafRows.forEach(row => {\n    let value = row.getValue(columnId);\n\n    if (typeof value === 'number') {\n      min = Math.min(min, value);\n      max = Math.max(max, value);\n    }\n  });\n  return (min + max) / 2;\n};\n\nconst unique = (columnId, leafRows) => {\n  return Array.from(new Set(leafRows.map(d => d.getValue(columnId))).values());\n};\n\nconst uniqueCount = (columnId, leafRows) => {\n  return new Set(leafRows.map(d => d.getValue(columnId))).size;\n};\n\nconst count = (_columnId, leafRows) => {\n  return leafRows.length;\n};\n\nconst aggregationFns = {\n  sum,\n  min,\n  max,\n  extent,\n  mean,\n  median,\n  unique,\n  uniqueCount,\n  count\n};\n\n//\nconst Grouping = {\n  getDefaultColumnDef: () => {\n    return {\n      aggregatedCell: props => {\n        var _props$getValue$toStr, _props$getValue;\n\n        return (_props$getValue$toStr = (_props$getValue = props.getValue()) == null ? void 0 : _props$getValue.toString == null ? void 0 : _props$getValue.toString()) != null ? _props$getValue$toStr : null;\n      },\n      aggregationFn: 'auto'\n    };\n  },\n  getInitialState: state => {\n    return {\n      grouping: [],\n      ...state\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      onGroupingChange: makeStateUpdater('grouping', instance),\n      groupedColumnMode: 'reorder'\n    };\n  },\n  createColumn: (column, instance) => {\n    return {\n      toggleGrouping: () => {\n        instance.setGrouping(old => {\n          // Find any existing grouping for this column\n          if (old != null && old.includes(column.id)) {\n            return old.filter(d => d !== column.id);\n          }\n\n          return [...(old != null ? old : []), column.id];\n        });\n      },\n      getCanGroup: () => {\n        var _ref, _ref2, _ref3, _column$columnDef$ena;\n\n        return (_ref = (_ref2 = (_ref3 = (_column$columnDef$ena = column.columnDef.enableGrouping) != null ? _column$columnDef$ena : true) != null ? _ref3 : instance.options.enableGrouping) != null ? _ref2 : true) != null ? _ref : !!column.accessorFn;\n      },\n      getIsGrouped: () => {\n        var _instance$getState$gr;\n\n        return (_instance$getState$gr = instance.getState().grouping) == null ? void 0 : _instance$getState$gr.includes(column.id);\n      },\n      getGroupedIndex: () => {\n        var _instance$getState$gr2;\n\n        return (_instance$getState$gr2 = instance.getState().grouping) == null ? void 0 : _instance$getState$gr2.indexOf(column.id);\n      },\n      getToggleGroupingHandler: () => {\n        const canGroup = column.getCanGroup();\n        return () => {\n          if (!canGroup) return;\n          column.toggleGrouping();\n        };\n      },\n      getAutoAggregationFn: () => {\n        const firstRow = instance.getCoreRowModel().flatRows[0];\n        const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n\n        if (typeof value === 'number') {\n          return aggregationFns.sum;\n        }\n\n        if (Object.prototype.toString.call(value) === '[object Date]') {\n          return aggregationFns.extent;\n        }\n      },\n      getAggregationFn: () => {\n        var _ref4;\n\n        const userAggregationFns = instance.options.aggregationFns;\n\n        if (!column) {\n          throw new Error();\n        }\n\n        return isFunction(column.columnDef.aggregationFn) ? column.columnDef.aggregationFn : column.columnDef.aggregationFn === 'auto' ? column.getAutoAggregationFn() : (_ref4 = userAggregationFns == null ? void 0 : userAggregationFns[column.columnDef.aggregationFn]) != null ? _ref4 : aggregationFns[column.columnDef.aggregationFn];\n      }\n    };\n  },\n  createInstance: instance => {\n    return {\n      setGrouping: updater => instance.options.onGroupingChange == null ? void 0 : instance.options.onGroupingChange(updater),\n      resetGrouping: defaultState => {\n        var _instance$initialStat, _instance$initialStat2;\n\n        instance.setGrouping(defaultState ? [] : (_instance$initialStat = (_instance$initialStat2 = instance.initialState) == null ? void 0 : _instance$initialStat2.grouping) != null ? _instance$initialStat : []);\n      },\n      getPreGroupedRowModel: () => instance.getSortedRowModel(),\n      getGroupedRowModel: () => {\n        if (!instance._getGroupedRowModel && instance.options.getGroupedRowModel) {\n          instance._getGroupedRowModel = instance.options.getGroupedRowModel(instance);\n        }\n\n        if (instance.options.manualGrouping || !instance._getGroupedRowModel) {\n          return instance.getPreGroupedRowModel();\n        }\n\n        return instance._getGroupedRowModel();\n      }\n    };\n  },\n  createRow: row => {\n    return {\n      getIsGrouped: () => !!row.groupingColumnId,\n      _groupingValuesCache: {}\n    };\n  },\n  createCell: (cell, column, row, instance) => {\n    return {\n      getIsGrouped: () => column.getIsGrouped() && column.id === row.groupingColumnId,\n      getIsPlaceholder: () => !cell.getIsGrouped() && column.getIsGrouped(),\n      getIsAggregated: () => {\n        var _row$subRows;\n\n        return !cell.getIsGrouped() && !cell.getIsPlaceholder() && ((_row$subRows = row.subRows) == null ? void 0 : _row$subRows.length) > 1;\n      },\n      renderAggregatedCell: () => {\n        var _column$columnDef$agg;\n\n        const template = (_column$columnDef$agg = column.columnDef.aggregatedCell) != null ? _column$columnDef$agg : column.columnDef.cell;\n        return template ? instance._render(template, {\n          instance,\n          column,\n          row,\n          cell,\n          getValue: cell.getValue\n        }) : null;\n      }\n    };\n  }\n};\nfunction orderColumns(leafColumns, grouping, groupedColumnMode) {\n  if (!(grouping != null && grouping.length) || !groupedColumnMode) {\n    return leafColumns;\n  }\n\n  const nonGroupingColumns = leafColumns.filter(col => !grouping.includes(col.id));\n\n  if (groupedColumnMode === 'remove') {\n    return nonGroupingColumns;\n  }\n\n  const groupingColumns = grouping.map(g => leafColumns.find(col => col.id === g)).filter(Boolean);\n  return [...groupingColumns, ...nonGroupingColumns];\n}\n\n//\nconst Ordering = {\n  getInitialState: state => {\n    return {\n      columnOrder: [],\n      ...state\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      onColumnOrderChange: makeStateUpdater('columnOrder', instance)\n    };\n  },\n  createInstance: instance => {\n    return {\n      setColumnOrder: updater => instance.options.onColumnOrderChange == null ? void 0 : instance.options.onColumnOrderChange(updater),\n      resetColumnOrder: defaultState => {\n        var _instance$initialStat;\n\n        instance.setColumnOrder(defaultState ? [] : (_instance$initialStat = instance.initialState.columnOrder) != null ? _instance$initialStat : []);\n      },\n      _getOrderColumnsFn: memo(() => [instance.getState().columnOrder, instance.getState().grouping, instance.options.groupedColumnMode], (columnOrder, grouping, groupedColumnMode) => columns => {\n        // Sort grouped columns to the start of the column list\n        // before the headers are built\n        let orderedColumns = []; // If there is no order, return the normal columns\n\n        if (!(columnOrder != null && columnOrder.length)) {\n          orderedColumns = columns;\n        } else {\n          const columnOrderCopy = [...columnOrder]; // If there is an order, make a copy of the columns\n\n          const columnsCopy = [...columns]; // And make a new ordered array of the columns\n          // Loop over the columns and place them in order into the new array\n\n          while (columnsCopy.length && columnOrderCopy.length) {\n            const targetColumnId = columnOrderCopy.shift();\n            const foundIndex = columnsCopy.findIndex(d => d.id === targetColumnId);\n\n            if (foundIndex > -1) {\n              orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);\n            }\n          } // If there are any columns left, add them to the end\n\n\n          orderedColumns = [...orderedColumns, ...columnsCopy];\n        }\n\n        return orderColumns(orderedColumns, grouping, groupedColumnMode);\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getOrderColumnsFn' // debug: () => instance.options.debugAll ?? instance.options.debugTable,\n\n      })\n    };\n  }\n};\n\n//\nconst defaultPageIndex = 0;\nconst defaultPageSize = 10;\n\nconst getDefaultPaginationState = () => ({\n  pageIndex: defaultPageIndex,\n  pageSize: defaultPageSize\n});\n\nconst Pagination = {\n  getInitialState: state => {\n    return { ...state,\n      pagination: { ...getDefaultPaginationState(),\n        ...(state == null ? void 0 : state.pagination)\n      }\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      onPaginationChange: makeStateUpdater('pagination', instance)\n    };\n  },\n  createInstance: instance => {\n    let registered = false;\n    let queued = false;\n    return {\n      _autoResetPageIndex: () => {\n        var _ref, _instance$options$aut;\n\n        if (!registered) {\n          instance._queue(() => {\n            registered = true;\n          });\n\n          return;\n        }\n\n        if ((_ref = (_instance$options$aut = instance.options.autoResetAll) != null ? _instance$options$aut : instance.options.autoResetPageIndex) != null ? _ref : !instance.options.manualPagination) {\n          if (queued) return;\n          queued = true;\n\n          instance._queue(() => {\n            instance.resetPageIndex();\n            queued = false;\n          });\n        }\n      },\n      setPagination: updater => {\n        const safeUpdater = old => {\n          let newState = functionalUpdate(updater, old);\n          return newState;\n        };\n\n        return instance.options.onPaginationChange == null ? void 0 : instance.options.onPaginationChange(safeUpdater);\n      },\n      resetPagination: defaultState => {\n        var _instance$initialStat;\n\n        instance.setPagination(defaultState ? getDefaultPaginationState() : (_instance$initialStat = instance.initialState.pagination) != null ? _instance$initialStat : getDefaultPaginationState());\n      },\n      setPageIndex: updater => {\n        instance.setPagination(old => {\n          let pageIndex = functionalUpdate(updater, old.pageIndex);\n          const maxPageIndex = typeof old.pageCount !== 'undefined' ? old.pageCount - 1 : Number.MAX_SAFE_INTEGER;\n          pageIndex = Math.min(Math.max(0, pageIndex), maxPageIndex);\n          return { ...old,\n            pageIndex\n          };\n        });\n      },\n      resetPageIndex: defaultState => {\n        var _instance$initialStat2, _instance$initialStat3, _instance$initialStat4;\n\n        instance.setPageIndex(defaultState ? defaultPageIndex : (_instance$initialStat2 = (_instance$initialStat3 = instance.initialState) == null ? void 0 : (_instance$initialStat4 = _instance$initialStat3.pagination) == null ? void 0 : _instance$initialStat4.pageIndex) != null ? _instance$initialStat2 : defaultPageIndex);\n      },\n      resetPageSize: defaultState => {\n        var _instance$initialStat5, _instance$initialStat6, _instance$initialStat7;\n\n        instance.setPageSize(defaultState ? defaultPageSize : (_instance$initialStat5 = (_instance$initialStat6 = instance.initialState) == null ? void 0 : (_instance$initialStat7 = _instance$initialStat6.pagination) == null ? void 0 : _instance$initialStat7.pageSize) != null ? _instance$initialStat5 : defaultPageSize);\n      },\n      setPageSize: updater => {\n        instance.setPagination(old => {\n          const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize));\n          const topRowIndex = old.pageSize * old.pageIndex;\n          const pageIndex = Math.floor(topRowIndex / pageSize);\n          return { ...old,\n            pageIndex,\n            pageSize\n          };\n        });\n      },\n      setPageCount: updater => instance.setPagination(old => {\n        var _old$pageCount;\n\n        let newPageCount = functionalUpdate(updater, (_old$pageCount = old.pageCount) != null ? _old$pageCount : -1);\n\n        if (typeof newPageCount === 'number') {\n          newPageCount = Math.max(-1, newPageCount);\n        }\n\n        return { ...old,\n          pageCount: newPageCount\n        };\n      }),\n      getPageOptions: memo(() => [instance.getState().pagination.pageSize, instance.getState().pagination.pageCount], (pageSize, pageCount) => {\n        let pageOptions = [];\n\n        if (pageCount && pageCount > 0) {\n          pageOptions = [...new Array(pageCount)].fill(null).map((_, i) => i);\n        }\n\n        return pageOptions;\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getPageOptions',\n        debug: () => {\n          var _instance$options$deb;\n\n          return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n        }\n      }),\n      getCanPreviousPage: () => instance.getState().pagination.pageIndex > 0,\n      getCanNextPage: () => {\n        const {\n          pageIndex\n        } = instance.getState().pagination;\n        const pageCount = instance.getPageCount();\n\n        if (pageCount === -1) {\n          return true;\n        }\n\n        if (pageCount === 0) {\n          return false;\n        }\n\n        return pageIndex < pageCount - 1;\n      },\n      previousPage: () => {\n        return instance.setPageIndex(old => old - 1);\n      },\n      nextPage: () => {\n        return instance.setPageIndex(old => {\n          return old + 1;\n        });\n      },\n      getPrePaginationRowModel: () => instance.getExpandedRowModel(),\n      getPaginationRowModel: () => {\n        if (!instance._getPaginationRowModel && instance.options.getPaginationRowModel) {\n          instance._getPaginationRowModel = instance.options.getPaginationRowModel(instance);\n        }\n\n        if (instance.options.manualPagination || !instance._getPaginationRowModel) {\n          return instance.getPrePaginationRowModel();\n        }\n\n        return instance._getPaginationRowModel();\n      },\n      getPageCount: () => {\n        const {\n          pageCount\n        } = instance.getState().pagination;\n\n        if (typeof pageCount !== 'undefined') {\n          return pageCount;\n        }\n\n        return Math.ceil(instance.getPrePaginationRowModel().rows.length / instance.getState().pagination.pageSize);\n      }\n    };\n  }\n};\n\n//\nconst getDefaultPinningState = () => ({\n  left: [],\n  right: []\n});\n\nconst Pinning = {\n  getInitialState: state => {\n    return {\n      columnPinning: getDefaultPinningState(),\n      ...state\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      onColumnPinningChange: makeStateUpdater('columnPinning', instance)\n    };\n  },\n  createColumn: (column, instance) => {\n    return {\n      pin: position => {\n        const columnIds = column.getLeafColumns().map(d => d.id).filter(Boolean);\n        instance.setColumnPinning(old => {\n          var _old$left3, _old$right3;\n\n          if (position === 'right') {\n            var _old$left, _old$right;\n\n            return {\n              left: ((_old$left = old == null ? void 0 : old.left) != null ? _old$left : []).filter(d => !(columnIds != null && columnIds.includes(d))),\n              right: [...((_old$right = old == null ? void 0 : old.right) != null ? _old$right : []).filter(d => !(columnIds != null && columnIds.includes(d))), ...columnIds]\n            };\n          }\n\n          if (position === 'left') {\n            var _old$left2, _old$right2;\n\n            return {\n              left: [...((_old$left2 = old == null ? void 0 : old.left) != null ? _old$left2 : []).filter(d => !(columnIds != null && columnIds.includes(d))), ...columnIds],\n              right: ((_old$right2 = old == null ? void 0 : old.right) != null ? _old$right2 : []).filter(d => !(columnIds != null && columnIds.includes(d)))\n            };\n          }\n\n          return {\n            left: ((_old$left3 = old == null ? void 0 : old.left) != null ? _old$left3 : []).filter(d => !(columnIds != null && columnIds.includes(d))),\n            right: ((_old$right3 = old == null ? void 0 : old.right) != null ? _old$right3 : []).filter(d => !(columnIds != null && columnIds.includes(d)))\n          };\n        });\n      },\n      getCanPin: () => {\n        const leafColumns = column.getLeafColumns();\n        return leafColumns.some(d => {\n          var _d$columnDef$enablePi, _instance$options$ena;\n\n          return ((_d$columnDef$enablePi = d.columnDef.enablePinning) != null ? _d$columnDef$enablePi : true) && ((_instance$options$ena = instance.options.enablePinning) != null ? _instance$options$ena : true);\n        });\n      },\n      getIsPinned: () => {\n        const leafColumnIds = column.getLeafColumns().map(d => d.id);\n        const {\n          left,\n          right\n        } = instance.getState().columnPinning;\n        const isLeft = leafColumnIds.some(d => left == null ? void 0 : left.includes(d));\n        const isRight = leafColumnIds.some(d => right == null ? void 0 : right.includes(d));\n        return isLeft ? 'left' : isRight ? 'right' : false;\n      },\n      getPinnedIndex: () => {\n        var _instance$getState$co, _instance$getState$co2, _instance$getState$co3;\n\n        const position = column.getIsPinned();\n        return position ? (_instance$getState$co = (_instance$getState$co2 = instance.getState().columnPinning) == null ? void 0 : (_instance$getState$co3 = _instance$getState$co2[position]) == null ? void 0 : _instance$getState$co3.indexOf(column.id)) != null ? _instance$getState$co : -1 : 0;\n      }\n    };\n  },\n  createRow: (row, instance) => {\n    return {\n      getCenterVisibleCells: memo(() => [row._getAllVisibleCells(), instance.getState().columnPinning.left, instance.getState().columnPinning.right], (allCells, left, right) => {\n        const leftAndRight = [...(left != null ? left : []), ...(right != null ? right : [])];\n        return allCells.filter(d => !leftAndRight.includes(d.column.id));\n      }, {\n        key: process.env.NODE_ENV === 'production' && 'row.getCenterVisibleCells',\n        debug: () => {\n          var _instance$options$deb;\n\n          return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugRows;\n        }\n      }),\n      getLeftVisibleCells: memo(() => [row._getAllVisibleCells(), instance.getState().columnPinning.left,,], (allCells, left) => {\n        const cells = (left != null ? left : []).map(columnId => allCells.find(cell => cell.column.id === columnId)).filter(Boolean).map(d => ({ ...d,\n          position: 'left'\n        }));\n        return cells;\n      }, {\n        key: process.env.NODE_ENV === 'production' && 'row.getLeftVisibleCells',\n        debug: () => {\n          var _instance$options$deb2;\n\n          return (_instance$options$deb2 = instance.options.debugAll) != null ? _instance$options$deb2 : instance.options.debugRows;\n        }\n      }),\n      getRightVisibleCells: memo(() => [row._getAllVisibleCells(), instance.getState().columnPinning.right], (allCells, right) => {\n        const cells = (right != null ? right : []).map(columnId => allCells.find(cell => cell.column.id === columnId)).filter(Boolean).map(d => ({ ...d,\n          position: 'left'\n        }));\n        return cells;\n      }, {\n        key: process.env.NODE_ENV === 'production' && 'row.getRightVisibleCells',\n        debug: () => {\n          var _instance$options$deb3;\n\n          return (_instance$options$deb3 = instance.options.debugAll) != null ? _instance$options$deb3 : instance.options.debugRows;\n        }\n      })\n    };\n  },\n  createInstance: instance => {\n    return {\n      setColumnPinning: updater => instance.options.onColumnPinningChange == null ? void 0 : instance.options.onColumnPinningChange(updater),\n      resetColumnPinning: defaultState => {\n        var _instance$initialStat, _instance$initialStat2;\n\n        return instance.setColumnPinning(defaultState ? getDefaultPinningState() : (_instance$initialStat = (_instance$initialStat2 = instance.initialState) == null ? void 0 : _instance$initialStat2.columnPinning) != null ? _instance$initialStat : getDefaultPinningState());\n      },\n      getIsSomeColumnsPinned: position => {\n        var _pinningState$positio;\n\n        const pinningState = instance.getState().columnPinning;\n\n        if (!position) {\n          var _pinningState$left, _pinningState$right;\n\n          return Boolean(((_pinningState$left = pinningState.left) == null ? void 0 : _pinningState$left.length) || ((_pinningState$right = pinningState.right) == null ? void 0 : _pinningState$right.length));\n        }\n\n        return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);\n      },\n      getLeftLeafColumns: memo(() => [instance.getAllLeafColumns(), instance.getState().columnPinning.left], (allColumns, left) => {\n        return (left != null ? left : []).map(columnId => allColumns.find(column => column.id === columnId)).filter(Boolean);\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getLeftLeafColumns',\n        debug: () => {\n          var _instance$options$deb4;\n\n          return (_instance$options$deb4 = instance.options.debugAll) != null ? _instance$options$deb4 : instance.options.debugColumns;\n        }\n      }),\n      getRightLeafColumns: memo(() => [instance.getAllLeafColumns(), instance.getState().columnPinning.right], (allColumns, right) => {\n        return (right != null ? right : []).map(columnId => allColumns.find(column => column.id === columnId)).filter(Boolean);\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getRightLeafColumns',\n        debug: () => {\n          var _instance$options$deb5;\n\n          return (_instance$options$deb5 = instance.options.debugAll) != null ? _instance$options$deb5 : instance.options.debugColumns;\n        }\n      }),\n      getCenterLeafColumns: memo(() => [instance.getAllLeafColumns(), instance.getState().columnPinning.left, instance.getState().columnPinning.right], (allColumns, left, right) => {\n        const leftAndRight = [...(left != null ? left : []), ...(right != null ? right : [])];\n        return allColumns.filter(d => !leftAndRight.includes(d.id));\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getCenterLeafColumns',\n        debug: () => {\n          var _instance$options$deb6;\n\n          return (_instance$options$deb6 = instance.options.debugAll) != null ? _instance$options$deb6 : instance.options.debugColumns;\n        }\n      })\n    };\n  }\n};\n\n//\nconst RowSelection = {\n  getInitialState: state => {\n    return {\n      rowSelection: {},\n      ...state\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      onRowSelectionChange: makeStateUpdater('rowSelection', instance),\n      enableRowSelection: true,\n      enableMultiRowSelection: true,\n      enableSubRowSelection: true // enableGroupingRowSelection: false,\n      // isAdditiveSelectEvent: (e: unknown) => !!e.metaKey,\n      // isInclusiveSelectEvent: (e: unknown) => !!e.shiftKey,\n\n    };\n  },\n  createInstance: instance => {\n    return {\n      setRowSelection: updater => instance.options.onRowSelectionChange == null ? void 0 : instance.options.onRowSelectionChange(updater),\n      resetRowSelection: defaultState => {\n        var _instance$initialStat;\n\n        return instance.setRowSelection(defaultState ? {} : (_instance$initialStat = instance.initialState.rowSelection) != null ? _instance$initialStat : {});\n      },\n      toggleAllRowsSelected: value => {\n        instance.setRowSelection(old => {\n          value = typeof value !== 'undefined' ? value : !instance.getIsAllRowsSelected();\n          const rowSelection = { ...old\n          };\n          const preGroupedFlatRows = instance.getPreGroupedRowModel().flatRows; // We don't use `mutateRowIsSelected` here for performance reasons.\n          // All of the rows are flat already, so it wouldn't be worth it\n\n          if (value) {\n            preGroupedFlatRows.forEach(row => {\n              rowSelection[row.id] = true;\n            });\n          } else {\n            preGroupedFlatRows.forEach(row => {\n              delete rowSelection[row.id];\n            });\n          }\n\n          return rowSelection;\n        });\n      },\n      toggleAllPageRowsSelected: value => instance.setRowSelection(old => {\n        typeof value !== 'undefined' ? value : !instance.getIsAllPageRowsSelected();\n        const rowSelection = { ...old\n        };\n        instance.getRowModel().rows.forEach(row => {\n          mutateRowIsSelected(rowSelection, row.id, value, instance);\n        });\n        return rowSelection;\n      }),\n      // addRowSelectionRange: rowId => {\n      //   const {\n      //     rows,\n      //     rowsById,\n      //     options: { selectGroupingRows, selectSubRows },\n      //   } = instance\n      //   const findSelectedRow = (rows: Row[]) => {\n      //     let found\n      //     rows.find(d => {\n      //       if (d.getIsSelected()) {\n      //         found = d\n      //         return true\n      //       }\n      //       const subFound = findSelectedRow(d.subRows || [])\n      //       if (subFound) {\n      //         found = subFound\n      //         return true\n      //       }\n      //       return false\n      //     })\n      //     return found\n      //   }\n      //   const firstRow = findSelectedRow(rows) || rows[0]\n      //   const lastRow = rowsById[rowId]\n      //   let include = false\n      //   const selectedRowIds = {}\n      //   const addRow = (row: Row) => {\n      //     mutateRowIsSelected(selectedRowIds, row.id, true, {\n      //       rowsById,\n      //       selectGroupingRows: selectGroupingRows!,\n      //       selectSubRows: selectSubRows!,\n      //     })\n      //   }\n      //   instance.rows.forEach(row => {\n      //     const isFirstRow = row.id === firstRow.id\n      //     const isLastRow = row.id === lastRow.id\n      //     if (isFirstRow || isLastRow) {\n      //       if (!include) {\n      //         include = true\n      //       } else if (include) {\n      //         addRow(row)\n      //         include = false\n      //       }\n      //     }\n      //     if (include) {\n      //       addRow(row)\n      //     }\n      //   })\n      //   instance.setRowSelection(selectedRowIds)\n      // },\n      getPreSelectedRowModel: () => instance.getCoreRowModel(),\n      getSelectedRowModel: memo(() => [instance.getState().rowSelection, instance.getCoreRowModel()], (rowSelection, rowModel) => {\n        if (!Object.keys(rowSelection).length) {\n          return {\n            rows: [],\n            flatRows: [],\n            rowsById: {}\n          };\n        }\n\n        return selectRowsFn(instance, rowModel);\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getSelectedRowModel',\n        debug: () => {\n          var _instance$options$deb;\n\n          return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n        }\n      }),\n      getFilteredSelectedRowModel: memo(() => [instance.getState().rowSelection, instance.getFilteredRowModel()], (rowSelection, rowModel) => {\n        if (!Object.keys(rowSelection).length) {\n          return {\n            rows: [],\n            flatRows: [],\n            rowsById: {}\n          };\n        }\n\n        return selectRowsFn(instance, rowModel);\n      }, {\n        key: process.env.NODE_ENV === 'production' && 'getFilteredSelectedRowModel',\n        debug: () => {\n          var _instance$options$deb2;\n\n          return (_instance$options$deb2 = instance.options.debugAll) != null ? _instance$options$deb2 : instance.options.debugTable;\n        }\n      }),\n      getGroupedSelectedRowModel: memo(() => [instance.getState().rowSelection, instance.getGroupedRowModel()], (rowSelection, rowModel) => {\n        if (!Object.keys(rowSelection).length) {\n          return {\n            rows: [],\n            flatRows: [],\n            rowsById: {}\n          };\n        }\n\n        return selectRowsFn(instance, rowModel);\n      }, {\n        key: process.env.NODE_ENV === 'production' && 'getGroupedSelectedRowModel',\n        debug: () => {\n          var _instance$options$deb3;\n\n          return (_instance$options$deb3 = instance.options.debugAll) != null ? _instance$options$deb3 : instance.options.debugTable;\n        }\n      }),\n      ///\n      // getGroupingRowCanSelect: rowId => {\n      //   const row = instance.getRow(rowId)\n      //   if (!row) {\n      //     throw new Error()\n      //   }\n      //   if (typeof instance.options.enableGroupingRowSelection === 'function') {\n      //     return instance.options.enableGroupingRowSelection(row)\n      //   }\n      //   return instance.options.enableGroupingRowSelection ?? false\n      // },\n      getIsAllRowsSelected: () => {\n        const preFilteredFlatRows = instance.getPreFilteredRowModel().flatRows;\n        const {\n          rowSelection\n        } = instance.getState();\n        let isAllRowsSelected = Boolean(preFilteredFlatRows.length && Object.keys(rowSelection).length);\n\n        if (isAllRowsSelected) {\n          if (preFilteredFlatRows.some(row => !rowSelection[row.id])) {\n            isAllRowsSelected = false;\n          }\n        }\n\n        return isAllRowsSelected;\n      },\n      getIsAllPageRowsSelected: () => {\n        const paginationFlatRows = instance.getPaginationRowModel().flatRows;\n        const {\n          rowSelection\n        } = instance.getState();\n        let isAllPageRowsSelected = !!paginationFlatRows.length;\n\n        if (isAllPageRowsSelected && paginationFlatRows.some(row => !rowSelection[row.id])) {\n          isAllPageRowsSelected = false;\n        }\n\n        return isAllPageRowsSelected;\n      },\n      getIsSomeRowsSelected: () => {\n        var _instance$getState$ro;\n\n        return !instance.getIsAllRowsSelected() && !!Object.keys((_instance$getState$ro = instance.getState().rowSelection) != null ? _instance$getState$ro : {}).length;\n      },\n      getIsSomePageRowsSelected: () => {\n        const paginationFlatRows = instance.getPaginationRowModel().flatRows;\n        return instance.getIsAllPageRowsSelected() ? false : !!(paginationFlatRows != null && paginationFlatRows.length);\n      },\n      getToggleAllRowsSelectedHandler: () => {\n        return e => {\n          instance.toggleAllRowsSelected(e.target.checked);\n        };\n      },\n      getToggleAllPageRowsSelectedHandler: () => {\n        return e => {\n          instance.toggleAllPageRowsSelected(e.target.checked);\n        };\n      }\n    };\n  },\n  createRow: (row, instance) => {\n    return {\n      toggleSelected: value => {\n        const isSelected = row.getIsSelected();\n        instance.setRowSelection(old => {\n          value = typeof value !== 'undefined' ? value : !isSelected;\n\n          if (isSelected === value) {\n            return old;\n          }\n\n          const selectedRowIds = { ...old\n          };\n          mutateRowIsSelected(selectedRowIds, row.id, value, instance);\n          return selectedRowIds;\n        });\n      },\n      getIsSelected: () => {\n        const {\n          rowSelection\n        } = instance.getState();\n        return isRowSelected(row, rowSelection) === true;\n      },\n      getIsSomeSelected: () => {\n        const {\n          rowSelection\n        } = instance.getState();\n        return isRowSelected(row, rowSelection) === 'some';\n      },\n      getCanSelect: () => {\n        var _instance$options$ena;\n\n        if (typeof instance.options.enableRowSelection === 'function') {\n          return instance.options.enableRowSelection(row);\n        }\n\n        return (_instance$options$ena = instance.options.enableRowSelection) != null ? _instance$options$ena : true;\n      },\n      getCanSelectSubRows: () => {\n        var _instance$options$ena2;\n\n        if (typeof instance.options.enableSubRowSelection === 'function') {\n          return instance.options.enableSubRowSelection(row);\n        }\n\n        return (_instance$options$ena2 = instance.options.enableSubRowSelection) != null ? _instance$options$ena2 : true;\n      },\n      getCanMultiSelect: () => {\n        var _instance$options$ena3;\n\n        if (typeof instance.options.enableMultiRowSelection === 'function') {\n          return instance.options.enableMultiRowSelection(row);\n        }\n\n        return (_instance$options$ena3 = instance.options.enableMultiRowSelection) != null ? _instance$options$ena3 : true;\n      },\n      getToggleSelectedHandler: () => {\n        const canSelect = row.getCanSelect();\n        return e => {\n          var _target;\n\n          if (!canSelect) return;\n          row.toggleSelected((_target = e.target) == null ? void 0 : _target.checked);\n        };\n      }\n    };\n  }\n};\n\nconst mutateRowIsSelected = (selectedRowIds, id, value, instance) => {\n  var _row$subRows;\n\n  const row = instance.getRow(id);\n  row.getIsGrouped(); // if ( // TODO: enforce grouping row selection rules\n  //   !isGrouped ||\n  //   (isGrouped && instance.options.enableGroupingRowSelection)\n  // ) {\n\n  if (value) {\n    selectedRowIds[id] = true;\n  } else {\n    delete selectedRowIds[id];\n  } // }\n\n\n  if ((_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) {\n    row.subRows.forEach(row => mutateRowIsSelected(selectedRowIds, row.id, value, instance));\n  }\n};\n\nfunction selectRowsFn(instance, rowModel) {\n  const rowSelection = instance.getState().rowSelection;\n  const newSelectedFlatRows = [];\n  const newSelectedRowsById = {}; // Filters top level and nested rows\n\n  const recurseRows = function (rows, depth) {\n    if (depth === void 0) {\n      depth = 0;\n    }\n\n    return rows.map(row => {\n      var _row$subRows2;\n\n      const isSelected = isRowSelected(row, rowSelection) === true;\n\n      if (isSelected) {\n        newSelectedFlatRows.push(row);\n        newSelectedRowsById[row.id] = row;\n      }\n\n      if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {\n        row = { ...row,\n          subRows: recurseRows(row.subRows, depth + 1)\n        };\n      }\n\n      if (isSelected) {\n        return row;\n      }\n    }).filter(Boolean);\n  };\n\n  return {\n    rows: recurseRows(rowModel.rows),\n    flatRows: newSelectedFlatRows,\n    rowsById: newSelectedRowsById\n  };\n}\nfunction isRowSelected(row, selection, instance) {\n  if (selection[row.id]) {\n    return true;\n  }\n\n  if (row.subRows && row.subRows.length) {\n    let allChildrenSelected = true;\n    let someSelected = false;\n    row.subRows.forEach(subRow => {\n      // Bail out early if we know both of these\n      if (someSelected && !allChildrenSelected) {\n        return;\n      }\n\n      if (isRowSelected(subRow, selection)) {\n        someSelected = true;\n      } else {\n        allChildrenSelected = false;\n      }\n    });\n    return allChildrenSelected ? true : someSelected ? 'some' : false;\n  }\n\n  return false;\n}\n\nconst reSplitAlphaNumeric = /([0-9]+)/gm;\n\nconst alphanumeric = (rowA, rowB, columnId) => {\n  return compareAlphanumeric(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\n};\n\nconst alphanumericCaseSensitive = (rowA, rowB, columnId) => {\n  return compareAlphanumeric(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\n}; // The text filter is more basic (less numeric support)\n// but is much faster\n\n\nconst text = (rowA, rowB, columnId) => {\n  return compareBasic(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\n}; // The text filter is more basic (less numeric support)\n// but is much faster\n\n\nconst textCaseSensitive = (rowA, rowB, columnId) => {\n  return compareBasic(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\n};\n\nconst datetime = (rowA, rowB, columnId) => {\n  return compareBasic(rowA.getValue(columnId).getTime(), rowB.getValue(columnId).getTime());\n};\n\nconst basic = (rowA, rowB, columnId) => {\n  return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));\n}; // Utils\n\n\nfunction compareBasic(a, b) {\n  return a === b ? 0 : a > b ? 1 : -1;\n}\n\nfunction toString(a) {\n  if (typeof a === 'number') {\n    if (isNaN(a) || a === Infinity || a === -Infinity) {\n      return '';\n    }\n\n    return String(a);\n  }\n\n  if (typeof a === 'string') {\n    return a;\n  }\n\n  return '';\n} // Mixed sorting is slow, but very inclusive of many edge cases.\n// It handles numbers, mixed alphanumeric combinations, and even\n// null, undefined, and Infinity\n\n\nfunction compareAlphanumeric(aStr, bStr) {\n  // Split on number groups, but keep the delimiter\n  // Then remove falsey split values\n  const a = aStr.split(reSplitAlphaNumeric).filter(Boolean);\n  const b = bStr.split(reSplitAlphaNumeric).filter(Boolean); // While\n\n  while (a.length && b.length) {\n    const aa = a.shift();\n    const bb = b.shift();\n    const an = parseInt(aa, 10);\n    const bn = parseInt(bb, 10);\n    const combo = [an, bn].sort(); // Both are string\n\n    if (isNaN(combo[0])) {\n      if (aa > bb) {\n        return 1;\n      }\n\n      if (bb > aa) {\n        return -1;\n      }\n\n      continue;\n    } // One is a string, one is a number\n\n\n    if (isNaN(combo[1])) {\n      return isNaN(an) ? -1 : 1;\n    } // Both are numbers\n\n\n    if (an > bn) {\n      return 1;\n    }\n\n    if (bn > an) {\n      return -1;\n    }\n  }\n\n  return a.length - b.length;\n} // Exports\n\n\nconst sortingFns = {\n  alphanumeric,\n  alphanumericCaseSensitive,\n  text,\n  textCaseSensitive,\n  datetime,\n  basic\n};\n\n//\nconst Sorting = {\n  getInitialState: state => {\n    return {\n      sorting: [],\n      ...state\n    };\n  },\n  getDefaultColumnDef: () => {\n    return {\n      sortingFn: 'auto'\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      onSortingChange: makeStateUpdater('sorting', instance),\n      isMultiSortEvent: e => {\n        return e.shiftKey;\n      }\n    };\n  },\n  createColumn: (column, instance) => {\n    return {\n      getAutoSortingFn: () => {\n        const firstRows = instance.getFilteredRowModel().flatRows.slice(10);\n        let isString = false;\n\n        for (const row of firstRows) {\n          const value = row == null ? void 0 : row.getValue(column.id);\n\n          if (Object.prototype.toString.call(value) === '[object Date]') {\n            return sortingFns.datetime;\n          }\n\n          if (typeof value === 'string') {\n            isString = true;\n\n            if (value.split(reSplitAlphaNumeric).length > 1) {\n              return sortingFns.alphanumeric;\n            }\n          }\n        }\n\n        if (isString) {\n          return sortingFns.text;\n        }\n\n        return sortingFns.basic;\n      },\n      getAutoSortDir: () => {\n        const firstRow = instance.getFilteredRowModel().flatRows[0];\n        const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n\n        if (typeof value === 'string') {\n          return 'asc';\n        }\n\n        return 'desc';\n      },\n      getSortingFn: () => {\n        var _ref;\n\n        const userSortingFn = instance.options.sortingFns;\n\n        if (!column) {\n          throw new Error();\n        }\n\n        return isFunction(column.columnDef.sortingFn) ? column.columnDef.sortingFn : column.columnDef.sortingFn === 'auto' ? column.getAutoSortingFn() : (_ref = userSortingFn == null ? void 0 : userSortingFn[column.columnDef.sortingFn]) != null ? _ref : sortingFns[column.columnDef.sortingFn];\n      },\n      toggleSorting: (desc, multi) => {\n        // if (column.columns.length) {\n        //   column.columns.forEach((c, i) => {\n        //     if (c.id) {\n        //       instance.toggleColumnSorting(c.id, undefined, multi || !!i)\n        //     }\n        //   })\n        //   return\n        // }\n        instance.setSorting(old => {\n          var _ref2, _column$columnDef$sor, _instance$options$ena, _instance$options$ena2;\n\n          // Find any existing sorting for this column\n          const existingSorting = old == null ? void 0 : old.find(d => d.id === column.id);\n          const existingIndex = old == null ? void 0 : old.findIndex(d => d.id === column.id);\n          const hasDescDefined = typeof desc !== 'undefined' && desc !== null;\n          let newSorting = []; // What should we do with this sort action?\n\n          let sortAction;\n\n          if (column.getCanMultiSort() && multi) {\n            if (existingSorting) {\n              sortAction = 'toggle';\n            } else {\n              sortAction = 'add';\n            }\n          } else {\n            // Normal mode\n            if (old != null && old.length && existingIndex !== old.length - 1) {\n              sortAction = 'replace';\n            } else if (existingSorting) {\n              sortAction = 'toggle';\n            } else {\n              sortAction = 'replace';\n            }\n          }\n\n          const sortDescFirst = (_ref2 = (_column$columnDef$sor = column.columnDef.sortDescFirst) != null ? _column$columnDef$sor : instance.options.sortDescFirst) != null ? _ref2 : column.getAutoSortDir() === 'desc'; // Handle toggle states that will remove the sorting\n\n          if (sortAction === 'toggle' && ( // Must be toggling\n          (_instance$options$ena = instance.options.enableSortingRemoval) != null ? _instance$options$ena : true) && // If enableSortRemove, enable in general\n          !hasDescDefined && ( // Must not be setting desc\n          multi ? (_instance$options$ena2 = instance.options.enableMultiRemove) != null ? _instance$options$ena2 : true : true) && ( // If multi, don't allow if enableMultiRemove\n          existingSorting != null && existingSorting.desc // Finally, detect if it should indeed be removed\n          ? !sortDescFirst : sortDescFirst)) {\n            sortAction = 'remove';\n          }\n\n          if (sortAction === 'replace') {\n            newSorting = [{\n              id: column.id,\n              desc: hasDescDefined ? desc : !!sortDescFirst\n            }];\n          } else if (sortAction === 'add' && old != null && old.length) {\n            var _instance$options$max;\n\n            newSorting = [...old, {\n              id: column.id,\n              desc: hasDescDefined ? desc : !!sortDescFirst\n            }]; // Take latest n columns\n\n            newSorting.splice(0, newSorting.length - ((_instance$options$max = instance.options.maxMultiSortColCount) != null ? _instance$options$max : Number.MAX_SAFE_INTEGER));\n          } else if (sortAction === 'toggle' && old != null && old.length) {\n            // This flips (or sets) the\n            newSorting = old.map(d => {\n              if (d.id === column.id) {\n                return { ...d,\n                  desc: hasDescDefined ? desc : !(existingSorting != null && existingSorting.desc)\n                };\n              }\n\n              return d;\n            });\n          } else if (sortAction === 'remove' && old != null && old.length) {\n            newSorting = old.filter(d => d.id !== column.id);\n          }\n\n          return newSorting;\n        });\n      },\n      getCanSort: () => {\n        var _column$columnDef$ena, _instance$options$ena3;\n\n        return ((_column$columnDef$ena = column.columnDef.enableSorting) != null ? _column$columnDef$ena : true) && ((_instance$options$ena3 = instance.options.enableSorting) != null ? _instance$options$ena3 : true) && !!column.accessorFn;\n      },\n      getCanMultiSort: () => {\n        var _ref3, _column$columnDef$ena2;\n\n        return (_ref3 = (_column$columnDef$ena2 = column.columnDef.enableMultiSort) != null ? _column$columnDef$ena2 : instance.options.enableMultiSort) != null ? _ref3 : !!column.accessorFn;\n      },\n      getIsSorted: () => {\n        var _instance$getState$so;\n\n        const columnSort = (_instance$getState$so = instance.getState().sorting) == null ? void 0 : _instance$getState$so.find(d => d.id === column.id);\n        return !columnSort ? false : columnSort.desc ? 'desc' : 'asc';\n      },\n      getSortIndex: () => {\n        var _instance$getState$so2, _instance$getState$so3;\n\n        return (_instance$getState$so2 = (_instance$getState$so3 = instance.getState().sorting) == null ? void 0 : _instance$getState$so3.findIndex(d => d.id === column.id)) != null ? _instance$getState$so2 : -1;\n      },\n      clearSorting: () => {\n        //clear sorting for just 1 column\n        instance.setSorting(old => old != null && old.length ? old.filter(d => d.id !== column.id) : []);\n      },\n      getToggleSortingHandler: () => {\n        const canSort = column.getCanSort();\n        return e => {\n          if (!canSort) return;\n          e.persist == null ? void 0 : e.persist();\n          column.toggleSorting == null ? void 0 : column.toggleSorting(undefined, column.getCanMultiSort() ? instance.options.isMultiSortEvent == null ? void 0 : instance.options.isMultiSortEvent(e) : false);\n        };\n      }\n    };\n  },\n  createInstance: instance => {\n    return {\n      setSorting: updater => instance.options.onSortingChange == null ? void 0 : instance.options.onSortingChange(updater),\n      resetSorting: defaultState => {\n        var _instance$initialStat, _instance$initialStat2;\n\n        instance.setSorting(defaultState ? [] : (_instance$initialStat = (_instance$initialStat2 = instance.initialState) == null ? void 0 : _instance$initialStat2.sorting) != null ? _instance$initialStat : []);\n      },\n      getPreSortedRowModel: () => instance.getFilteredRowModel(),\n      getSortedRowModel: () => {\n        if (!instance._getSortedRowModel && instance.options.getSortedRowModel) {\n          instance._getSortedRowModel = instance.options.getSortedRowModel(instance);\n        }\n\n        if (instance.options.manualSorting || !instance._getSortedRowModel) {\n          return instance.getPreSortedRowModel();\n        }\n\n        return instance._getSortedRowModel();\n      }\n    };\n  }\n};\n\n//\nconst Visibility = {\n  getInitialState: state => {\n    return {\n      columnVisibility: {},\n      ...state\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      onColumnVisibilityChange: makeStateUpdater('columnVisibility', instance)\n    };\n  },\n  createColumn: (column, instance) => {\n    return {\n      toggleVisibility: value => {\n        if (column.getCanHide()) {\n          instance.setColumnVisibility(old => ({ ...old,\n            [column.id]: value != null ? value : !column.getIsVisible()\n          }));\n        }\n      },\n      getIsVisible: () => {\n        var _instance$getState$co, _instance$getState$co2;\n\n        return (_instance$getState$co = (_instance$getState$co2 = instance.getState().columnVisibility) == null ? void 0 : _instance$getState$co2[column.id]) != null ? _instance$getState$co : true;\n      },\n      getCanHide: () => {\n        var _column$columnDef$ena, _instance$options$ena;\n\n        return ((_column$columnDef$ena = column.columnDef.enableHiding) != null ? _column$columnDef$ena : true) && ((_instance$options$ena = instance.options.enableHiding) != null ? _instance$options$ena : true);\n      },\n      getToggleVisibilityHandler: () => {\n        return e => {\n          column.toggleVisibility == null ? void 0 : column.toggleVisibility(e.target.checked);\n        };\n      }\n    };\n  },\n  createRow: (row, instance) => {\n    return {\n      _getAllVisibleCells: memo(() => [row.getAllCells(), instance.getState().columnVisibility], cells => {\n        return cells.filter(cell => cell.column.getIsVisible());\n      }, {\n        key: process.env.NODE_ENV === 'production' && 'row._getAllVisibleCells',\n        debug: () => {\n          var _instance$options$deb;\n\n          return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugRows;\n        }\n      }),\n      getVisibleCells: memo(() => [row.getLeftVisibleCells(), row.getCenterVisibleCells(), row.getRightVisibleCells()], (left, center, right) => [...left, ...center, ...right], {\n        key: process.env.NODE_ENV === 'development' && 'row.getVisibleCells',\n        debug: () => {\n          var _instance$options$deb2;\n\n          return (_instance$options$deb2 = instance.options.debugAll) != null ? _instance$options$deb2 : instance.options.debugRows;\n        }\n      })\n    };\n  },\n  createInstance: instance => {\n    const makeVisibleColumnsMethod = (key, getColumns) => {\n      return memo(() => [getColumns(), getColumns().filter(d => d.getIsVisible()).map(d => d.id).join('_')], columns => {\n        return columns.filter(d => d.getIsVisible == null ? void 0 : d.getIsVisible());\n      }, {\n        key,\n        debug: () => {\n          var _instance$options$deb3;\n\n          return (_instance$options$deb3 = instance.options.debugAll) != null ? _instance$options$deb3 : instance.options.debugColumns;\n        }\n      });\n    };\n\n    return {\n      getVisibleFlatColumns: makeVisibleColumnsMethod('getVisibleFlatColumns', () => instance.getAllFlatColumns()),\n      getVisibleLeafColumns: makeVisibleColumnsMethod('getVisibleLeafColumns', () => instance.getAllLeafColumns()),\n      getLeftVisibleLeafColumns: makeVisibleColumnsMethod('getLeftVisibleLeafColumns', () => instance.getLeftLeafColumns()),\n      getRightVisibleLeafColumns: makeVisibleColumnsMethod('getRightVisibleLeafColumns', () => instance.getRightLeafColumns()),\n      getCenterVisibleLeafColumns: makeVisibleColumnsMethod('getCenterVisibleLeafColumns', () => instance.getCenterLeafColumns()),\n      setColumnVisibility: updater => instance.options.onColumnVisibilityChange == null ? void 0 : instance.options.onColumnVisibilityChange(updater),\n      resetColumnVisibility: defaultState => {\n        var _instance$initialStat;\n\n        instance.setColumnVisibility(defaultState ? {} : (_instance$initialStat = instance.initialState.columnVisibility) != null ? _instance$initialStat : {});\n      },\n      toggleAllColumnsVisible: value => {\n        var _value;\n\n        value = (_value = value) != null ? _value : !instance.getIsAllColumnsVisible();\n        instance.setColumnVisibility(instance.getAllLeafColumns().reduce((obj, column) => ({ ...obj,\n          [column.id]: !value ? !(column.getCanHide != null && column.getCanHide()) : value\n        }), {}));\n      },\n      getIsAllColumnsVisible: () => !instance.getAllLeafColumns().some(column => !(column.getIsVisible != null && column.getIsVisible())),\n      getIsSomeColumnsVisible: () => instance.getAllLeafColumns().some(column => column.getIsVisible == null ? void 0 : column.getIsVisible()),\n      getToggleAllColumnsVisibilityHandler: () => {\n        return e => {\n          var _target;\n\n          instance.toggleAllColumnsVisible((_target = e.target) == null ? void 0 : _target.checked);\n        };\n      }\n    };\n  }\n};\n\nconst features = [Headers, Visibility, Ordering, Pinning, Filters, Sorting, Grouping, Expanding, Pagination, RowSelection, ColumnSizing]; //\n\nfunction createTableInstance(options) {\n  var _options$initialState;\n\n  if (options.debugAll || options.debugTable) {\n    console.info('Creating Table Instance...');\n  }\n\n  let instance = {\n    _features: features\n  };\n\n  const defaultOptions = instance._features.reduce((obj, feature) => {\n    return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(instance));\n  }, {});\n\n  const mergeOptions = options => {\n    if (instance.options.mergeOptions) {\n      return instance.options.mergeOptions(defaultOptions, options);\n    }\n\n    return { ...defaultOptions,\n      ...options\n    };\n  };\n\n  const coreInitialState = {};\n  let initialState = { ...coreInitialState,\n    ...((_options$initialState = options.initialState) != null ? _options$initialState : {})\n  };\n\n  instance._features.forEach(feature => {\n    var _feature$getInitialSt;\n\n    initialState = (_feature$getInitialSt = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState)) != null ? _feature$getInitialSt : initialState;\n  });\n\n  const queued = [];\n  let queuedTimeout = false;\n  const coreInstance = {\n    _features: features,\n    options: { ...defaultOptions,\n      ...options\n    },\n    initialState,\n    _queue: cb => {\n      queued.push(cb);\n\n      if (!queuedTimeout) {\n        queuedTimeout = true; // Schedule a microtask to run the queued callbacks after\n        // the current call stack (render, etc) has finished.\n\n        Promise.resolve().then(() => {\n          while (queued.length) {\n            queued.shift()();\n          }\n\n          queuedTimeout = false;\n        }).catch(error => setTimeout(() => {\n          throw error;\n        }));\n      }\n    },\n    reset: () => {\n      instance.setState(instance.initialState);\n    },\n    setOptions: updater => {\n      const newOptions = functionalUpdate(updater, instance.options);\n      instance.options = mergeOptions(newOptions);\n    },\n    _render: (template, props) => {\n      if (typeof instance.options.render === 'function') {\n        return instance.options.render(template, props);\n      }\n\n      if (typeof template === 'function') {\n        return template(props);\n      }\n\n      return template;\n    },\n    getState: () => {\n      return instance.options.state;\n    },\n    setState: updater => {\n      instance.options.onStateChange == null ? void 0 : instance.options.onStateChange(updater);\n    },\n    _getRowId: (row, index, parent) => {\n      var _instance$options$get;\n\n      return (_instance$options$get = instance.options.getRowId == null ? void 0 : instance.options.getRowId(row, index, parent)) != null ? _instance$options$get : \"\" + (parent ? [parent.id, index].join('.') : index);\n    },\n    getCoreRowModel: () => {\n      if (!instance._getCoreRowModel) {\n        instance._getCoreRowModel = instance.options.getCoreRowModel(instance);\n      }\n\n      return instance._getCoreRowModel();\n    },\n    // The final calls start at the bottom of the model,\n    // expanded rows, which then work their way up\n    getRowModel: () => {\n      return instance.getPaginationRowModel();\n    },\n    getRow: id => {\n      const row = instance.getRowModel().rowsById[id];\n\n      if (!row) {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error(\"getRow expected an ID, but got \" + id);\n        }\n\n        throw new Error();\n      }\n\n      return row;\n    },\n    _getDefaultColumnDef: memo(() => [instance.options.defaultColumn], defaultColumn => {\n      var _defaultColumn;\n\n      defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};\n      return {\n        header: props => props.header.column.id,\n        footer: props => props.header.column.id,\n        cell: props => {\n          var _props$getValue$toStr, _props$getValue;\n\n          return (_props$getValue$toStr = (_props$getValue = props.getValue()) == null ? void 0 : _props$getValue.toString == null ? void 0 : _props$getValue.toString()) != null ? _props$getValue$toStr : null;\n        },\n        ...instance._features.reduce((obj, feature) => {\n          return Object.assign(obj, feature.getDefaultColumnDef == null ? void 0 : feature.getDefaultColumnDef());\n        }, {}),\n        ...defaultColumn\n      };\n    }, {\n      debug: () => {\n        var _instance$options$deb;\n\n        return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugColumns;\n      },\n      key: process.env.NODE_ENV === 'development' && 'getDefaultColumnDef'\n    }),\n    _getColumnDefs: () => instance.options.columns,\n    getAllColumns: memo(() => [instance._getColumnDefs()], columnDefs => {\n      const recurseColumns = function (columnDefs, parent, depth) {\n        if (depth === void 0) {\n          depth = 0;\n        }\n\n        return columnDefs.map(columnDef => {\n          const column = createColumn(instance, columnDef, depth, parent);\n          column.columns = columnDef.columns ? recurseColumns(columnDef.columns, column, depth + 1) : [];\n          return column;\n        });\n      };\n\n      return recurseColumns(columnDefs);\n    }, {\n      key: process.env.NODE_ENV === 'development' && 'getAllColumns',\n      debug: () => {\n        var _instance$options$deb2;\n\n        return (_instance$options$deb2 = instance.options.debugAll) != null ? _instance$options$deb2 : instance.options.debugColumns;\n      }\n    }),\n    getAllFlatColumns: memo(() => [instance.getAllColumns()], allColumns => {\n      return allColumns.flatMap(column => {\n        return column.getFlatColumns();\n      });\n    }, {\n      key: process.env.NODE_ENV === 'development' && 'getAllFlatColumns',\n      debug: () => {\n        var _instance$options$deb3;\n\n        return (_instance$options$deb3 = instance.options.debugAll) != null ? _instance$options$deb3 : instance.options.debugColumns;\n      }\n    }),\n    _getAllFlatColumnsById: memo(() => [instance.getAllFlatColumns()], flatColumns => {\n      return flatColumns.reduce((acc, column) => {\n        acc[column.id] = column;\n        return acc;\n      }, {});\n    }, {\n      key: process.env.NODE_ENV === 'development' && 'getAllFlatColumnsById',\n      debug: () => {\n        var _instance$options$deb4;\n\n        return (_instance$options$deb4 = instance.options.debugAll) != null ? _instance$options$deb4 : instance.options.debugColumns;\n      }\n    }),\n    getAllLeafColumns: memo(() => [instance.getAllColumns(), instance._getOrderColumnsFn()], (allColumns, orderColumns) => {\n      let leafColumns = allColumns.flatMap(column => column.getLeafColumns());\n      return orderColumns(leafColumns);\n    }, {\n      key: process.env.NODE_ENV === 'development' && 'getAllLeafColumns',\n      debug: () => {\n        var _instance$options$deb5;\n\n        return (_instance$options$deb5 = instance.options.debugAll) != null ? _instance$options$deb5 : instance.options.debugColumns;\n      }\n    }),\n    getColumn: columnId => {\n      const column = instance._getAllFlatColumnsById()[columnId];\n\n      if (!column) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\"[Table] Column with id \" + columnId + \" does not exist.\");\n        }\n\n        throw new Error();\n      }\n\n      return column;\n    }\n  };\n  Object.assign(instance, coreInstance);\n\n  instance._features.forEach(feature => {\n    return Object.assign(instance, feature.createInstance == null ? void 0 : feature.createInstance(instance));\n  });\n\n  return instance;\n}\n\n//\nfunction createTableFactory(opts) {\n  return () => createTable(undefined, undefined, opts);\n} // A lot of returns in here are `as any` for a reason. Unless you\n// can find a better way to do this, then don't worry about them\n\nfunction createTable(_, __, options) {\n  const table = {\n    generics: undefined,\n    options: options != null ? options : {\n      render: (() => {\n        throw new Error('');\n      })()\n    },\n    // setGenerics: () => table as any,\n    setRowType: () => table,\n    setTableMetaType: () => table,\n    setColumnMetaType: () => table,\n    setFilterMetaType: () => table,\n    setOptions: newOptions => createTable(_, __, { ...options,\n      ...newOptions\n    }),\n    createDisplayColumn: column => ({ ...column,\n      columnDefType: 'display'\n    }),\n    createGroup: column => ({ ...column,\n      columnDefType: 'group'\n    }),\n    createDataColumn: (accessor, column) => {\n      column = { ...column,\n        columnDefType: 'data',\n        id: column.id\n      };\n\n      if (typeof accessor === 'string') {\n        var _column$id;\n\n        return { ...column,\n          id: (_column$id = column.id) != null ? _column$id : accessor,\n          accessorKey: accessor\n        };\n      }\n\n      if (typeof accessor === 'function') {\n        return { ...column,\n          accessorFn: accessor\n        };\n      }\n\n      throw new Error('Invalid accessor');\n    },\n    createOptions: options => options\n  };\n  return table;\n}\n\nfunction createCell(instance, row, column, columnId) {\n  const cell = {\n    id: row.id + \"_\" + column.id,\n    row,\n    column,\n    getValue: () => row.getValue(columnId),\n    renderCell: () => {\n      return column.columnDef.cell ? instance._render(column.columnDef.cell, {\n        instance,\n        column,\n        row,\n        cell: cell,\n        getValue: cell.getValue\n      }) : null;\n    }\n  };\n\n  instance._features.forEach(feature => {\n    Object.assign(cell, feature.createCell == null ? void 0 : feature.createCell(cell, column, row, instance));\n  }, {});\n\n  return cell;\n}\n\nconst createRow = (instance, id, original, rowIndex, depth, subRows) => {\n  let row = {\n    id,\n    index: rowIndex,\n    original,\n    depth,\n    _valuesCache: {},\n    getValue: columnId => {\n      if (row._valuesCache.hasOwnProperty(columnId)) {\n        return row._valuesCache[columnId];\n      }\n\n      const column = instance.getColumn(columnId);\n\n      if (!column.accessorFn) {\n        return undefined;\n      }\n\n      row._valuesCache[columnId] = column.accessorFn(row.original, rowIndex);\n      return row._valuesCache[columnId];\n    },\n    subRows: subRows != null ? subRows : [],\n    getLeafRows: () => flattenBy(row.subRows, d => d.subRows),\n    getAllCells: memo(() => [instance.getAllLeafColumns()], leafColumns => {\n      return leafColumns.map(column => {\n        return createCell(instance, row, column, column.id);\n      });\n    }, {\n      key: process.env.NODE_ENV === 'development' && 'row.getAllCells',\n      debug: () => {\n        var _instance$options$deb;\n\n        return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugRows;\n      }\n    }),\n    _getAllCellsByColumnId: memo(() => [row.getAllCells()], allCells => {\n      return allCells.reduce((acc, cell) => {\n        acc[cell.column.id] = cell;\n        return acc;\n      }, {});\n    }, {\n      key: process.env.NODE_ENV === 'production' && 'row.getAllCellsByColumnId',\n      debug: () => {\n        var _instance$options$deb2;\n\n        return (_instance$options$deb2 = instance.options.debugAll) != null ? _instance$options$deb2 : instance.options.debugRows;\n      }\n    })\n  };\n\n  for (let i = 0; i < instance._features.length; i++) {\n    const feature = instance._features[i];\n    Object.assign(row, feature == null ? void 0 : feature.createRow == null ? void 0 : feature.createRow(row, instance));\n  }\n\n  return row;\n};\n\nfunction getCoreRowModel() {\n  return instance => memo(() => [instance.options.data], data => {\n    const rowModel = {\n      rows: [],\n      flatRows: [],\n      rowsById: {}\n    };\n\n    const accessRows = function (originalRows, depth, parent) {\n      if (depth === void 0) {\n        depth = 0;\n      }\n\n      const rows = [];\n\n      for (let i = 0; i < originalRows.length; i++) {\n        // This could be an expensive check at scale, so we should move it somewhere else, but where?\n        // if (!id) {\n        //   if (process.env.NODE_ENV !== 'production') {\n        //     throw new Error(`getRowId expected an ID, but got ${id}`)\n        //   }\n        // }\n        // Make the row\n        const row = createRow(instance, instance._getRowId(originalRows[i], i, parent), originalRows[i], i, depth); // Keep track of every row in a flat array\n\n        rowModel.flatRows.push(row); // Also keep track of every row by its ID\n\n        rowModel.rowsById[row.id] = row; // Push instance row into parent\n\n        rows.push(row); // Get the original subrows\n\n        if (instance.options.getSubRows) {\n          var _row$originalSubRows;\n\n          row.originalSubRows = instance.options.getSubRows(originalRows[i], i); // Then recursively access them\n\n          if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) {\n            row.subRows = accessRows(row.originalSubRows, depth + 1, row);\n          }\n        }\n      }\n\n      return rows;\n    };\n\n    rowModel.rows = accessRows(data);\n    return rowModel;\n  }, {\n    key: process.env.NODE_ENV === 'development' && 'getRowModel',\n    debug: () => {\n      var _instance$options$deb;\n\n      return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n    },\n    onChange: () => {\n      instance._autoResetPageIndex();\n    }\n  });\n}\n\nfunction filterRows(rows, filterRowImpl, instance) {\n  if (instance.options.filterFromLeafRows) {\n    return filterRowModelFromLeafs(rows, filterRowImpl, instance);\n  }\n\n  return filterRowModelFromRoot(rows, filterRowImpl, instance);\n}\nfunction filterRowModelFromLeafs(rowsToFilter, filterRow, instance) {\n  const newFilteredFlatRows = [];\n  const newFilteredRowsById = {};\n  let row;\n  let newRow;\n\n  const recurseFilterRows = function (rowsToFilter, depth) {\n    if (depth === void 0) {\n      depth = 0;\n    }\n\n    const rows = []; // Filter from children up first\n\n    for (let i = 0; i < rowsToFilter.length; i++) {\n      var _row$subRows;\n\n      row = rowsToFilter[i];\n\n      if ((_row$subRows = row.subRows) != null && _row$subRows.length) {\n        newRow = createRow(instance, row.id, row.original, row.index, row.depth);\n        newRow.columnFilters = row.columnFilters;\n        newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\n\n        if (!newRow.subRows.length) {\n          continue;\n        }\n\n        row = newRow;\n      }\n\n      if (filterRow(row)) {\n        rows.push(row);\n        newFilteredRowsById[row.id] = row;\n        newFilteredRowsById[i] = row;\n      }\n    }\n\n    return rows;\n  };\n\n  return {\n    rows: recurseFilterRows(rowsToFilter),\n    flatRows: newFilteredFlatRows,\n    rowsById: newFilteredRowsById\n  };\n}\nfunction filterRowModelFromRoot(rowsToFilter, filterRow, instance) {\n  const newFilteredFlatRows = [];\n  const newFilteredRowsById = {};\n  let rows;\n  let row;\n  let newRow; // Filters top level and nested rows\n\n  const recurseFilterRows = function (rowsToFilter, depth) {\n    if (depth === void 0) {\n      depth = 0;\n    }\n\n    // Filter from parents downward first\n    rows = []; // Apply the filter to any subRows\n\n    for (let i = 0; i < rowsToFilter.length; i++) {\n      row = rowsToFilter[i];\n      const pass = filterRow(row);\n\n      if (pass) {\n        var _row$subRows2;\n\n        if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {\n          newRow = createRow(instance, row.id, row.original, row.index, row.depth);\n          newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\n          row = newRow;\n        }\n\n        rows.push(row);\n        newFilteredFlatRows.push(row);\n        newFilteredRowsById[row.id] = row;\n      }\n    }\n\n    return rows;\n  };\n\n  return {\n    rows: recurseFilterRows(rowsToFilter),\n    flatRows: newFilteredFlatRows,\n    rowsById: newFilteredRowsById\n  };\n}\n\nfunction getFilteredRowModel() {\n  return instance => memo(() => [instance.getPreFilteredRowModel(), instance.getState().columnFilters, instance.getState().globalFilter], (rowModel, columnFilters, globalFilter) => {\n    if (!rowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\n      for (let i = 0; i < rowModel.flatRows.length; i++) {\n        rowModel.flatRows[i].columnFilters = {};\n        rowModel.flatRows[i].columnFiltersMeta = {};\n      }\n\n      return rowModel;\n    }\n\n    const resolvedColumnFilters = [];\n    const resolvedGlobalFilters = [];\n    (columnFilters != null ? columnFilters : []).forEach(d => {\n      var _filterFn$resolveFilt;\n\n      const column = instance.getColumn(d.id);\n\n      if (!column) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\"Table: Could not find a column to filter with columnId: \" + d.id);\n        }\n      }\n\n      const filterFn = column.getFilterFn();\n\n      if (!filterFn) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\"Could not find a valid 'column.filterFn' for column with the ID: \" + column.id + \".\");\n        }\n\n        return;\n      }\n\n      resolvedColumnFilters.push({\n        id: d.id,\n        filterFn,\n        resolvedValue: (_filterFn$resolveFilt = filterFn.resolveFilterValue == null ? void 0 : filterFn.resolveFilterValue(d.value)) != null ? _filterFn$resolveFilt : d.value\n      });\n    });\n    const filterableIds = columnFilters.map(d => d.id);\n    const globalFilterFn = instance.getGlobalFilterFn();\n    const globallyFilterableColumns = instance.getAllLeafColumns().filter(column => column.getCanGlobalFilter());\n\n    if (globalFilter && globalFilterFn && globallyFilterableColumns.length) {\n      filterableIds.push('__global__');\n      globallyFilterableColumns.forEach(column => {\n        var _globalFilterFn$resol;\n\n        resolvedGlobalFilters.push({\n          id: column.id,\n          filterFn: globalFilterFn,\n          resolvedValue: (_globalFilterFn$resol = globalFilterFn.resolveFilterValue == null ? void 0 : globalFilterFn.resolveFilterValue(globalFilter)) != null ? _globalFilterFn$resol : globalFilter\n        });\n      });\n    }\n\n    let currentColumnFilter;\n    let currentGlobalFilter; // Flag the prefiltered row model with each filter state\n\n    for (let j = 0; j < rowModel.flatRows.length; j++) {\n      const row = rowModel.flatRows[j];\n      row.columnFilters = {};\n\n      if (resolvedColumnFilters.length) {\n        for (let i = 0; i < resolvedColumnFilters.length; i++) {\n          currentColumnFilter = resolvedColumnFilters[i];\n          const id = currentColumnFilter.id; // Tag the row with the column filter state\n\n          row.columnFilters[id] = currentColumnFilter.filterFn(row, id, currentColumnFilter.resolvedValue, filterMeta => {\n            row.columnFiltersMeta[id] = filterMeta;\n          });\n        }\n      }\n\n      if (resolvedGlobalFilters.length) {\n        for (let i = 0; i < resolvedGlobalFilters.length; i++) {\n          currentGlobalFilter = resolvedGlobalFilters[i];\n          const id = currentGlobalFilter.id; // Tag the row with the first truthy global filter state\n\n          if (currentGlobalFilter.filterFn(row, id, currentGlobalFilter.resolvedValue, filterMeta => {\n            row.columnFiltersMeta[id] = filterMeta;\n          })) {\n            row.columnFilters.__global__ = true;\n            break;\n          }\n        }\n\n        if (row.columnFilters.__global__ !== true) {\n          row.columnFilters.__global__ = false;\n        }\n      }\n    }\n\n    const filterRowsImpl = row => {\n      // Horizontally filter rows through each column\n      for (let i = 0; i < filterableIds.length; i++) {\n        if (row.columnFilters[filterableIds[i]] === false) {\n          return false;\n        }\n      }\n\n      return true;\n    }; // Filter final rows using all of the active filters\n\n\n    return filterRows(rowModel.rows, filterRowsImpl, instance);\n  }, {\n    key: process.env.NODE_ENV === 'development' && 'getFilteredRowModel',\n    debug: () => {\n      var _instance$options$deb;\n\n      return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n    },\n    onChange: () => {\n      instance._autoResetPageIndex();\n    }\n  });\n}\n\nfunction getFacetedRowModel() {\n  return (instance, columnId) => memo(() => [instance.getPreFilteredRowModel(), instance.getState().columnFilters, instance.getState().globalFilter, instance.getFilteredRowModel()], (preRowModel, columnFilters, globalFilter) => {\n    if (!preRowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\n      return preRowModel;\n    }\n\n    const filterableIds = [...columnFilters.map(d => d.id).filter(d => d !== columnId), globalFilter ? '__global__' : undefined].filter(Boolean);\n\n    const filterRowsImpl = row => {\n      // Horizontally filter rows through each column\n      for (let i = 0; i < filterableIds.length; i++) {\n        if (row.columnFilters[filterableIds[i]] === false) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    return filterRows(preRowModel.rows, filterRowsImpl, instance);\n  }, {\n    key: process.env.NODE_ENV === 'development' && 'getFacetedRowModel_' + columnId,\n    debug: () => {\n      var _instance$options$deb;\n\n      return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n    },\n    onChange: () => {}\n  });\n}\n\nfunction getFacetedUniqueValues() {\n  return (instance, columnId) => memo(() => [instance.getColumn(columnId).getFacetedRowModel()], facetedRowModel => {\n    let facetedUniqueValues = new Map();\n\n    for (let i = 0; i < facetedRowModel.flatRows.length; i++) {\n      var _facetedRowModel$flat;\n\n      const value = (_facetedRowModel$flat = facetedRowModel.flatRows[i]) == null ? void 0 : _facetedRowModel$flat.getValue(columnId);\n\n      if (facetedUniqueValues.has(value)) {\n        var _facetedUniqueValues$;\n\n        facetedUniqueValues.set(value, ((_facetedUniqueValues$ = facetedUniqueValues.get(value)) != null ? _facetedUniqueValues$ : 0) + 1);\n      } else {\n        facetedUniqueValues.set(value, 1);\n      }\n    }\n\n    return facetedUniqueValues;\n  }, {\n    key: process.env.NODE_ENV === 'development' && 'getFacetedUniqueValues_' + columnId,\n    debug: () => {\n      var _instance$options$deb;\n\n      return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n    },\n    onChange: () => {}\n  });\n}\n\nfunction getFacetedMinMaxValues() {\n  return (instance, columnId) => memo(() => [instance.getColumn(columnId).getFacetedRowModel()], facetedRowModel => {\n    var _facetedRowModel$flat;\n\n    const firstValue = (_facetedRowModel$flat = facetedRowModel.flatRows[0]) == null ? void 0 : _facetedRowModel$flat.getValue(columnId);\n\n    if (typeof firstValue === 'undefined') {\n      return undefined;\n    }\n\n    let facetedMinMaxValues = [firstValue, firstValue];\n\n    for (let i = 0; i < facetedRowModel.flatRows.length; i++) {\n      var _facetedRowModel$flat2;\n\n      const value = (_facetedRowModel$flat2 = facetedRowModel.flatRows[i]) == null ? void 0 : _facetedRowModel$flat2.getValue(columnId);\n\n      if (value < facetedMinMaxValues[0]) {\n        facetedMinMaxValues[0] = value;\n      } else if (value > facetedMinMaxValues[1]) {\n        facetedMinMaxValues[1] = value;\n      }\n    }\n\n    return facetedMinMaxValues;\n  }, {\n    key: process.env.NODE_ENV === 'development' && 'getFacetedMinMaxValues_' + columnId,\n    debug: () => {\n      var _instance$options$deb;\n\n      return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n    },\n    onChange: () => {}\n  });\n}\n\nfunction getSortedRowModel() {\n  return instance => memo(() => [instance.getState().sorting, instance.getPreSortedRowModel()], (sorting, rowModel) => {\n    if (!rowModel.rows.length || !(sorting != null && sorting.length)) {\n      return rowModel;\n    }\n\n    const sortingState = instance.getState().sorting;\n    const sortedFlatRows = []; // Filter out sortings that correspond to non existing columns\n\n    const availableSorting = sortingState.filter(sort => instance.getColumn(sort.id).getCanSort());\n    const columnInfoById = {};\n    availableSorting.forEach(sortEntry => {\n      const column = instance.getColumn(sortEntry.id);\n      columnInfoById[sortEntry.id] = {\n        sortUndefined: column.columnDef.sortUndefined,\n        invertSorting: column.columnDef.invertSorting,\n        sortingFn: column.getSortingFn()\n      };\n    });\n\n    const sortData = rows => {\n      // This will also perform a stable sorting using the row index\n      // if needed.\n      const sortedData = rows.slice();\n      sortedData.sort((rowA, rowB) => {\n        for (let i = 0; i < availableSorting.length; i += 1) {\n          var _sortEntry$desc;\n\n          const sortEntry = availableSorting[i];\n          const columnInfo = columnInfoById[sortEntry.id];\n          const isDesc = (_sortEntry$desc = sortEntry == null ? void 0 : sortEntry.desc) != null ? _sortEntry$desc : false;\n\n          if (columnInfo.sortUndefined) {\n            const aValue = rowA.getValue(sortEntry.id);\n            const bValue = rowB.getValue(sortEntry.id);\n            const aUndefined = typeof aValue === 'undefined';\n            const bUndefined = typeof bValue === 'undefined';\n\n            if (aUndefined || bUndefined) {\n              return aUndefined && bUndefined ? 0 : aUndefined ? columnInfo.sortUndefined : -columnInfo.sortUndefined;\n            }\n          } // This function should always return in ascending order\n\n\n          let sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id);\n\n          if (sortInt !== 0) {\n            if (isDesc) {\n              sortInt *= -1;\n            }\n\n            if (columnInfo.invertSorting) {\n              sortInt *= -1;\n            }\n\n            return sortInt;\n          }\n        }\n\n        return rowA.index - rowB.index;\n      }); // If there are sub-rows, sort them\n\n      sortedData.forEach(row => {\n        sortedFlatRows.push(row);\n\n        if (!row.subRows || row.subRows.length <= 1) {\n          return;\n        }\n\n        row.subRows = sortData(row.subRows);\n      });\n      return sortedData;\n    };\n\n    return {\n      rows: sortData(rowModel.rows),\n      flatRows: sortedFlatRows,\n      rowsById: rowModel.rowsById\n    };\n  }, {\n    key: process.env.NODE_ENV === 'development' && 'getSortedRowModel',\n    debug: () => {\n      var _instance$options$deb;\n\n      return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n    },\n    onChange: () => {\n      instance._autoResetPageIndex();\n    }\n  });\n}\n\nfunction getGroupedRowModel() {\n  return instance => memo(() => [instance.getState().grouping, instance.getPreGroupedRowModel()], (grouping, rowModel) => {\n    if (!rowModel.rows.length || !grouping.length) {\n      return rowModel;\n    } // Filter the grouping list down to columns that exist\n\n\n    const existingGrouping = grouping.filter(columnId => instance.getColumn(columnId));\n    const groupedFlatRows = [];\n    const groupedRowsById = {}; // const onlyGroupedFlatRows: Row[] = [];\n    // const onlyGroupedRowsById: Record<RowId, Row> = {};\n    // const nonGroupedFlatRows: Row[] = [];\n    // const nonGroupedRowsById: Record<RowId, Row> = {};\n    // Recursively group the data\n\n    const groupUpRecursively = function (rows, depth, parentId) {\n      if (depth === void 0) {\n        depth = 0;\n      }\n\n      // This is the last level, just return the rows\n      if (depth === existingGrouping.length) {\n        return rows;\n      }\n\n      const columnId = existingGrouping[depth]; // Group the rows together for this level\n\n      const rowGroupsMap = groupBy(rows, columnId); // Peform aggregations for each group\n\n      const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map((_ref, index) => {\n        let [groupingValue, groupedRows] = _ref;\n        let id = columnId + \":\" + groupingValue;\n        id = parentId ? parentId + \">\" + id : id; // First, Recurse to group sub rows before aggregation\n\n        const subRows = groupUpRecursively(groupedRows, depth + 1, id); // Flatten the leaf rows of the rows in this group\n\n        const leafRows = depth ? flattenBy(groupedRows, row => row.subRows) : groupedRows;\n        const row = createRow(instance, id, undefined, index, depth);\n        Object.assign(row, {\n          groupingColumnId: columnId,\n          groupingValue,\n          subRows,\n          leafRows,\n          getValue: columnId => {\n            // Don't aggregate columns that are in the grouping\n            if (existingGrouping.includes(columnId)) {\n              if (row._valuesCache.hasOwnProperty(columnId)) {\n                return row._valuesCache[columnId];\n              }\n\n              if (groupedRows[0]) {\n                var _groupedRows$0$getVal;\n\n                row._valuesCache[columnId] = (_groupedRows$0$getVal = groupedRows[0].getValue(columnId)) != null ? _groupedRows$0$getVal : undefined;\n              }\n\n              return row._valuesCache[columnId];\n            }\n\n            if (row._groupingValuesCache.hasOwnProperty(columnId)) {\n              return row._groupingValuesCache[columnId];\n            } // Aggregate the values\n\n\n            const column = instance.getColumn(columnId);\n            const aggregateFn = column.getAggregationFn();\n\n            if (aggregateFn) {\n              row._groupingValuesCache[columnId] = aggregateFn(columnId, leafRows, groupedRows);\n              return row._groupingValuesCache[columnId];\n            }\n          }\n        });\n        subRows.forEach(subRow => {\n          groupedFlatRows.push(subRow);\n          groupedRowsById[subRow.id] = subRow; // if (subRow.getIsGrouped?.()) {\n          //   onlyGroupedFlatRows.push(subRow);\n          //   onlyGroupedRowsById[subRow.id] = subRow;\n          // } else {\n          //   nonGroupedFlatRows.push(subRow);\n          //   nonGroupedRowsById[subRow.id] = subRow;\n          // }\n        });\n        return row;\n      });\n      return aggregatedGroupedRows;\n    };\n\n    const groupedRows = groupUpRecursively(rowModel.rows, 0, '');\n    groupedRows.forEach(subRow => {\n      groupedFlatRows.push(subRow);\n      groupedRowsById[subRow.id] = subRow; // if (subRow.getIsGrouped?.()) {\n      //   onlyGroupedFlatRows.push(subRow);\n      //   onlyGroupedRowsById[subRow.id] = subRow;\n      // } else {\n      //   nonGroupedFlatRows.push(subRow);\n      //   nonGroupedRowsById[subRow.id] = subRow;\n      // }\n    });\n    return {\n      rows: groupedRows,\n      flatRows: groupedFlatRows,\n      rowsById: groupedRowsById\n    };\n  }, {\n    key: process.env.NODE_ENV === 'development' && 'getGroupedRowModel',\n    debug: () => {\n      var _instance$options$deb;\n\n      return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n    },\n    onChange: () => {\n      instance._queue(() => {\n        instance._autoResetExpanded();\n\n        instance._autoResetPageIndex();\n      });\n    }\n  });\n}\n\nfunction groupBy(rows, columnId) {\n  const groupMap = new Map();\n  return rows.reduce((map, row) => {\n    const resKey = \"\" + row.getValue(columnId);\n    const previous = map.get(resKey);\n\n    if (!previous) {\n      map.set(resKey, [row]);\n    } else {\n      map.set(resKey, [...previous, row]);\n    }\n\n    return map;\n  }, groupMap);\n}\n\nfunction getExpandedRowModel() {\n  return instance => memo(() => [instance.getState().expanded, instance.getPreExpandedRowModel(), instance.options.paginateExpandedRows], (expanded, rowModel, paginateExpandedRows) => {\n    if (!rowModel.rows.length || // Do not expand if rows are not included in pagination\n    !paginateExpandedRows || expanded !== true && !Object.keys(expanded != null ? expanded : {}).length) {\n      return rowModel;\n    }\n\n    return expandRows(rowModel);\n  }, {\n    key: process.env.NODE_ENV === 'development' && 'getExpandedRowModel',\n    debug: () => {\n      var _instance$options$deb;\n\n      return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n    }\n  });\n}\nfunction expandRows(rowModel, instance) {\n  const expandedRows = [];\n\n  const handleRow = row => {\n    var _row$subRows;\n\n    expandedRows.push(row);\n\n    if ((_row$subRows = row.subRows) != null && _row$subRows.length && row.getIsExpanded()) {\n      row.subRows.forEach(handleRow);\n    }\n  };\n\n  rowModel.rows.forEach(handleRow);\n  return {\n    rows: expandedRows,\n    flatRows: rowModel.flatRows,\n    rowsById: rowModel.rowsById\n  };\n}\n\nfunction getPaginationRowModel(opts) {\n  return instance => memo(() => [instance.getState().pagination, instance.getPrePaginationRowModel()], (pagination, rowModel) => {\n    if (!rowModel.rows.length) {\n      return rowModel;\n    }\n\n    const {\n      pageSize,\n      pageIndex\n    } = pagination;\n    let {\n      rows,\n      flatRows,\n      rowsById\n    } = rowModel;\n    const pageStart = pageSize * pageIndex;\n    const pageEnd = pageStart + pageSize;\n    rows = rows.slice(pageStart, pageEnd);\n\n    if (!instance.options.paginateExpandedRows) {\n      return expandRows({\n        rows,\n        flatRows,\n        rowsById\n      });\n    }\n\n    return {\n      rows,\n      flatRows,\n      rowsById\n    };\n  }, {\n    key: process.env.NODE_ENV === 'development' && 'getPaginationRowModel',\n    debug: () => {\n      var _instance$options$deb;\n\n      return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n    }\n  });\n}\n\nexport { ColumnSizing, Expanding, Filters, Grouping, Headers, Ordering, Pagination, Pinning, RowSelection, Sorting, Visibility, aggregationFns, buildHeaderGroups, createColumn, createRow, createTableFactory, createTableInstance, defaultColumnSizing, expandRows, filterFns, flattenBy, functionalUpdate, getCoreRowModel, getExpandedRowModel, getFacetedMinMaxValues, getFacetedRowModel, getFacetedUniqueValues, getFilteredRowModel, getGroupedRowModel, getPaginationRowModel, getSortedRowModel, isFunction, isRowSelected, makeStateUpdater, memo, noop, orderColumns, passiveEventSupported, reSplitAlphaNumeric, selectRowsFn, shouldAutoRemoveFilter, sortingFns };\n//# sourceMappingURL=index.js.map\n","import * as React from 'react'\nexport * from '@tanstack/table-core'\n\nimport {\n  createTableInstance,\n  TableOptions,\n  TableInstance,\n  Table,\n  TableGenerics,\n  createTableFactory,\n  Overwrite,\n  PartialKeys,\n  TableOptionsResolved,\n} from '@tanstack/table-core'\n\nexport type Renderable<TProps> =\n  | React.ReactNode\n  | React.FunctionComponent<TProps>\n  | React.Component<TProps>\n\nexport type Render = <TProps extends {}>(\n  Comp: Renderable<TProps>,\n  props: TProps\n) => React.ReactNode | JSX.Element\n\nexport type ReactTableGenerics = Overwrite<\n  TableGenerics,\n  { Renderer: Render; Rendered: ReturnType<Render> }\n>\n\n//\n\nexport const render: Render = (Comp, props) =>\n  !Comp ? null : isReactComponent(Comp) ? <Comp {...props} /> : Comp\n\nfunction isReactComponent(component: unknown): component is React.FC {\n  return (\n    isClassComponent(component) ||\n    typeof component === 'function' ||\n    isExoticComponent(component)\n  )\n}\n\nfunction isClassComponent(component: any) {\n  return (\n    typeof component === 'function' &&\n    (() => {\n      const proto = Object.getPrototypeOf(component)\n      return proto.prototype && proto.prototype.isReactComponent\n    })()\n  )\n}\n\nfunction isExoticComponent(component: any) {\n  return (\n    typeof component === 'object' &&\n    typeof component.$$typeof === 'symbol' &&\n    ['react.memo', 'react.forward_ref'].includes(component.$$typeof.description)\n  )\n}\n\nexport const createTable = createTableFactory({ render })\n\n// const useIsomorphicLayoutEffect =\n//   typeof document !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\nexport type UseTableInstanceOptions<TGenerics extends ReactTableGenerics> =\n  TableOptions<TGenerics>\n\nexport function useTableInstance<TGenerics extends ReactTableGenerics>(\n  table: Table<TGenerics>,\n  options: UseTableInstanceOptions<TGenerics>\n): TableInstance<TGenerics> {\n  // Compose in the generic options to the user options\n  const resolvedOptions: TableOptionsResolved<TGenerics> = {\n    ...table.options,\n    state: {}, // Dummy state\n    onStateChange: () => {}, // noop\n    render,\n    ...options,\n  }\n\n  // Create a new table instance and store it in state\n  const [instanceRef] = React.useState(() => ({\n    current: createTableInstance<TGenerics>(resolvedOptions),\n  }))\n\n  // By default, manage table state here using the instance's initial state\n  const [state, setState] = React.useState(\n    () => instanceRef.current.initialState\n  )\n\n  // Compose the default state above with any user state. This will allow the user\n  // to only control a subset of the state if desired.\n  instanceRef.current.setOptions(prev => ({\n    ...prev,\n    ...options,\n    state: {\n      ...state,\n      ...options.state,\n    },\n    // Similarly, we'll maintain both our internal state and any user-provided\n    // state.\n    onStateChange: updater => {\n      setState(updater)\n      options.onStateChange?.(updater)\n    },\n  }))\n\n  return instanceRef.current\n}\n"]},"metadata":{},"sourceType":"script"}